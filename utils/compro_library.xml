<templateSet group="compro_library">
  <template name="calc_fact" value="auto calc_fact = [mpow]{&#10;	constexpr int N = 2e6;&#10;	vector&lt;mint&gt; fact(N + 1, 1);&#10;	vector&lt;mint&gt; inv(N + 1, 1);&#10;	for(int i = 1; i &lt; N; ++i){&#10;		fact[i + 1] = fact[i] * (i + 1);&#10;		inv[i + 1] = mpow(fact[i + 1], MOD - 2);&#10;	}&#10;	return make_pair(fact, inv);&#10;};&#10;vector&lt;mint&gt; fact, inv;&#10;tie(fact, inv) = calc_fact();&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="divisor" value="auto divisor = [](i64 x){&#10;	int sq = sqrt(x) + 1;&#10;	vector&lt;int&gt; ret;&#10;	for(i64 i = 1; i &lt; sq; ++i)&#10;		if(!(x % i)){&#10;			ret.emplace_back(i);&#10;			if(i * i != x)&#10;				ret.emplace_back(x / i);&#10;		}&#10;	sort(ret.begin(), ret.end());&#10;	return ret;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="eratisthenes" value="auto eratosthenes = []{&#10;	constexpr int N = 2e6;&#10;	bitset&lt;N&gt; not_prime(3);&#10;	for(int i = 2; i &lt; N; ++i)&#10;		if(!not_prime[i])&#10;			for(int j = 2 * i; j &lt; N; j += i)&#10;				not_prime.set(j);&#10;	return not_prime;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="factoring" value="auto factoring = [](i64 x){&#10;	int sq = sqrt(x) + 1;&#10;	vector&lt;int&gt; ret;&#10;	if(x == 1){&#10;		ret.emplace_back(1);&#10;		return ret;&#10;	}&#10;	for(i64 i = 2; i &lt; sq; ++i)&#10;		while(x % i == 0){&#10;			ret.emplace_back(i);&#10;			x /= i;&#10;		}&#10;	if(x != 1)&#10;		ret.emplace_back(x);&#10;	return ret;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="gcd" value="auto gcd = [](i64 x, i64 y){&#10;	while(y){&#10;		i64 z = x % y;&#10;		x = y;&#10;		y = z;&#10;	}&#10;	return x;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lcm" value="auto lcm = [gcd](i64 x, i64 y){&#10;	return x * y / gcd(x, y);&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="mo_query" value="template &lt;typename ResultType&gt;&#10;vector&lt;ResultType&gt; mo_query(Mo&amp; mo, vector&lt;pair&lt;int,int&gt;&gt;&amp; queries, function&lt;ResultType(int)&gt; get_func, int packet=512){&#10;    int q = queries.size();&#10;    vector&lt;tuple&lt;int,int,int&gt;&gt; sort_queries;&#10;    for(int i = 0; i &lt; q; ++i)&#10;        sort_queries.emplace_back(queries[i].first / packet, queries[i].second, i);&#10;    sort(sort_queries.begin(), sort_queries.end());&#10;    vector&lt;ResultType&gt; ans(q);&#10;    for(auto&amp; query : sort_queries){&#10;        int idx = get&lt;2&gt;(query);&#10;        mo.move(queries[idx].first, queries[idx].second);&#10;        ans[idx] = get_func(idx);&#10;    }&#10;    return ans;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="modpow" value="auto mpow = [](auto x, i64 y){&#10;	auto z = x;&#10;	decltype(x) val = y &amp; 1 ? x : decltype(x)(1);&#10;	while(z *= z, y &gt;&gt;= 1)&#10;		if(y &amp; 1)&#10;			val *= z;&#10;	return val;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="ncr" value="auto ncr = [&amp;fact, &amp;inv](int n, int r){&#10;	if(n &lt; 0 || r &lt; 0 || n &lt; r)&#10;		return mint(0);&#10;	return fact[n] * inv[r] * inv[n - r];&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="nhr" value="auto nhr = [ncr](int n, int r){&#10;	return ncr(n + r - 1, r);&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="scc" value="vector&lt;int&gt; scc(vector&lt;vector&lt;int&gt;&gt;&amp; edges){&#10;    int n = edges.size();&#10;    vector&lt;vector&lt;int&gt;&gt; rev(n);&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        for(auto&amp; x : edges[i])&#10;            rev[x].emplace_back(i);&#10;&#10;    vector&lt;i64&gt; dfs_num(n, -1);&#10;    vector&lt;i64&gt; flag(n, 0);&#10;    int num = 0;&#10;    function&lt;void(int)&gt; dfs = [&amp;](int pos){&#10;        flag[pos] = 1;&#10;        for(auto&amp; xx : edges[pos])&#10;            if(!flag[xx]){&#10;                dfs(xx);&#10;        }&#10;        dfs_num[pos] = num++;&#10;    };&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        if(!flag[i])&#10;            dfs(i);&#10;&#10;    vector&lt;int&gt; dfs_inv(n);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        dfs_inv[n - 1 - dfs_num[i]] = i;&#10;&#10;    num = 0;&#10;&#10;    vector&lt;int&gt; scc_vec(n, -1);&#10;&#10;    function&lt;void(int)&gt; rdfs = [&amp;](int pos){&#10;        scc_vec[pos] = num;&#10;        for(auto t : rev[pos])&#10;            if(scc_vec[t] == -1)&#10;                rdfs(t);&#10;    };&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        if(scc_vec[dfs_inv[i]] == -1){&#10;            rdfs(dfs_inv[i]);&#10;            ++num;&#10;        }&#10;&#10;    return scc_vec;&#10;}&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="scc_dag" value="struct Result{&#10;    int dag_size;&#10;    vector&lt;vector&lt;int&gt;&gt; dag_graph;&#10;    // 元のグラフでi番目の頂点が何番目の強連結成分に含まれるか&#10;    vector&lt;int&gt; elements;&#10;    // i番目の強連結成分に含まれる頂点のリスト&#10;    vector&lt;vector&lt;int&gt;&gt; tps_list;&#10;    // トポソしてi番目にくる頂点のindex&#10;    vector&lt;int&gt; tps_order;&#10;    // DAGのi番目の頂点をトポソした時の番号&#10;    vector&lt;int&gt; tps_index;&#10;};&#10;&#10;Result scc_dag(vector&lt;vector&lt;int&gt;&gt;&amp; edges){&#10;    int n = edges.size();&#10;    vector&lt;int&gt; scc_vec = scc(edges);&#10;    int m = *max_element(scc_vec.begin(), scc_vec.end()) + 1;&#10;    vector&lt;vector&lt;int&gt;&gt; dag_graph(m);&#10;&#10;    queue&lt;int&gt; tps_que;&#10;    vector&lt;int&gt; in_count(m, 0);&#10;    vector&lt;int&gt; tps(m, -1);&#10;    vector&lt;int&gt; tps_idx(m);&#10;    for(int i = 0; i &lt; n; ++i){&#10;        for(auto j : edges[i]){&#10;            if(scc_vec[i] == scc_vec[j])&#10;                continue;&#10;            dag_graph[scc_vec[i]].push_back(scc_vec[j]);&#10;            ++in_count[scc_vec[j]];&#10;        }&#10;    }&#10;    for(int i = 0; i &lt; m; ++i)&#10;        if(in_count[i] == 0)&#10;            tps_que.push(i);&#10;    int cnt = 0;&#10;    while(!tps_que.empty()){&#10;        int x = tps_que.front();&#10;        tps_idx[x] = cnt;&#10;        tps[cnt++] = x;&#10;        tps_que.pop();&#10;        for(auto y : dag_graph[x])&#10;            if(--in_count[y] == 0)&#10;                tps_que.push(y);&#10;    }&#10;    assert(cnt == m);&#10;&#10;    vector&lt;vector&lt;int&gt;&gt; tps_list(m);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        tps_list[scc_vec[i]].push_back(i);&#10;&#10;    Result res;&#10;    res.dag_size = m;&#10;    res.elements = move(scc_vec);&#10;    res.tps_index = move(tps_idx);&#10;    res.tps_order = move(tps);&#10;    res.tps_list = move(tps_list);&#10;    res.dag_graph = move(dag_graph);&#10;    return res;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="simple_graph" value="template &lt;typename T = pair&lt;int,int&gt;&gt;&#10;vector&lt;vector&lt;int&gt;&gt; simple_graph(vector&lt;vector&lt;T&gt;&gt;&amp; edges, function&lt;int(T)&gt; f = [](auto x){return x.first;}){&#10;    vector&lt;vector&lt;int&gt;&gt; simple_edges(edges.size());&#10;    for(int i = 0; i &lt; edges.size(); ++i)&#10;        for(auto&amp; x : edges[i])&#10;            simple_edges[i].push_back(f(x));&#10;    return simple_edges;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="twoedgeconnectedcomponents_tree" value="struct Result{&#10;    int group_cnt;&#10;    vector&lt;int&gt; group;&#10;    vector&lt;vector&lt;int&gt;&gt; group_elm_list;&#10;    // 同じ二重辺連結成分の辺をグループごとに列挙する, 片方向のみ(辺数倍化しない)&#10;    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; same_group_edges;&#10;    // 橋, 片方向のみ&#10;    vector&lt;pair&lt;int,int&gt;&gt; bridges;&#10;    // 関節点&#10;    vector&lt;int&gt; arts;&#10;    vector&lt;vector&lt;int&gt;&gt; tree_graph;&#10;    vector&lt;int&gt; par;&#10;    vector&lt;vector&lt;int&gt;&gt; childs;&#10;};&#10;&#10;Result two_edge_connected_components_tree(vector&lt;vector&lt;int&gt;&gt;&amp; edges){&#10;    int n = edges.size();&#10;    LowLink ll(edges);&#10;    vector&lt;vector&lt;int&gt;&gt; not_bridge_graph(n);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        for(auto j : edges[i]){&#10;            pair&lt;int,int&gt; min_max = minmax(i, j);&#10;            auto iter = lower_bound(ll.bridge.begin(), ll.bridge.end(), min_max);&#10;            if(iter == ll.bridge.end() || *iter != min_max)&#10;                not_bridge_graph[i].push_back(j);&#10;        }&#10;&#10;    vector&lt;int&gt; group(n, -1);&#10;    function&lt;void(int)&gt; group_dfs = [&amp;](int x){&#10;        for(auto y : not_bridge_graph[x])&#10;            if(group[y] == -1){&#10;                group[y] = group[x];&#10;                group_dfs(y);&#10;            }&#10;    };&#10;    int group_cnt = 0;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        if(group[i] == -1){&#10;            group[i] = group_cnt++;&#10;            group_dfs(i);&#10;        }&#10;    vector&lt;vector&lt;int&gt;&gt; group_elm_list(group_cnt);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        group_elm_list[group[i]].push_back(i);&#10;&#10;    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; same_group_edges(group_cnt);&#10;    vector&lt;vector&lt;int&gt;&gt; tree_edges(group_cnt);&#10;    vector&lt;int&gt; par(group_cnt, -1);&#10;    vector&lt;vector&lt;int&gt;&gt; childs(group_cnt);&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        for(auto j : edges[i])&#10;            if(group[i] == group[j] &amp;&amp; i &lt; j)&#10;                same_group_edges[group[i]].emplace_back(i, j);&#10;&#10;    for(auto&amp; p : ll.bridge){&#10;        tree_edges[group[p.first]].push_back(group[p.second]);&#10;        tree_edges[group[p.second]].push_back(group[p.first]);&#10;    }&#10;    vector&lt;bool&gt; flag(n, false);&#10;    function&lt;void(int)&gt; tree_dfs = [&amp;](int x){&#10;        for(auto y : tree_edges[x])&#10;            if(!flag[y]){&#10;                flag[y] = true;&#10;                par[y] = x;&#10;                childs[x].push_back(y);&#10;                tree_dfs(y);&#10;            }&#10;    };&#10;    flag[0] = true;&#10;    tree_dfs(0);&#10;&#10;    Result res;&#10;    res.group_cnt = group_cnt;&#10;    res.group_elm_list = move(group_elm_list);&#10;    res.same_group_edges = move(same_group_edges);&#10;    res.bridges = move(ll.bridge);&#10;    res.arts = move(ll.art);&#10;    res.group = move(group);&#10;    res.tree_graph = move(tree_edges);&#10;    res.par = move(par);&#10;    res.childs = move(childs);&#10;    return res;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="avl" value="template &lt;typename T&gt;&#10;struct AVL{&#10;    template &lt;typename U&gt;&#10;    struct Node{&#10;        int size, height;&#10;        U val, sum;&#10;        Node(U val, Node&lt;U&gt;* nil) : val(val), sum(val), size(1), height(1){c[0] = nil; c[1] = nil;}&#10;        Node&lt;U&gt;* c[2];&#10;    };&#10;&#10;    using NodePtr = Node&lt;T&gt;*;&#10;    function&lt;T(T, T)&gt; f = [](auto x, auto y){return x + y;};&#10;    T op;&#10;    NodePtr nil;&#10;&#10;    AVL(function&lt;T(T, T)&gt; f, T op) : f(f), op(op){&#10;        nil = new Node&lt;T&gt;(op, nullptr);&#10;        nil-&gt;size = 0;&#10;        nil-&gt;height = 0;&#10;        nil-&gt;c[0] = nil;&#10;        nil-&gt;c[1] = nil;&#10;    }&#10;&#10;    template &lt;bool inv&gt;&#10;    int balance_factor(NodePtr x){return (x-&gt;c[0]-&gt;height - x-&gt;c[1]-&gt;height) * (inv ? -1 : 1);}&#10;    void _update(NodePtr x){&#10;        if(x == nil)&#10;            return;&#10;        x-&gt;size = x-&gt;c[0]-&gt;size + x-&gt;c[1]-&gt;size + 1;&#10;        x-&gt;height = max(x-&gt;c[0]-&gt;height, x-&gt;c[1]-&gt;height) + 1;&#10;        x-&gt;sum = f(f(x-&gt;c[0]-&gt;sum, x-&gt;val), x-&gt;c[1]-&gt;sum);&#10;    }&#10;    template &lt;bool is_right&gt;&#10;    NodePtr rotate(NodePtr x){&#10;        NodePtr new_root = x-&gt;c[1 ^ is_right];&#10;        x-&gt;c[1 ^ is_right] = new_root-&gt;c[0 ^ is_right];&#10;        new_root-&gt;c[0 ^ is_right] = x;&#10;        _update(x);&#10;        _update(new_root);&#10;        return new_root;&#10;    }&#10;    template &lt;bool inv&gt;&#10;    NodePtr _balance(NodePtr x){&#10;        if(balance_factor&lt;inv&gt;(x) == 2){&#10;            if(balance_factor&lt;inv&gt;(x-&gt;c[0 ^ inv]) &lt; 0)&#10;                x-&gt;c[0 ^ inv] = rotate&lt;inv&gt;(x-&gt;c[0 ^ inv]);&#10;            x = rotate&lt;1 ^ inv&gt;(x);&#10;        }&#10;        return x;&#10;    }&#10;    NodePtr balance(NodePtr x){&#10;        x = _balance&lt;false&gt;(x);&#10;        x = _balance&lt;true&gt;(x);&#10;        _update(x);&#10;        return x;&#10;    }&#10;    NodePtr insert(NodePtr x, int idx, T val){&#10;        if(x == nil)&#10;            return new Node&lt;T&gt;(val, nil);&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt;= left_size)&#10;            x-&gt;c[0] = insert(x-&gt;c[0], idx, val);&#10;        else&#10;            x-&gt;c[1] = insert(x-&gt;c[1], idx - left_size - 1, val);&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;&#10;    // 子が片方しかない時にノードを削除する&#10;    NodePtr _erase_top(NodePtr x, bool del){&#10;        for(int i = 0; i &lt; 2; ++i){&#10;            if(x-&gt;c[i] == nil){&#10;                NodePtr new_node = x-&gt;c[i ^ 1];&#10;                if(del)&#10;                    delete(x);&#10;                return new_node;&#10;            }&#10;        }&#10;    }&#10;    // 最小の要素をdstにコピーしてから削除する&#10;    NodePtr _copy_erase(NodePtr x, NodePtr dst, bool del){&#10;        if(x-&gt;c[0] == nil){&#10;            dst-&gt;val = x-&gt;val;&#10;            return _erase_top(x, del);&#10;        }&#10;        x-&gt;c[0] = _copy_erase(x-&gt;c[0], dst, del);&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;    NodePtr erase(NodePtr x, int idx, bool del = true){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            x-&gt;c[0] = erase(x-&gt;c[0], idx, del);&#10;        else if(left_size &lt; idx)&#10;            x-&gt;c[1] = erase(x-&gt;c[1], idx - left_size - 1, del);&#10;        else{&#10;            if(x-&gt;c[0] == nil || x-&gt;c[1] == nil)&#10;                return _erase_top(x, del);&#10;            x-&gt;c[1] = _copy_erase(x-&gt;c[1], x, del);&#10;        }&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;    NodePtr getNode(NodePtr x, int idx){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            return getNode(x-&gt;c[0], idx);&#10;        else if(left_size &lt; idx)&#10;            return getNode(x-&gt;c[1], idx - left_size - 1);&#10;        else&#10;            return x;&#10;    }&#10;    T get(NodePtr x, int l, int r){&#10;        if(l &lt;= 0 &amp;&amp; x-&gt;size &lt;= r)&#10;            return x-&gt;sum;&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        T res = op;&#10;        if(l &lt;= left_size &amp;&amp; left_size &lt; r)&#10;            res = x-&gt;val;&#10;        if(l &lt; left_size)&#10;            res = f(get(x-&gt;c[0], l, r), res);&#10;        if(left_size + 1 &lt; r)&#10;            res = f(res, get(x-&gt;c[1], l - left_size - 1, r - left_size - 1));&#10;        return res;&#10;    }&#10;    NodePtr update(NodePtr x, int idx, T val, function&lt;T(T, T)&gt; g = [](auto x, auto y){return x + y;}){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            x-&gt;c[0] = update(x-&gt;c[0], idx, val, g);&#10;        else if(left_size &lt; idx)&#10;            x-&gt;c[1] = update(x-&gt;c[1], idx - left_size - 1, val, g);&#10;        else&#10;            x-&gt;val = g(x-&gt;val, val);&#10;        _update(x);&#10;&#10;        return x;&#10;    }&#10;    NodePtr set(NodePtr x, int idx, T val){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            x-&gt;c[0] = set(x-&gt;c[0], idx, val);&#10;        else if(left_size &lt; idx)&#10;            x-&gt;c[1] = set(x-&gt;c[1], idx - left_size - 1, val);&#10;        else&#10;            x-&gt;val = val;&#10;        _update(x);&#10;        return x;&#10;    }&#10;&#10;    void print(NodePtr x, int p = 0){&#10;        if(x == nil)return;&#10;        if(p == 0)&#10;            cout &lt;&lt; &quot;----print----&quot; &lt;&lt; endl;&#10;        print(x-&gt;c[0], p + 12);&#10;        for(int i = 0; i &lt; p; ++i)&#10;            cout &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;val:&quot; &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;sum:&quot; &lt;&lt; x-&gt;sum &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;size:&quot; &lt;&lt; x-&gt;size &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;height:&quot; &lt;&lt; x-&gt;height &lt;&lt; endl;&#10;        print(x-&gt;c[1], p + 12);&#10;        if(p == 0)&#10;            cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="binaryindexedtree" value="template &lt;typename T&gt;&#10;struct BIT{&#10;    vector&lt;T&gt; elm;&#10;    BIT(int n, T init = T()) : elm(n + 1, init){&#10;    }&#10;&#10;    // [0, x)&#10;    T sum(int x){&#10;        T val = 0;&#10;        for(; x &gt; 0; x -= x &amp; -x)&#10;            val += elm[x];&#10;        return val;&#10;    }&#10;&#10;    // [l, r)&#10;    T sum(int l, int r){&#10;        return sum(r) - sum(l);&#10;    }&#10;&#10;    void add(int x, T val){&#10;        for(++x; x &lt; elm.size(); x += x &amp; -x)&#10;            elm[x] += val;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="binarylifting" value="struct BinaryLifting{&#10;    int n;&#10;    vector&lt;vector&lt;int&gt;&gt; next;&#10;    vector&lt;int&gt; par;&#10;    vector&lt;vector&lt;int&gt;&gt; childs;&#10;    vector&lt;int&gt; depth;&#10;&#10;    BinaryLifting(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int root = 0) : n(edges.size()), depth(n, -1), par(n, -1), childs(n){&#10;        function&lt;void(int)&gt; dfs = [&amp;](int x){&#10;            for(auto y : edges[x])&#10;                if(depth[y] == -1){&#10;                    depth[y] = depth[x] + 1;&#10;                    par[y] = x;&#10;                    childs[x].push_back(y);&#10;                    dfs(y);&#10;                }&#10;        };&#10;        depth[root] = 0;&#10;        dfs(0);&#10;&#10;        next.push_back(move(par));&#10;        for(int k = 0;; ++k){&#10;            bool fl = false;&#10;            next.emplace_back(n, -1);&#10;            for(int i = 0; i &lt; n; ++i){&#10;                next[k + 1][i] = (next[k][i] == -1 ? -1 : next[k][next[k][i]]);&#10;                if(next[k + 1][i] != -1)&#10;                    fl = true;&#10;            }&#10;            if(!fl)&#10;                break;&#10;        }&#10;    }&#10;    // kth_next(x, 0) =&gt; x&#10;    int kth_next(int x, int k){&#10;        for(int i = 0; i &lt; next.size() &amp;&amp; k; ++i){&#10;            if(k &amp; (1 &lt;&lt; i)){&#10;                x = next[i][x];&#10;                if(x == -1)&#10;                    break;&#10;            }&#10;        }&#10;        return x;&#10;    }&#10;&#10;    int lca(int x, int y){&#10;        int min_depth = min(depth[x], depth[y]);&#10;        x = kth_next(x, depth[x] - min_depth);&#10;        y = kth_next(y, depth[y] - min_depth);&#10;        if(x == y)&#10;            return x;&#10;        for(int i = next.size() - 1; i &gt;= 0; --i)&#10;            if(next[i][x] != next[i][y]){&#10;                x = next[i][x];&#10;                y = next[i][y];&#10;            }&#10;        return next[0][x];&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="compression" value="template&lt;typename T&gt;&#10;struct Compression{&#10;    vector&lt;T&gt; compvec;&#10;    Compression(vector&lt;T&gt;&amp; inp){//圧縮する&#10;        compvec = inp;&#10;        sort(compvec.begin(), compvec.end());&#10;        compvec.erase(unique(compvec.begin(), compvec.end()), compvec.end());&#10;    }&#10;    int Index(T val){//圧縮を元に対応するインデックスを返す&#10;        auto it = lower_bound(compvec.begin(), compvec.end(), val);&#10;        return distance(compvec.begin(), it);&#10;    }&#10;    vector&lt;T&gt;&amp; operator*(){&#10;        return compvec;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="convexhulltrick" value="template &lt;typename T, typename U&gt;&#10;struct ConvexHullTrick{&#10;    // 任意の2関数で共有点が高々1個ならElmの中身を適切に変えれば通る&#10;&#10;    struct Elm{&#10;        T a, b;&#10;        U operator()(T x){&#10;            return a * x + b;&#10;        }&#10;    };&#10;&#10;    struct Node{&#10;        Elm f;&#10;        Node* l;&#10;        Node* r;&#10;        Node(Elm elm) : f(elm), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    U _min, _max, _inf;&#10;    Node* root;&#10;&#10;    ConvexHullTrick(U _min, U _max, U _inf) :&#10;        _min(_min),&#10;        _max(_max),&#10;        _inf(_inf),&#10;        root(nullptr)&#10;    {&#10;    }&#10;&#10;    Node* _insert(Node* p, T st, T en, Elm f){&#10;        if(!p)&#10;            return new Node(f);&#10;        if(p-&gt;f(st) &lt;= f(st) &amp;&amp; p-&gt;f(en) &lt;= f(en))&#10;            return p;&#10;        if(p-&gt;f(st) &gt;= f(st) &amp;&amp; p-&gt;f(en) &gt;= f(en)){&#10;            p-&gt;f = f;&#10;            return p;&#10;        }&#10;        T mid = (st + en) / 2;&#10;        if(p-&gt;f(mid) &gt; f(mid))&#10;            swap(p-&gt;f, f);&#10;        if(p-&gt;f(st) &gt;= f(st))&#10;            p-&gt;l = _insert(p-&gt;l, st, mid, f);&#10;        else&#10;            p-&gt;r = _insert(p-&gt;r, mid, en, f);&#10;        return p;&#10;    }&#10;&#10;    U _query(Node* p, T st, T en, T x){&#10;        if(!p)&#10;            return _inf;&#10;        if(st == en)&#10;            return p-&gt;f(x);&#10;        T mid = (st + en) / 2;&#10;        if(x &lt;= mid)&#10;            return min(p-&gt;f(x), _query(p-&gt;l, st, mid, x));&#10;        else&#10;            return min(p-&gt;f(x), _query(p-&gt;r, mid, en, x));&#10;    }&#10;&#10;    void insert(Elm f){&#10;        root = _insert(root, _min, _max, f);&#10;    }&#10;&#10;    U query(T x){&#10;        return _query(root, _min, _max, x);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dinic" value="template &lt;typename T&gt;&#10;struct Dinic{&#10;    struct Edge{&#10;        int to, rev;&#10;        T cap;&#10;        Edge(int to, T cap, int rev) : to(to), rev(rev), cap(cap){}&#10;    };&#10;&#10;    vector&lt;vector&lt;Edge&gt;&gt; edges;&#10;    T _inf;&#10;    vector&lt;T&gt; min_cost;&#10;    vector&lt;int&gt; cnt;&#10;&#10;    Dinic(int n) : edges(n), _inf(numeric_limits&lt;T&gt;::max()){}&#10;&#10;    void add(int from, int to, T cap){&#10;        edges[from].emplace_back(to, cap, static_cast&lt;int&gt;(edges[to].size()));&#10;        edges[to].emplace_back(from, 0, static_cast&lt;int&gt;(edges[from].size()) - 1);&#10;    }&#10;&#10;    bool bfs(int s, int t){&#10;        min_cost.assign(edges.size(), -1);&#10;        queue&lt;int&gt; que;&#10;        min_cost[s] = 0;&#10;        que.emplace(s);&#10;        while(!que.empty() &amp;&amp; min_cost[t] == -1){&#10;            int x = que.front();&#10;            que.pop();&#10;            for(auto&amp; ed : edges[x])&#10;                if(ed.cap &gt; 0 &amp;&amp; min_cost[ed.to] == -1){&#10;                    min_cost[ed.to] = min_cost[x] + 1;&#10;                    que.emplace(ed.to);&#10;                }&#10;        }&#10;        return min_cost[t] != -1;&#10;    }&#10;&#10;    T dfs(int idx, int t, T flow){&#10;        if(idx == t)&#10;            return flow;&#10;        T ret = 0;&#10;        while(cnt[idx] &lt; edges[idx].size()){&#10;            auto&amp; ed = edges[idx][cnt[idx]];&#10;            if(ed.cap &gt; 0 &amp;&amp; min_cost[idx] &lt; min_cost[ed.to]){&#10;                T d = dfs(ed.to, t, min(flow, ed.cap));&#10;                ed.cap -= d;&#10;                edges[ed.to][ed.rev].cap += d;&#10;                ret += d;&#10;                flow -= d;&#10;                if(flow == 0)&#10;                    break;&#10;            }&#10;            ++cnt[idx];&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    T solve(int s, int t){&#10;        T flow = 0;&#10;        while(bfs(s, t)){&#10;            cnt.assign(edges.size(), 0);&#10;            T f = 0;&#10;            while((f = dfs(s, t, _inf)) &gt; 0)&#10;                flow += f;&#10;        }&#10;        return flow;&#10;    }&#10;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="disjointsparsetable" value="template &lt;typename T&gt;&#10;struct DisjointSparseTable{&#10;    function&lt;T(T, T)&gt; f;&#10;    vector&lt;vector&lt;T&gt;&gt; v;&#10;&#10;    DisjointSparseTable(vector&lt;T&gt;&amp; inp, function&lt;T(T, T)&gt; f) : f(f){&#10;        int n = inp.size();&#10;        int b;&#10;        for(b = 0; (1 &lt;&lt; b) &lt;= inp.size(); ++b);&#10;        v.assign(b, vector&lt;T&gt;(n));&#10;        for(int i = 0; i &lt; n; ++i)&#10;            v[0][i] = inp[i];&#10;        for(int i = 1; i &lt; b; ++i){&#10;            int siz = 1 &lt;&lt; i;&#10;            for(int j = 0; j &lt; n; j += siz &lt;&lt; 1){&#10;                int t = min(j + siz, n);&#10;                v[i][t - 1] = inp[t - 1];&#10;                for(int k = t - 2; k &gt;= j; --k)&#10;                    v[i][k] = f(inp[k], v[i][k + 1]);&#10;                if(t &gt;= n)&#10;                    break;&#10;                v[i][t] = inp[t];&#10;                int r = min(t + siz, n);&#10;                for(int k = t + 1; k &lt; r; ++k)&#10;                    v[i][k] = f(v[i][k - 1], inp[k]);&#10;            }&#10;        }&#10;    }&#10;&#10;    T get(int l, int r){&#10;        if(l &gt;= --r)&#10;            return v[0][l];&#10;        int p = 31 - __builtin_clz(l ^ r);&#10;        return f(v[p][l], v[p][r]);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dynamiclazysegmenttree" value="template&lt;typename T, typename U&gt;&#10;struct Segtree{&#10;&#10;    struct SegNode{&#10;        T val;&#10;        U lazy;&#10;&#10;        SegNode* l;&#10;        SegNode* r;&#10;        SegNode(T val, U lazy) : val(val), lazy(lazy), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    i64 n;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;    T op_t;&#10;    U op_u;&#10;&#10;    SegNode* root;&#10;&#10;    Segtree(int n_, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t, U op_u) : f(f), g(g), h(h), op_t(op_t), op_u(op_u){&#10;        for(n = 1; n &lt; n_; n &lt;&lt;= 1);&#10;        root = new SegNode(op_t, op_u);&#10;    }&#10;&#10;    SegNode* getl(SegNode* node){&#10;        return node-&gt;l ? node-&gt;l : node-&gt;l = new SegNode(op_t, op_u);&#10;    }&#10;&#10;    SegNode* getr(SegNode* node){&#10;        return node-&gt;r ? node-&gt;r : node-&gt;r = new SegNode(op_t, op_u);&#10;    }&#10;&#10;    void eval(SegNode* node, i64 len){&#10;        node-&gt;val = g(node-&gt;val, node-&gt;lazy, len);&#10;        getl(node);&#10;        node-&gt;l-&gt;lazy = h(node-&gt;l-&gt;lazy, node-&gt;lazy);&#10;        getr(node);&#10;        node-&gt;r-&gt;lazy = h(node-&gt;r-&gt;lazy, node-&gt;lazy);&#10;        node-&gt;lazy = op_u;&#10;    }&#10;&#10;    void update(i64 x, i64 y, U val, SegNode* node = nullptr, i64 l = 0, i64 r = 0){&#10;        if(node == nullptr){&#10;            node = root;&#10;            r = n;&#10;        }&#10;        eval(node, r - l);&#10;        if(r &lt;= x || y &lt;= l)&#10;            return ;&#10;        if(x &lt;= l &amp;&amp; r &lt;= y){&#10;            node-&gt;lazy = h(node-&gt;lazy, val);&#10;            eval(node, r - l);&#10;        }else{&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;            update(x, y, val, getl(node), l, mid);&#10;            update(x, y, val, getr(node), mid, r);&#10;            node-&gt;val = f(node-&gt;l-&gt;val, node-&gt;r-&gt;val);&#10;        }&#10;    }&#10;&#10;    T get(i64 x, i64 y, SegNode* node = nullptr, i64 l = 0, i64 r = 0){&#10;        if(node	== nullptr){&#10;            node = root;&#10;            r = n;&#10;        }&#10;&#10;        if(r &lt;= x || y &lt;= l)&#10;            return op_t;&#10;        eval(node, r - l);&#10;        if(x &lt;= l &amp;&amp; r &lt;= y)&#10;            return node-&gt;val;&#10;&#10;        i64 val_l = op_t, val_r = op_t;&#10;        i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;        if(node-&gt;l)&#10;            val_l = get(x, y, node-&gt;l, l, mid);&#10;        if(node-&gt;r)&#10;            val_r = get(x, y, node-&gt;r, mid, r);&#10;        return f(val_l, val_r);&#10;    }&#10;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dynamicsegmenttree" value="template &lt;typename T&gt;&#10;struct Segtree{&#10;&#10;    struct SegNode;&#10;&#10;    struct SegNode{&#10;        T val;&#10;        SegNode* l;&#10;        SegNode* r;&#10;&#10;        SegNode(T val) : val(val), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    i64 n;&#10;    function&lt;T(T, T)&gt; f;&#10;    T op;&#10;    SegNode* root;&#10;&#10;    Segtree(int n_, function&lt;T(T, T)&gt; f, T op) : f(f), op(op){&#10;        for(n = 1; n &lt; n_; n &lt;&lt;= 1);&#10;        root = new SegNode(op);&#10;    }&#10;&#10;    SegNode* getl(SegNode* node, T val){&#10;        return node-&gt;l == nullptr ? node-&gt;l = new SegNode(val) : node-&gt;l;&#10;    }&#10;&#10;    SegNode* getr(SegNode* node, T val){&#10;        return node-&gt;r == nullptr ? node-&gt;r = new SegNode(val) : node-&gt;r;&#10;    }&#10;&#10;    void eval(SegNode* node){&#10;        node-&gt;val = f(node-&gt;l == nullptr ? op : node-&gt;l-&gt;val, node-&gt;r == nullptr ? op : node-&gt;r-&gt;val);&#10;    }&#10;&#10;    void set(i64 x, T val){&#10;        assert(0 &lt;= x &amp;&amp; x &lt; n);&#10;&#10;        SegNode* node = root;&#10;        stack&lt;SegNode*&gt; nodes;&#10;        i64 l = 0, r = n;&#10;&#10;        while(r - l &gt; 1){&#10;            nodes.push(node);&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;            if(x &lt; mid){&#10;                node = getl(node, x);&#10;                r = mid;&#10;            }else{&#10;                node = getr(node, x);&#10;                l = mid;&#10;            }&#10;        }&#10;&#10;        node-&gt;val = val;&#10;        while(!nodes.empty()){&#10;            eval(nodes.top());&#10;            nodes.pop();&#10;        }&#10;    }&#10;&#10;    void update(i64 x, T val){&#10;        assert(0 &lt;= x &amp;&amp; x &lt; n);&#10;&#10;        SegNode* node = root;&#10;        stack&lt;SegNode*&gt; nodes;&#10;        i64 l = 0, r = n;&#10;&#10;        while(r - l &gt; 1){&#10;            nodes.push(node);&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;            if(x &lt; mid){&#10;                node = getl(node, x);&#10;                r = mid;&#10;            }else{&#10;                node = getr(node, x);&#10;                l = mid;&#10;            }&#10;        }&#10;&#10;        node-&gt;val = f(node-&gt;val, val);&#10;        while(!nodes.empty()){&#10;            eval(nodes.top());&#10;            nodes.pop();&#10;        }&#10;    }&#10;&#10;    T get(i64 x, i64 y, SegNode* node = nullptr, i64 l = 0,  i64 r = 0){&#10;&#10;        if(node == nullptr){&#10;            node = root;&#10;            r = n;&#10;        }&#10;&#10;        if(x &lt;= l &amp;&amp; r &lt;= y)&#10;            return node-&gt;val;&#10;&#10;        if(r &lt;= x || y &lt;= l)&#10;            return op;&#10;&#10;        T val_l = op, val_r = op;&#10;        i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;        if(node-&gt;l != nullptr)&#10;            val_l = f(val_l, get(x, y, node-&gt;l, l, mid));&#10;        if(node-&gt;r != nullptr)&#10;            val_r = f(get(x, y, node-&gt;r, mid, r), val_r);&#10;&#10;        return f(val_l, val_r);&#10;    }&#10;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="eulertour" value="struct EulerTour{&#10;    int n;&#10;    vector&lt;int&gt; in, out;&#10;    EulerTour(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int par = 0) : n(edges.size()), in(n, -1), out(n, -1){&#10;        int cnt = 0;&#10;        function&lt;void(int)&gt; f = [&amp;](int x){&#10;            in[x] = cnt++;&#10;            for(auto y : edges[x]){&#10;                if(in[y] == -1)&#10;                    f(y);&#10;            }&#10;            out[x] = cnt;&#10;        };&#10;        f(par);&#10;    }&#10;    int get_pos(int x){&#10;        return in[x];&#10;    }&#10;    // 自身を含みたくない場合は(in[x] + 1, out[x])&#10;    pair&lt;int,int&gt; get_subtree(int x){&#10;        return make_pair(in[x], out[x]);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="heavylightdecomposition" value="class HeavyLightDecomposition{&#10;public:&#10;    int n;&#10;    vector&lt;vector&lt;int&gt;&gt; g;&#10;    vector&lt;int&gt; rev, in, out, nxt, rin, size, depth;&#10;&#10;    HeavyLightDecomposition(vector&lt;vector&lt;int&gt;&gt;&amp; inp) :&#10;        n(inp.size()),&#10;        g(n),&#10;        rev(n, 0),&#10;        in(n, 0),&#10;        out(n, 0),&#10;        nxt(n, 0),&#10;        rin(n, 0),&#10;        size(n, 0),&#10;        depth(n, -1)&#10;    {&#10;&#10;        function&lt;void(int, int)&gt; dfs_ed = [&amp;](int pos, int dep){&#10;            depth[pos]=dep;&#10;            for(auto ed : inp[pos])&#10;                if(depth[ed] == -1){&#10;                    g[pos].emplace_back(ed);&#10;                    rev[ed] = pos;&#10;                    dfs_ed(ed, dep + 1);&#10;                }&#10;        };&#10;        dfs_ed(0, 0);&#10;&#10;        function&lt;void(int)&gt; dfs_sz = [&amp;](int v){&#10;            size[v] = 1;&#10;            for(auto &amp;u: g[v]){&#10;                dfs_sz(u);&#10;                size[v] += size[u];&#10;                if(size[u] &gt; size[g[v][0]])&#10;                    swap(u, g[v][0]);&#10;            }&#10;        };&#10;        dfs_sz(0);&#10;&#10;        int t = 0;&#10;&#10;        function&lt;void(int)&gt; dfs_hld = [&amp;](int v){&#10;            in[v] = t++;&#10;            rin[in[v]] = v;&#10;            for(auto u: g[v]){&#10;                nxt[u] = (u == g[v][0] ? nxt[v] : u);&#10;                dfs_hld(u);&#10;            }&#10;            out[v] = t;&#10;        };&#10;        dfs_hld(0);&#10;    }&#10;&#10;    pair&lt;int,int&gt; subtree(int x){&#10;        return make_pair(in[x], out[x]);&#10;    }&#10;&#10;    vector&lt;int&gt; subtree_path(int x){&#10;        return vector&lt;int&gt;(next(rin.begin(), in[x]), next(rin.begin(), out[x]));&#10;    }&#10;&#10;    pair&lt;int,int&gt; subsegment(int x){&#10;        return make_pair(in[nxt[x]], in[x] + 1);&#10;    }&#10;&#10;    vector&lt;int&gt; subsegment_path(int x){&#10;        return vector&lt;int&gt;(next(rin.begin(), in[nxt[x]]), next(rin.begin(), in[x] + 1));&#10;    }&#10;&#10;    vector&lt;pair&lt;int,int&gt;&gt; root_path_query(int x){&#10;        vector&lt;pair&lt;int,int&gt;&gt; ret;&#10;        ret.emplace_back(subsegment(x));&#10;        while(ret.back().first)&#10;            ret.emplace_back(subsegment(rev[rin[ret.back().first]]));&#10;&#10;        return ret;&#10;    }&#10;&#10;    int lca(int x, int y){&#10;&#10;        int sx = rin[subsegment(x).first];&#10;        int sy = rin[subsegment(y).first];&#10;        while(sx != sy){&#10;            if(depth[sx] &gt; depth[sy])&#10;                x = rev[sx];&#10;            else&#10;                y = rev[sy];&#10;            sx = rin[subsegment(x).first];&#10;            sy = rin[subsegment(y).first];&#10;        }&#10;&#10;        return depth[x] &lt; depth[y] ? x : y;&#10;    }&#10;&#10;    pair&lt;vector&lt;pair&lt;int,int&gt;&gt;,vector&lt;pair&lt;int,int&gt;&gt;&gt; two_point_path(i64 x, i64 y){&#10;        i64 z = lca(x, y);&#10;        pair&lt;int,int&gt; z_par = subsegment(z);&#10;&#10;        vector&lt;pair&lt;int,int&gt;&gt; ret_x;&#10;        ret_x.emplace_back(subsegment(x));&#10;&#10;        while(ret_x.back().first != z_par.first)&#10;            ret_x.emplace_back(subsegment(rev[rin[ret_x.back().first]]));&#10;&#10;        ret_x.back().first = in[z];&#10;&#10;        vector&lt;pair&lt;int,int&gt;&gt; ret_y;&#10;        ret_y.emplace_back(subsegment(y));&#10;&#10;        while(ret_y.back().first != z_par.first)&#10;            ret_y.emplace_back(subsegment(rev[rin[ret_y.back().first]]));&#10;&#10;        ret_y.back().first = in[z] + 1;&#10;&#10;        return make_pair(ret_x, ret_y);&#10;    }&#10;&#10;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lazysegtree" value="template&lt;typename T, typename U&gt;&#10;struct Segtree{&#10;    int n;&#10;    T op_t;&#10;    U op_u;&#10;    vector&lt;T&gt; elm;&#10;    vector&lt;U&gt; lazy;&#10;    vector&lt;int&gt; length;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;&#10;    Segtree(int n, T init, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t = T(), U op_u = U()) :&#10;        n(n),&#10;        op_t(op_t),&#10;        op_u(op_u),&#10;        elm(2 * n, init),&#10;        lazy(2 * n, op_u),&#10;        length(2 * n, 0),&#10;        f(f),&#10;        g(g),&#10;        h(h)&#10;    {&#10;        for(int i = n - 1; i &gt; 0; --i){&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;            length[i] = length[2 * i] + 1;&#10;        }&#10;    }&#10;&#10;    Segtree(int n, vector&lt;T&gt; init, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t = T(), U op_u = U()) :&#10;        n(n),&#10;        op_t(op_t),&#10;        op_u(op_u),&#10;        elm(2 * n),&#10;        lazy(2 * n, op_u),&#10;        length(2 * n, 0),&#10;        f(f),&#10;        g(g),&#10;        h(h)&#10;    {&#10;        for(int i = 0; i &lt; n; ++i)&#10;            elm[i + n] = init[i];&#10;&#10;        for(int i = n - 1; i &gt; 0; --i){&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;            length[i] = length[2 * i] + 1;&#10;        }&#10;    }&#10;&#10;    vector&lt;int&gt; get_list(int x, int y){&#10;&#10;        vector&lt;int&gt; ret_list;&#10;        for(x += n, y += n - 1; x; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            ret_list.emplace_back(x);&#10;            if(x != y)&#10;                ret_list.emplace_back(y);&#10;        }&#10;&#10;        return ret_list;&#10;    }&#10;&#10;    void eval(int x){&#10;&#10;        elm[x] = g(elm[x], lazy[x], 1 &lt;&lt; length[x]);&#10;        if(x &lt; n){&#10;            lazy[2 * x] = h(lazy[2 * x], lazy[x]);&#10;            lazy[2 * x + 1] = h(lazy[2 * x + 1], lazy[x]);&#10;        }&#10;        lazy[x] = op_u;&#10;    }&#10;&#10;    void update(int x, int y, U val){&#10;&#10;        if(x == y)&#10;            return;&#10;        vector&lt;int&gt; index_list = get_list(x, y);&#10;        for(int i = index_list.size() - 1; i &gt;= 0; --i)&#10;            eval(index_list[i]);&#10;&#10;        for(x += n, y += n - 1; x &lt;= y; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            if(x &amp; 1){&#10;                lazy[x] = h(lazy[x], val);&#10;                eval(x++);&#10;            }&#10;            if(!(y &amp; 1)){&#10;                lazy[y] = h(lazy[y], val);&#10;                eval(y--);&#10;            }&#10;        }&#10;&#10;        for(auto index : index_list){&#10;            if(index &lt; n){&#10;                eval(2 * index);&#10;                eval(2 * index + 1);&#10;                elm[index] = f(elm[2 * index], elm[2 * index + 1]);&#10;            }&#10;        }&#10;    }&#10;&#10;    T get(int x, int y){&#10;&#10;        vector&lt;int&gt; index_list = get_list(x, y);&#10;        for(int i = index_list.size() - 1; i &gt;= 0; --i)&#10;            eval(index_list[i]);&#10;&#10;        T l = op_t, r = op_t;&#10;        for(x += n, y += n - 1; x &lt;= y; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            if(x &amp; 1){&#10;                eval(x);&#10;                l = f(l, elm[x++]);&#10;            }&#10;            if(!(y &amp; 1)){&#10;                eval(y);&#10;                r = f(elm[y--], r);&#10;            }&#10;        }&#10;        return f(l, r);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lowlink" value="struct LowLink{&#10;    vector&lt;vector&lt;int&gt;&gt;&amp; edges;&#10;    // 関節点&#10;    vector&lt;int&gt; art;&#10;    vector&lt;pair&lt;int,int&gt;&gt; bridge;&#10;&#10;    vector&lt;int&gt; used, ord, low;&#10;    int k;&#10;&#10;    void dfs(int idx, int par){&#10;        ord[idx] = k++;&#10;        low[idx] = ord[idx];&#10;        bool is_art = false;&#10;        int cnt = 0;&#10;        for(auto&amp; to : edges[idx]){&#10;            if(ord[to] == -1){&#10;                ++cnt;&#10;                dfs(to, idx);&#10;                low[idx] = min(low[idx], low[to]);&#10;                is_art |= par != -1 &amp;&amp; low[to] &gt;= ord[idx];&#10;                if(ord[idx] &lt; low[to])&#10;                    bridge.emplace_back(idx, to);&#10;            }else if(to != par)&#10;                low[idx] = min(low[idx], ord[to]);&#10;        }&#10;        is_art |= (par == -1 &amp;&amp; cnt &gt; 1);&#10;        if(is_art)&#10;            art.emplace_back(idx);&#10;    }&#10;&#10;    LowLink(vector&lt;vector&lt;int&gt;&gt;&amp; edges) :&#10;        edges(edges),&#10;        ord(edges.size(), -1),&#10;        low(edges.size(), 0),&#10;        k(0)&#10;    {&#10;        for(int i = 0; i &lt; edges.size(); ++i)&#10;            if(ord[i] == -1)&#10;                dfs(i, -1);&#10;        for(auto&amp; b : bridge)&#10;            b = make_pair(min(b.first, b.second), max(b.first, b.second));&#10;        sort(art.begin(), art.end());&#10;        sort(bridge.begin(), bridge.end());&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="matrix" value="template &lt;typename T&gt;&#10;struct Matrix{&#10;    int h, w;&#10;    vector&lt;T&gt; v;&#10;&#10;    Matrix() : h(1), w(1), v(1, 1){}&#10;    Matrix(int n){*this = makeUnit(n);}&#10;    Matrix(int h, int w) : h(h), w(w), v(h * w, 0){}&#10;&#10;    Matrix(vector&lt;vector&lt;T&gt;&gt; v_) : h(v_.size()), w(v_[0].size()), v(h * w){&#10;        for(int i = 0; i &lt; h; ++i)&#10;            for(int j = 0; j &lt; w; ++j)&#10;                v[i * w + j] = v_[i][j];&#10;    }&#10;&#10;    static Matrix makeUnit(int n){&#10;        Matrix mat(n, n);&#10;        for(int i = 0; i &lt; n; ++i)&#10;            mat.at(i, i) = 1;&#10;        return mat;&#10;    }&#10;&#10;    T&amp; at(int i, int j){&#10;        assert(0 &lt;= i &amp;&amp; i &lt;= h &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; w);&#10;        return v[i * w + j];&#10;    };&#10;&#10;    Matrix pow(i64 x){&#10;        assert(h == w);&#10;        auto mat = x &amp; 1 ? *this : makeUnit(h);&#10;        auto u = *this;&#10;        while(u = u * u, x &gt;&gt;= 1)&#10;            if(x &amp; 1)&#10;                mat *= u;&#10;        return mat;&#10;    }&#10;&#10;    Matrix&amp; operator+=(const Matrix&amp; mat){&#10;        assert(h == mat.h &amp;&amp; w == mat.w);&#10;        for(int i = 0; i &lt; h * w; ++i)&#10;            v[i] += mat.v[i];&#10;        return *this;&#10;    }&#10;&#10;    Matrix&amp; operator-=(const Matrix&amp; mat){&#10;        assert(h == mat.h &amp;&amp; w == mat.w);&#10;        for(int i = 0; i &lt; h * w; ++i)&#10;            v[i] -= mat.v[i];&#10;        return *this;&#10;    }&#10;&#10;    Matrix&amp; operator%=(const T mod){&#10;        for(int i = 0; i &lt; h * w; ++i)&#10;            v[i] %= mod;&#10;        return *this;&#10;    }&#10;&#10;    Matrix operator*(const Matrix&amp; mat){&#10;        assert(w == mat.h);&#10;        Matrix ret(h, mat.w);&#10;        for(int i = 0; i &lt; h; ++i)&#10;            for(int k = 0; k &lt; w; ++k)&#10;                for(int j = 0; j &lt; mat.w; ++j)&#10;                    ret.v[i * mat.w + j] += v[i * w + k] * mat.v[k * mat.w + j];&#10;        return ret;&#10;    }&#10;&#10;    Matrix operator+(const Matrix&amp; mat){return Matrix(*this) += mat;}&#10;    Matrix operator-(const Matrix&amp; mat){return Matrix(*this) -= mat;}&#10;    Matrix operator%(const T mod){return Matrix(*this) %= mod;}&#10;    Matrix&amp; operator*=(const Matrix&amp; mat){return *this = *this * mat;}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="mo" value="struct Mo{&#10;    int l, r;&#10;    function&lt;void(int)&gt; left_add, left_erase, right_add, right_erase;&#10;    Mo(function&lt;void(int)&gt; left_add, function&lt;void(int)&gt; left_erase,&#10;       function&lt;void(int)&gt; right_add, function&lt;void(int)&gt; right_erase,&#10;       int sl = 0, int sr = 0) :&#10;       l(sl), r(sr), left_add(left_add), left_erase(left_erase), right_add(right_add), right_erase(right_erase){}&#10;    void move(int next_l, int next_r){&#10;        for(int i = l; i &lt; next_l; ++i)&#10;            left_erase(i);&#10;        for(int i = l - 1; i &gt;= next_l; --i)&#10;            left_add(i);&#10;        for(int i = r; i &lt; next_r; ++i)&#10;            right_add(i);&#10;        for(int i = r - 1; i &gt;= next_r; --i)&#10;            right_erase(i);&#10;        l = next_l, r = next_r;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="modint" value="template &lt;i64 mod = MOD&gt;&#10;struct ModInt{&#10;    i64 p;&#10;&#10;    ModInt() : p(0){}&#10;    ModInt(i64 x){p = x &gt;= 0 ? x % mod : x + (-x + mod - 1) / mod * mod;}&#10;&#10;    ModInt&amp; operator+=(const ModInt&amp; y){p = p + *y - ((p + *y) &gt;= mod ? mod : 0); return *this;}&#10;    ModInt&amp; operator-=(const ModInt&amp; y){p = p - *y + (p - *y &lt; 0 ? mod : 0); return *this;}&#10;    ModInt&amp; operator*=(const ModInt&amp; y){p = (p * *y) % mod; return *this;}&#10;    ModInt&amp; operator%=(const ModInt&amp; y){if(y)p %= *y; return *this;}&#10;&#10;    ModInt operator+(const ModInt&amp; y) const{ModInt x = *this; return x += y;}&#10;    ModInt operator-(const ModInt&amp; y) const{ModInt x = *this; return x -= y;}&#10;    ModInt operator*(const ModInt&amp; y) const{ModInt x = *this; return x *= y;}&#10;    ModInt operator%(const ModInt&amp; y) const{ModInt x = *this; return x %= y;}&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; stream, const ModInt&lt;mod&gt;&amp; x){&#10;        stream &lt;&lt; *x;&#10;        return stream;&#10;    }&#10;&#10;    friend ostream&amp; operator&gt;&gt;(ostream&amp; stream, const ModInt&lt;mod&gt;&amp; x){&#10;        stream &gt;&gt; *x;&#10;        return stream;&#10;    }&#10;&#10;    ModInt&amp; operator++(){p = (p + 1) % mod; return *this;}&#10;    ModInt&amp; operator--(){p = (p - 1 + mod) % mod; return *this;}&#10;&#10;    bool operator==(const ModInt&amp; y) const{return p == *y;}&#10;    bool operator!=(const ModInt&amp; y) const{return p != *y;}&#10;&#10;    const i64&amp; operator*() const{return p;}&#10;    i64&amp; operator*(){return p;}&#10;&#10;};&#10;&#10;using mint = ModInt&lt;&gt;;&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="persistentdynamiclazysegmenttree" value="template&lt;typename T, typename U&gt;&#10;struct Segtree{&#10;&#10;    struct SegNode{&#10;        T val;&#10;        U lazy;&#10;&#10;        shared_ptr&lt;SegNode&gt; l;&#10;        shared_ptr&lt;SegNode&gt; r;&#10;        SegNode(T val, U lazy) : val(val), lazy(lazy), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    i64 n;&#10;    shared_ptr&lt;SegNode&gt; nil;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;    T op_t;&#10;    U op_u;&#10;&#10;    shared_ptr&lt;SegNode&gt; root;&#10;&#10;    Segtree(int n_, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t, U op_u) : f(f), g(g), h(h), op_t(op_t), op_u(op_u){&#10;        for(n = 1; n &lt; n_; n &lt;&lt;= 1);&#10;        root = make_shared&lt;SegNode&gt;(op_t, op_u);&#10;    }&#10;&#10;    void eval(shared_ptr&lt;SegNode&gt; node, i64 len, bool make = true){&#10;        node-&gt;val = g(node-&gt;val, node-&gt;lazy, len);&#10;        if(make){&#10;            node-&gt;l = node-&gt;l ? make_shared&lt;SegNode&gt;(*node-&gt;l) : make_shared&lt;SegNode&gt;(op_t, op_u);&#10;            node-&gt;r = node-&gt;r ? make_shared&lt;SegNode&gt;(*node-&gt;r) : make_shared&lt;SegNode&gt;(op_t, op_u);&#10;        }&#10;        node-&gt;l-&gt;lazy = h(node-&gt;l-&gt;lazy, node-&gt;lazy);&#10;        node-&gt;r-&gt;lazy = h(node-&gt;r-&gt;lazy, node-&gt;lazy);&#10;        node-&gt;lazy = op_u;&#10;    }&#10;&#10;    // if root -&gt; make new node      -&gt; eval(make child)&#10;    void update(i64 x, i64 y, U val, shared_ptr&lt;SegNode&gt; node = nullptr, i64 l = -1, i64 r = -1){&#10;        bool root_flag = (node == nullptr);&#10;        if(root_flag){&#10;            root = make_shared&lt;SegNode&gt;(*root);&#10;            node = root;&#10;        }&#10;        if(l == -1){&#10;            l = 0;&#10;            r = n;&#10;        }&#10;        eval(node, r - l);&#10;        if(r &lt;= x || y &lt;= l)&#10;            return ;&#10;        if(x &lt;= l &amp;&amp; r &lt;= y){&#10;            node-&gt;lazy = h(node-&gt;lazy, val);&#10;            eval(node, r - l, false);&#10;        }else{&#10;            eval(node, r - l);&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;            update(x, y, val, node-&gt;l, l, mid);&#10;            update(x, y, val, node-&gt;r, mid, r);&#10;            node-&gt;val = f(node-&gt;l-&gt;val, node-&gt;r-&gt;val);&#10;        }&#10;        return ;&#10;    }&#10;&#10;    T get(i64 x, i64 y, shared_ptr&lt;SegNode&gt; node = nullptr, i64 l = -1, i64 r = -1){&#10;        bool root_flag = (node == nullptr);&#10;        if(root_flag){&#10;            root = make_shared&lt;SegNode&gt;(*root);&#10;            node = root;&#10;        }&#10;        if(l == -1){&#10;            l = 0;&#10;            r = n;&#10;        }&#10;&#10;        if(r &lt;= x || y &lt;= l)&#10;            return op_t;&#10;        eval(node, r - l);&#10;        if(x &lt;= l &amp;&amp; r &lt;= y)&#10;            return node-&gt;val;&#10;&#10;        i64 val_l = op_t, val_r = op_t;&#10;        i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;        if(node-&gt;l)&#10;            val_l = get(x, y, node-&gt;l, l, mid);&#10;        if(node-&gt;r)&#10;            val_r = get(x, y, node-&gt;r, mid, r);&#10;&#10;        return f(val_l, val_r);&#10;    }&#10;&#10;};&#10;&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="persistentunionfind" value="struct UnionFind{&#10;    vector&lt;int&gt; par, time;&#10;    int count;&#10;    UnionFind(int n) : par(n, -1), time(n, MOD), count(0){}&#10;    // [0, t]の間に併合されたかどうか&#10;    int Find(int x, int t){return par[x] &lt; 0 || time[x] &gt; t ? x : Find(par[x], t);}&#10;    int Size(int x){return par[x] &lt; 0 ? -par[x] : Size(par[x]);}&#10;    // 現在のcount+1のタイミングで併合された事にする&#10;    // Unite失敗時もcountが増えるので注意&#10;    int Unite(int x, int y){&#10;        x = Find(x, MOD + 1);&#10;        y = Find(y, MOD + 1);&#10;        ++count;&#10;        if(x == y)&#10;            return 0;&#10;        if(par[x] &gt; par[y])&#10;            swap(x, y);&#10;        par[x] += par[y];&#10;        par[y] = x;&#10;        time[y] = count;&#10;        return count;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="primaldual" value="template &lt;typename T, typename U&gt;&#10;struct PrimalDual{&#10;    struct Edge{&#10;        int to, rev;&#10;        U cap;&#10;        T cost;&#10;        Edge(int to, U cap, T cost, int rev) :&#10;            to(to), rev(rev), cap(cap), cost(cost){}&#10;    };&#10;    vector&lt;vector&lt;Edge&gt;&gt; edges;&#10;    T _inf;&#10;    vector&lt;T&gt; potential, min_cost;&#10;    vector&lt;int&gt; prev_v, prev_e;&#10;&#10;    PrimalDual(int n) : edges(n), _inf(numeric_limits&lt;T&gt;::max()){}&#10;&#10;    void add(int from, int to, U cap, T cost){&#10;        edges[from].emplace_back(to, cap, cost, static_cast&lt;int&gt;(edges[to].size()));&#10;        edges[to].emplace_back(from, 0, -cost, static_cast&lt;int&gt;(edges[from].size()) - 1);&#10;    }&#10;&#10;    T solve(int s, int t, U flow){&#10;        int n = edges.size();&#10;        T ret = 0;&#10;        priority_queue&lt;pair&lt;T,int&gt;, vector&lt;pair&lt;T,int&gt;&gt;, greater&lt;pair&lt;T,int&gt;&gt;&gt; que;&#10;        potential.assign(n, 0);&#10;        prev_v.assign(n, -1);&#10;        prev_e.assign(n, -1);&#10;        while(flow &gt; 0){&#10;            min_cost.assign(n, _inf);&#10;            que.emplace(0, s);&#10;            min_cost[s] = 0;&#10;            while(!que.empty()){&#10;                T fl;&#10;                int pos;&#10;                tie(fl, pos) = que.top();&#10;                que.pop();&#10;                if(min_cost[pos] != fl)&#10;                    continue;&#10;                for(int i = 0; i &lt; edges[pos].size(); ++i){&#10;                    auto&amp; ed = edges[pos][i];&#10;                    T nex = fl + ed.cost + potential[pos] - potential[ed.to];&#10;                    if(ed.cap &gt; 0 &amp;&amp; min_cost[ed.to] &gt; nex){&#10;                        min_cost[ed.to] = nex;&#10;                        prev_v[ed.to] = pos;&#10;                        prev_e[ed.to] = i;&#10;                        que.emplace(min_cost[ed.to], ed.to);&#10;                    }&#10;                }&#10;            }&#10;            if(min_cost[t] == _inf)&#10;                return -1;&#10;            for(int i = 0; i &lt; n; ++i)&#10;                potential[i] += min_cost[i];&#10;            T add_flow = flow;&#10;            for(int x = t; x != s; x = prev_v[x])&#10;                add_flow = min(add_flow, edges[prev_v[x]][prev_e[x]].cap);&#10;            flow -= add_flow;&#10;            ret += add_flow * potential[t];&#10;            for(int x = t; x != s; x = prev_v[x]){&#10;                auto&amp; ed = edges[prev_v[x]][prev_e[x]];&#10;                ed.cap -= add_flow;&#10;                edges[x][ed.rev].cap += add_flow;&#10;            }&#10;        }&#10;        return ret;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rectanglesum" value="struct RectangleSum{//O(HW)で初期化してO(1)で長方形の和を出す(半開区間)&#10;    vector&lt;vector&lt;i64&gt;&gt; sum;&#10;    int h, w;&#10;    RectangleSum(vector&lt;vector&lt;i64&gt;&gt;&amp; v) :&#10;        h(v.size()),&#10;        w(v[0].size()),&#10;        sum(v)&#10;    {}&#10;&#10;    // 半開区間で設定する事に注意する&#10;    void set(int sx, int sy, int ex, int ey, i64 val){&#10;        sum[sx][sy] += val;&#10;        sum[sx][ey] -= val;&#10;        sum[ex][sy] -= val;&#10;        sum[ex][ey] += val;&#10;    }&#10;&#10;    void run(){&#10;&#10;        for(int i = 0; i &lt; h; ++i)&#10;            for(int j = 0; j &lt; w + 1; ++j)&#10;                sum[i + 1][j] += sum[i][j];&#10;&#10;        for(int i = 0; i &lt; h + 1; ++i)&#10;            for(int j = 0; j &lt; w; ++j)&#10;                sum[i][j + 1] += sum[i][j];&#10;    }&#10;&#10;    i64 getSum(int sx, int sy, int ex, int ey){&#10;        return sum[ex][ey] + sum[sx][sy] - sum[sx][ey] - sum[ex][sy];&#10;    }&#10;};&#10;&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rollinghash" value="template &lt;i64 mod1 = MOD, i64 mod2 = MOD + 2, i64 base = 10007, typename T = string&gt;&#10;struct RollingHash{&#10;&#10;    using mint1 = ModInt&lt;mod1&gt;;&#10;    using mint2 = ModInt&lt;mod2&gt;;&#10;    using pair_type = pair&lt;mint1, mint2&gt;;&#10;    int len;&#10;    std::vector&lt;pair_type&gt; v;&#10;    static std::vector&lt;pair_type&gt; power, inv;&#10;&#10;    RollingHash(T s) :&#10;    len(s.size())&#10;    {&#10;        v.assign(1, make_pair(mint1(0), mint2(0)));&#10;        for(int i = 0; i &lt; len; ++i){&#10;            auto c = s[i];&#10;            v.emplace_back(v.back().first + power[i].first * c,&#10;                           v.back().second + power[i].second * c);&#10;            if(static_cast&lt;int&gt;(power.size()) == i + 1){&#10;                power.emplace_back(power.back().first * base,&#10;                                   power.back().second * base);&#10;                inv.emplace_back(mpow(power.back().first, mod1 - 2),&#10;                                 mpow(power.back().second, mod2 - 2));&#10;            }&#10;        }&#10;    };&#10;&#10;    pair_type get(int l = 0, int r = -1){&#10;        if(r == -1)&#10;            r = len;&#10;        assert(l &lt;= r);&#10;        assert(r &lt;= len);&#10;        auto l_cut = make_pair(v[r].first - v[l].first,&#10;                               v[r].second - v[l].second);&#10;        return make_pair(l_cut.first * inv[l].first,&#10;                         l_cut.second * inv[l].second);&#10;    }&#10;&#10;    pair_type connect(pair_type l, pair_type r, int l_len){&#10;        return make_pair(l.first + power[l_len].first * r.first,&#10;                         l.second + power[l_len].second * r.second);&#10;    }&#10;};&#10;&#10;using RH = RollingHash&lt;MOD, MOD + 2, 10007&gt;;&#10;template&lt;&gt; vector&lt;pair&lt;ModInt&lt;MOD&gt;, ModInt&lt;MOD + 2&gt;&gt;&gt; RH::power = {make_pair(ModInt&lt;MOD&gt;(1), ModInt&lt;MOD + 2&gt;(1))};&#10;template&lt;&gt; vector&lt;pair&lt;ModInt&lt;MOD&gt;, ModInt&lt;MOD + 2&gt;&gt;&gt; RH::inv = {make_pair(ModInt&lt;MOD&gt;(1), ModInt&lt;MOD + 2&gt;(1))};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="segtree" value="template&lt;typename T&gt;&#10;struct Segtree{&#10;    int n;&#10;    T op;&#10;    vector&lt;T&gt; elm;&#10;    function&lt;T(T, T)&gt; f;&#10;&#10;    Segtree(int n, T init, function&lt;T(T, T)&gt; f, T op = T()) :&#10;        n(n),&#10;        op(op),&#10;        elm(2 * n, init),&#10;        f(f)&#10;    {&#10;        for(int i = n - 1; i &gt;= 1; --i)&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;    }&#10;&#10;    Segtree(int n, vector&lt;T&gt; init, function&lt;T(T, T)&gt; f, T op = T()) :&#10;        n(n),&#10;        op(op),&#10;        elm(2 * n),&#10;        f(f)&#10;    {&#10;        for(int i = 0; i &lt; n; ++i)&#10;            elm[i + n] = init[i];&#10;        for(int i = n - 1; i &gt;= 1; --i)&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;    }&#10;&#10;    void set(int x, T val){&#10;        x += n;&#10;        elm[x] = val;&#10;        while(x &gt;&gt;= 1)&#10;            elm[x] = f(elm[2 * x], elm[2 * x + 1]);&#10;    }&#10;&#10;    void update(int x, T val){&#10;        x += n;&#10;        elm[x] = f(elm[x], val);&#10;        while(x &gt;&gt;= 1)&#10;            elm[x] = f(elm[2 * x], elm[2 * x + 1]);&#10;    }&#10;&#10;    T get(int x, int y) const{&#10;        T l = op, r = op;&#10;        for(x += n, y += n - 1; x &lt;= y; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            if(x &amp; 1)&#10;                l = f(l, elm[x++]);&#10;            if(!(y &amp; 1))&#10;                r = f(elm[y--], r);&#10;        }&#10;        return f(l, r);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="treap" value="template &lt;typename T, typename U = int&gt;&#10;struct Node{&#10;&#10;    using np = Node&lt;T, U&gt;*;&#10;&#10;    static np nil;&#10;&#10;    T val;&#10;    U lazy;&#10;    uint32_t pri;&#10;&#10;    int size;&#10;    T sum;&#10;&#10;    np l = nil;&#10;    np r = nil;&#10;&#10;    Node(T v, U OU = U()) : val(v), lazy(OU), pri(rndpri()), size(1), sum(v), l(nil), r(nil){}&#10;    Node(T v, U OU, uint32_t p) : val(v), lazy(OU), pri(p), size(1), sum(v), l(nil), r(nil){}&#10;&#10;    static uint32_t rndpri() {&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = time(0);&#10;        uint32_t t = x ^ (x &lt;&lt; 11);&#10;        x = y;&#10;        y = z;&#10;        z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return max&lt;uint32_t&gt;(1, w &amp; 0x3FFFFFFF);&#10;    }&#10;};&#10;&#10;&#10;template &lt;typename T, typename U = int&gt;&#10;class Treap{&#10;&#10;    using nt = Node&lt;T, U&gt;;&#10;    using np = nt*;&#10;    using F = function&lt;T(T, T)&gt;;&#10;    using G = function&lt;T(T, U, int)&gt;;&#10;    using H = function&lt;U(U, U)&gt;;&#10;&#10;public:&#10;&#10;    np root;&#10;    bool is_list;&#10;    F f;&#10;    G g;&#10;    H h;&#10;    T OT;&#10;    U OU;&#10;&#10;    Treap(bool is_list, F f, G g, H h, T OT, U OU) : root(nt::nil), is_list(is_list), f(f), g(g), h(h), OT(OT), OU(OU){}&#10;&#10;    Treap(T val, bool is_list, F f, G g, H h, T OT, U OU) : root(new nt(val)), is_list(is_list), f(f), g(g), h(h), OT(OT), OU(OU){}&#10;&#10;    // 配列で初期化する&#10;    Treap(vector&lt;T&gt; v, bool is_list, F f, G g, H h, T OT, U OU) : root(nt::nil), is_list(is_list), f(f), g(g), h(h), OT(OT), OU(OU){&#10;        for(auto&amp; xx : v)&#10;            root = _merge(root, new nt(xx, OU));&#10;    }&#10;&#10;    static Treap make(bool is_list, F f = [](T x, T){return x;}, T OT = T(), G g = [](auto x, auto, auto){return x;}, H h = [](auto x, auto){return x;}, U OU = U()){&#10;        assert(nt::nil != nullptr);&#10;        return Treap(is_list, f, g, h, OT, OU);&#10;    }&#10;&#10;    static Treap make(T val, bool is_list, F f = [](auto x, auto){return x;}, T OT = T(), G g = [](auto x, auto, auto){return x;}, H h = [](auto x, auto){return x;}, U OU = U()){&#10;        assert(nt::nil != nullptr);&#10;        return Treap(val, is_list, f, g, h, OT, OU);&#10;    }&#10;&#10;    static Treap make(vector&lt;T&gt; val, bool is_list, F f = [](auto x, auto){return x;}, T OT = T(), G g = [](auto x, auto, auto){return x;}, H h = [](auto x, auto){return x;}, U OU = U()){&#10;        assert(nt::nil != nullptr);&#10;        return Treap(val, is_list, f, g, h, OT, OU);&#10;    }&#10;&#10;    ~Treap(){&#10;        clear();&#10;        if(root != nt::nil)&#10;            delete root;&#10;    }&#10;&#10;    int _size(np x){return x == nt::nil ? 0 : x-&gt;size;}&#10;    T _sum(np x){return x == nt::nil ? OT : x-&gt;sum;}&#10;&#10;    np _update(np x){&#10;&#10;        if(x == nt::nil)&#10;            return x;&#10;&#10;        if(is_list){&#10;            _push(x);&#10;            _push(x-&gt;l);&#10;            _push(x-&gt;r);&#10;        }&#10;&#10;		x-&gt;sum = f(f(_sum(x-&gt;l), x-&gt;val), _sum(x-&gt;r));&#10;		x-&gt;size = _size(x-&gt;l) + _size(x-&gt;r) + 1;&#10;        return x;&#10;    }&#10;&#10;    void _push(np x){&#10;        if(x-&gt;lazy == OU)&#10;            return ;&#10;&#10;        x-&gt;sum = g(x-&gt;sum, x-&gt;lazy, x-&gt;size);&#10;        x-&gt;val = g(x-&gt;val, x-&gt;lazy, 1);&#10;&#10;        if(x-&gt;l != nt::nil)&#10;            x-&gt;l-&gt;lazy = h(x-&gt;l-&gt;lazy, x-&gt;lazy);&#10;        if(x-&gt;r != nt::nil)&#10;            x-&gt;r-&gt;lazy = h(x-&gt;r-&gt;lazy, x-&gt;lazy);&#10;&#10;        x-&gt;lazy = OU;&#10;&#10;    }&#10;&#10;    np _merge(np l, np r){&#10;        if(l == nt::nil || r ==nt::nil)&#10;            return l == nt::nil ? r : l;&#10;&#10;        if(l-&gt;pri &gt; r-&gt;pri){&#10;            l-&gt;r = _merge(l-&gt;r, r);&#10;            return _update(l);&#10;        }else{&#10;            r-&gt;l = _merge(l, r-&gt;l);&#10;            return _update(r);&#10;        }&#10;    }&#10;&#10;    pair&lt;np,np&gt; _split(np x, int k){&#10;        if(x == nt::nil)&#10;            return make_pair(nt::nil, nt::nil);&#10;&#10;        assert(0 &lt;= k &amp;&amp; k &lt;= _size(x));&#10;&#10;        if(k &lt;= _size(x-&gt;l)){&#10;            pair&lt;np, np&gt; s = _split(x-&gt;l, k);&#10;            x-&gt;l = s.second;&#10;            return make_pair(s.first, _update(x));&#10;&#10;        }else{&#10;            pair&lt;np, np&gt; s = _split(x-&gt;r, k - _size(x-&gt;l) - 1);&#10;            x-&gt;r = s.first;&#10;            return make_pair(_update(x), s.second);&#10;        }&#10;    }&#10;&#10;    np _insert(np x, int k, T val){&#10;        np l, r;&#10;        tie(l, r) = _split(x, k);&#10;        return _merge(_merge(l, new nt(val, OU)), r);&#10;    }&#10;&#10;    np _erase(np x, int k){&#10;        np l, r, m;&#10;        tie(l, r) = _split(x, k);&#10;        tie(m, r) = _split(r, 1);&#10;        if(m != nt::nil)&#10;            delete m;&#10;        return _merge(l, r);&#10;    }&#10;&#10;    void _set(np x, int k, T val){&#10;        _update(x);&#10;&#10;        if(k &lt; _size(x-&gt;l))&#10;            _set(x-&gt;l, k, val);&#10;        else if(_size(x-&gt;l) == k)&#10;            x-&gt;val = val;&#10;        else&#10;            _set(x-&gt;r, k - _size(x-&gt;l) - 1, val);&#10;&#10;        _update(x);&#10;    }&#10;&#10;    void _add(np x, int l, int r, U val){&#10;        assert(is_list);&#10;        _update(x);&#10;&#10;        if(x == nt::nil)&#10;            return ;&#10;        l = max(l, 0);&#10;        r = min(r, _size(x));&#10;&#10;        int sl = _size(x-&gt;l);&#10;&#10;        if(l &gt;= r)&#10;            return ;&#10;&#10;        if (l == 0 &amp;&amp; r == _size(x)){&#10;            x-&gt;lazy = h(x-&gt;lazy, val);&#10;        }&#10;        else{&#10;            if(l &lt;= sl &amp;&amp; sl &lt; r)&#10;                x-&gt;val = g(x-&gt;val, val, 1);&#10;&#10;            _add(x-&gt;l, l, r, val);&#10;            _add(x-&gt;r, l - sl - 1, r - sl - 1, val);&#10;        }&#10;&#10;        _update(x);&#10;    }&#10;&#10;    np _getnode(np x, int k){&#10;&#10;        _update(x);&#10;&#10;        assert(0 &lt;= k &amp;&amp; k &lt; _size(x));&#10;&#10;        if(k &lt; _size(x-&gt;l))&#10;            return _getnode(x-&gt;l, k);&#10;        else if(_size(x-&gt;l) == k)&#10;            return x;&#10;        else&#10;            return _getnode(x-&gt;r, k - _size(x-&gt;l) - 1);&#10;    }&#10;&#10;    T _get(np x, int k){&#10;        return _getnode(x, k)-&gt;val;&#10;    }&#10;&#10;    T _rangesum(np x, int l, int r){&#10;        _update(x);&#10;&#10;        l = max(l, 0);&#10;        r = min(r, _size(x));&#10;        if(l &gt;= r)&#10;            return OT;&#10;        if(l == 0 &amp;&amp; r == _size(x))&#10;            return _sum(x);&#10;&#10;        int sl = _size(x-&gt;l);&#10;        T ret = (l &lt;= sl &amp;&amp; sl &lt; r ? x-&gt;val : OT);&#10;        ret = f(_rangesum(x-&gt;l, l, r), ret);&#10;        ret = f(ret, _rangesum(x-&gt;r, l - sl - 1, r - sl - 1));&#10;        return ret;&#10;    }&#10;&#10;    int _lowerbound(np x, T val){&#10;        _update(x);&#10;&#10;        if(x == nt::nil)&#10;            return 0;&#10;        if(val &lt;= x-&gt;val)&#10;            return _lowerbound(x-&gt;l, val);&#10;        else&#10;            return _lowerbound(x-&gt;r,val) + _size(x-&gt;l) + 1;&#10;    }&#10;&#10;    int _upperbound(np x, T val){&#10;        _update(x);&#10;&#10;        if(x == nt::nil)&#10;            return 0;&#10;        if(val &lt; x-&gt;val)&#10;            return _upperbound(x-&gt;l, val);&#10;        else&#10;            return _upperbound(x-&gt;r,val) + _size(x-&gt;l) + 1;&#10;    }&#10;&#10;    np _insert(np x, T val){&#10;        return _insert(x, _lowerbound(x, val), val);&#10;    }&#10;&#10;    void _clear(np x){&#10;        if(x-&gt;l != nt::nil){&#10;            _clear(x-&gt;l);&#10;            delete(x-&gt;l);&#10;            x-&gt;l = nt::nil;&#10;        }&#10;        if(x-&gt;r != nt::nil){&#10;            _clear(x-&gt;r);&#10;            delete(x-&gt;r);&#10;            x-&gt;r = nt::nil;&#10;        }&#10;    }&#10;&#10;    void push_front(T val){&#10;        root = _merge(new nt(val, OU), root);&#10;    }&#10;&#10;    void push_back(T val){&#10;        root = _merge(root, new nt(val, OU));&#10;    }&#10;&#10;    void pop_front(){&#10;        root = _split(root, 1).second;&#10;    }&#10;&#10;    void pop_back(){&#10;        root = _split(root, _size(root) - 1).first;&#10;    }&#10;&#10;    // [0, k)と[k, size)に分割して, [k, size)側を返す&#10;    Treap split_left(int k){&#10;        np p;&#10;        tie(root, p) = _split(root, k);&#10;        return decltype(this)(f, g, h, p);&#10;    }&#10;&#10;    // [0, k)と[k, size)に分割して, [0, k)側を返す&#10;    Treap split_right(int k){&#10;        np p;&#10;        tie(p, root) = _split(root, k);&#10;        return decltype(this)(f, g, h, p);&#10;    }&#10;&#10;    // rootを含めたサイズの出力&#10;    int size(){&#10;        return (root == nt::nil ? 0 : root-&gt;size);&#10;    }&#10;&#10;    // k番目への代入&#10;    void set(int k, T val){&#10;        return _set(root, k, val);&#10;    }&#10;&#10;    // k番目への加算&#10;    void add(int k, U val){&#10;        assert(is_list);&#10;        return _add(root, k, k + 1, val);&#10;    }&#10;&#10;    // [l, r)への一様加算&#10;    void add(int l, int r, U val){&#10;        assert(is_list);&#10;        return _add(root, l, r, val);&#10;    }&#10;&#10;    // k番目の取得&#10;    T get(int k){&#10;        return _get(root, k);&#10;    }&#10;&#10;    // [l, r)の総和 (同様の実装でRMQ等も可能)&#10;    T get(int l, int r){&#10;        return _rangesum(root, l, r);&#10;    }&#10;&#10;    // k番目への挿入&#10;    void insert(int k, T val){&#10;        assert(is_list);&#10;        root = _insert(root, k, val);&#10;    }&#10;&#10;    // 適切な位置への挿入&#10;    void insert(T val){&#10;        root = _insert(root, val);&#10;    }&#10;&#10;    // val &lt;= get(k) となるような最小のk&#10;    int lowerbound(T val){&#10;        return _lowerbound(root, val);&#10;    }&#10;&#10;    // val &lt; get(k) となるような最小のk&#10;    int upperbound(T val){&#10;        return _upperbound(root, val);&#10;    }&#10;&#10;    // k番目の要素削除&#10;    void erase(int k){&#10;        root = _erase(root, k);&#10;    }&#10;&#10;    // 要素の全削除&#10;    void clear(){&#10;        if(root != nt::nil){&#10;            _clear(root);&#10;            delete(root);&#10;            root = nt::nil;&#10;        }&#10;    }&#10;};&#10;&#10;const i64 val = 0;&#10;const i64 op = -1e9;&#10;using node_type = Node&lt;i64, i64&gt;;&#10;template&lt;&gt; node_type* node_type::nil = new node_type(0, op, 0);&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="trie" value="template &lt;int size = 26, int start = 'a'&gt;&#10;struct Trie{&#10;    struct Node{&#10;        // 値, prefixに含む文字列の数, 文字列の数&#10;        int val, len, cnt, exist_cnt;&#10;        // 子のindex, 子の(indexの)一覧&#10;        vector&lt;int&gt; next, exist;&#10;        Node(int val = -1, int len = 0, bool back = false) : val(val), len(len), cnt(0), exist_cnt(back), next(size, -1){}&#10;    };&#10;&#10;    vector&lt;Node&gt; nodes;&#10;    Trie() : nodes(1){}&#10;&#10;    int insert(string&amp; s, int str_index = 0){&#10;        int pos = 0, idx = str_index;&#10;        while(idx != s.size()){&#10;            ++nodes[pos].cnt;&#10;            int c = s[idx] - start;&#10;            assert(c &lt; size);&#10;&#10;            if(nodes[pos].next[c] == -1){&#10;                nodes[pos].next[c] = nodes.size();&#10;                nodes[pos].exist.emplace_back(nodes.size());&#10;                nodes.emplace_back(c, nodes[pos].len + 1);&#10;            }&#10;            pos = nodes[pos].next[c];&#10;            ++idx;&#10;        }&#10;        ++nodes[pos].cnt;&#10;        ++nodes[pos].exist_cnt;&#10;        return pos;&#10;    }&#10;&#10;    // (sの部分文字列, s, sを部分文字列に含む文字列)に対して関数を実行する&#10;    // ラムダ内でtrie.nodes[idx].exist_cntを判定する事で, 挿入された文字列そのもの以外判定しなくなる&#10;    void query(string&amp; s, function&lt;void(int, string&amp;)&gt; f, bool from_prefix, bool correct, bool to_prefix, int str_index = 0){&#10;        int pos = 0, idx = str_index;&#10;        string str;&#10;        while(idx != s.size()){&#10;            if(from_prefix)&#10;                f(pos, str);&#10;            int c = s[idx] - start;&#10;            assert(c &lt; size);&#10;&#10;            if(nodes[pos].next[c] == -1)&#10;                return ;&#10;            pos = nodes[pos].next[c];&#10;            str += static_cast&lt;char&gt;(nodes[pos].val + start);&#10;            ++idx;&#10;        }&#10;        if(correct)&#10;            f(pos, str);&#10;        function&lt;void(int)&gt; dfs = [&amp;](int pos){&#10;            for(auto&amp; next : nodes[pos].exist){&#10;                char c = nodes[next].val + start;&#10;                if(to_prefix)&#10;                    f(pos, str);&#10;                str += c;&#10;                dfs(next);&#10;                str.pop_back();&#10;            }&#10;        };&#10;        dfs(pos);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="unionfind" value="struct UnionFind{&#10;    vector&lt;int&gt; par;&#10;    int count;&#10;    UnionFind(int n) : par(n, -1), count(0){}&#10;    int Find(int x){return par[x] &lt; 0 ? x : Find(par[x]);}&#10;    int Size(int x){return par[x] &lt; 0 ? -par[x] : Size(par[x]);}&#10;    bool Unite(int x, int y){&#10;        x = Find(x);&#10;        y = Find(y);&#10;        if(x == y)&#10;            return false;&#10;        if(par[x] &gt; par[y])&#10;            swap(x, y);&#10;        par[x] += par[y];&#10;        par[y] = x;&#10;        return ++count;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="waveletmatrix" value="&#10;struct BitVector{&#10;    int n, m;&#10;    vector&lt;int&gt; l;&#10;    vector&lt;uint64_t&gt; s;&#10;&#10;    BitVector(int n) : n(n){&#10;        m = (n + 63) &gt;&gt; 6;&#10;        l.assign(m, 0);&#10;        s.assign(m, 0);&#10;    }&#10;&#10;    void set(int i, bool flag = true){&#10;        if(flag)&#10;            s[i &gt;&gt; 6] |= (1uLL &lt;&lt; (i &amp; 63));&#10;        else&#10;            s[i &gt;&gt; 6] &amp;= ~(1uLL &lt;&lt; (i &amp; 63));&#10;    }&#10;&#10;    void build(){&#10;        l[0] = 0;&#10;        for(int i = 1; i &lt; m; ++i)&#10;            l[i] = l[i - 1] + __builtin_popcountll(s[i - 1]);&#10;    }&#10;&#10;    // [0, r) count flag&#10;    int rank(int r, bool flag = true){&#10;        if(flag)&#10;            return l[r &gt;&gt; 6] + __builtin_popcountll(s[r &gt;&gt; 6] &amp; ((1uLL &lt;&lt; (r &amp; 63)) - 1));&#10;        else&#10;            return r - (l[r &gt;&gt; 6] + __builtin_popcountll(s[r &gt;&gt; 6] &amp; ((1uLL &lt;&lt; (r &amp; 63)) - 1)));&#10;    }&#10;&#10;};&#10;&#10;template &lt;typename T&gt;&#10;struct WaveletMatrix{&#10;    int n, m;&#10;    vector&lt;BitVector&gt; b;&#10;    vector&lt;int&gt; border;&#10;    WaveletMatrix(vector&lt;T&gt; a) : n(a.size()){&#10;        T max_val = *max_element(a.begin(), a.end());&#10;        m = (max_val == 0) ? 1 : 64 - __builtin_clzll(max_val);&#10;        b.resize(m, BitVector(n));&#10;        border.resize(m);&#10;        vector&lt;vector&lt;T&gt;&gt; v(2, vector&lt;T&gt;(n));&#10;        for(int j = m - 1; j &gt;= 0; --j){&#10;            vector&lt;int&gt; cnt(2, 0);&#10;            for(int i = 0; i &lt; n; ++i){&#10;                bool fl = ((a[i] &gt;&gt; j) &amp; 1);&#10;                if(fl)&#10;                    b[j].set(i);&#10;                v[fl][cnt[fl]++] = a[i];&#10;            }&#10;            swap(a, v[0]);&#10;            for(int i = 0; i &lt; cnt[1]; ++i) {&#10;                a[i + cnt[0]] = v[1][i];&#10;            }&#10;            b[j].build();&#10;            border[j] = cnt[0];&#10;        }&#10;    }&#10;&#10;    // [l, r) count x&#10;    int count(int l, int r, T x){&#10;        for(int j = m - 1; j &gt;= 0; --j){&#10;            bool fl = (x &gt;&gt; j) &amp; 1;&#10;            r = b[j].rank(r, fl) + (fl ? border[j] : 0);&#10;            l = b[j].rank(l, fl) + (fl ? border[j] : 0);&#10;        }&#10;        return r - l;&#10;    }&#10;&#10;    // [l, r) count k (x &lt;= k)&#10;    int count_lower(int l, int r, T x){&#10;        int cnt = 0;&#10;        for(int j = m - 1; j &gt;= 0; --j){&#10;            bool fl = (x &gt;&gt; j) &amp; 1;&#10;            if(fl)&#10;                cnt += (l - r) - b[j].rank(l, 0);&#10;            r = b[j].rank(r, fl) + (fl ? border[j] : 0);&#10;            l = b[j].rank(l, fl) + (fl ? border[j] : 0);&#10;        }&#10;        return cnt + (r - l);&#10;    }&#10;&#10;    // [l, r) count k (x &lt;= k &lt; y)&#10;    int count_range(int l, int r, T x, T y){&#10;        return count_lower(l, r, y - 1) - count_lower(l, r, x - 1);&#10;    }&#10;&#10;    // [l, r) k-th min value (k: 0-indexed)&#10;    T kth_min(int l, int r, int k){&#10;        if(r - l &lt; k)&#10;            return -1;&#10;        T ret = 0;&#10;        for(int j = m - 1; j &gt;= 0; --j){&#10;            int x = b[j].rank(r, false) - b[j].rank(l, false);&#10;            bool fl = (k &gt;= x);&#10;            if(fl){&#10;                ret |= (1uLL &lt;&lt; j);&#10;                k -= x;&#10;            }&#10;            r = b[j].rank(r, fl) + (fl ? border[j] : 0);&#10;            l = b[j].rank(l, fl) + (fl ? border[j] : 0);&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    // [l, r) k-th min value (k: 0-indexed)&#10;    T kth_max(int l, int r, int k){&#10;        return kth_min(l, r, (r - l - 1) - k);&#10;    }&#10;&#10;    // [l, r) upper_bound(k) value&#10;    T next_value_T(int l, int r, T k){&#10;        return kth_min(count_lower(l, r, k) + 1);&#10;    }&#10;&#10;    // [l, r) prev(lower_bound(k)) value&#10;    T prev_value(int l, int r, T k){&#10;        return kth_min(count_lower(l, r, k - 1));&#10;    }&#10;&#10;};" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="geometry" value="namespace geometry{&#10;    using D = long double;&#10;    constexpr D eps =1e-9;&#10;&#10;    struct Point;&#10;    bool near_eq(Point, Point);&#10;    D norm(Point);&#10;&#10;    struct Point{&#10;        D x, y;&#10;        Point(D x = 0.0, D y = 0.0) : x(x), y(y){}&#10;        friend bool operator&lt;(const Point&amp; a, const Point&amp; b){&#10;            return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#10;        }&#10;        Point&amp; operator+=(Point a){x += a.x, y += a.y; return *this;}&#10;        Point&amp; operator-=(Point a){x -= a.x, y -= a.y; return *this;}&#10;        Point&amp; operator*=(D p){x *= p, y *= p; return *this;}&#10;        Point&amp; operator*=(Point b){return *this = *this * b;}&#10;        Point&amp; operator/=(D p){x /= p, y /= p; return *this;}&#10;        Point&amp; operator/=(Point b){return *this = *this / b;}&#10;        friend Point operator+(Point a, Point b){return Point(a) += b;}&#10;        friend Point operator-(Point a, Point b){return Point(a) -= b;}&#10;        friend Point operator*(Point a, D p){return Point(a) *= p;}&#10;        friend Point operator*(Point a, Point b){return Point(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);}&#10;        friend Point operator/(Point a, D b){return Point(a) /= b;}&#10;        friend Point operator/(Point a, Point b){return Point(a.x * b.x + a.y * b.y, b.x * a.y - a.x * b.y) / norm(b);}&#10;    };&#10;    using P = Point;&#10;&#10;    struct Circle : public Point{&#10;        D r;&#10;        Circle(Point p = Point(), D r = 1) : Point(p), r(r){}&#10;        Circle(D x = 0.0, D y = 0.0, D r = 1) : Point(x, y), r(r){}&#10;    };&#10;    using C = Circle;&#10;&#10;    bool near_eq(D a, D b = 0.0){return abs(a - b) &lt; eps;}&#10;    bool near_eq(P a, P b = Point()){return near_eq(a.x, b.x) &amp;&amp; near_eq(a.y, b.y);}&#10;    D diag(P a){&#10;        assert(!near_eq(a));&#10;        return atan2(a.y, a.x);&#10;    }&#10;    D norm(P a){return a.x * a.x + a.y * a.y;}&#10;    D abs(P a){return sqrt(norm(a));}&#10;    D dist(P a, P b){return abs(a - b);}&#10;    D dot(P a, P b){return a.x * b.x + a.y * b.y;}&#10;    D cross(P a, P b){return a.x * b.y - a.y * b.x;}&#10;    int ccw(P a, P b, P c){&#10;        b -= a;&#10;        c -= a;&#10;        if(cross(b, c) &gt; eps)return 1;&#10;        if(cross(b, c) &lt; -eps)return -1;&#10;        if(dot(b, c) &lt; -eps)return 2;&#10;        if(norm(b) &lt; norm(c))return -2;&#10;        return 0;&#10;    }&#10;    bool is_on_line(P a1, P a2, P b){return abs(ccw(a1, a2, b)) != -1;}&#10;    bool is_on_segment(P a1, P a2, P b){return !ccw(a1, a2, b);}&#10;    P proj(P a1, P a2, P b){return a1 + dot(a2 - a1, b - a1) / norm(a2 - a1) * (a2 - a1);} // 直線への射影点&#10;    D dist(P a1, P a2, P b){return dist(proj(a1, a2, b), b);}&#10;    bool intersect(P a1, P a2, P b1, P b2){&#10;        return ccw(a1, a2, b1) * ccw(a1, a2, b2) &lt;= 0 &amp;&amp;&#10;               ccw(b1, b2, a1) * ccw(b1, b2, a2) &lt;= 0;&#10;    }&#10;    P cross_point(P a1, P a2, P b1, P b2){&#10;        D d1 = cross(b2 - b1, b1 - a1);&#10;        D d2 = cross(b2 - b1, a2 - a1);&#10;        if(near_eq(d1) &amp;&amp; near_eq(d2))return a1;&#10;        assert(!near_eq(d2));&#10;        return a1 + d1 / d2 * (a2 - a1);&#10;    }&#10;    vector&lt;Point&gt; cross_point(C c1, C c2){&#10;        vector&lt;Point&gt; cross;&#10;        P diff = c2 - c1;&#10;        D d = abs(diff);&#10;        D crl = (norm(diff) + c1.r * c1.r - c2.r * c2.r) / (2 * d);&#10;        if(near_eq(d) || c1.r &lt; abs(crl))&#10;            return cross;&#10;        P abn = diff * P(0, sqrt(c1.r * c1.r - crl * crl) / d);&#10;        P cp = c1 + crl / d * diff;&#10;        cross.push_back(cp + abn);&#10;        if(!near_eq(abn))&#10;            cross.push_back(cp - abn);&#10;        return cross;&#10;    }&#10;    vector&lt;pair&lt;P, P&gt;&gt; tangent_lines(C c1, C c2){ // 共通接線、接線の両端は円との接点&#10;        vector&lt;pair&lt;P, P&gt;&gt; lines;&#10;        D d = dist(c1, c2);&#10;        for(int i = 0; i &lt; 2; ++i){&#10;            D sin =(c1.r - (1 - i * 2) * c2.r) / d;&#10;            if(!(sin * sin &lt; 1 + eps))&#10;                break;&#10;            D cos = sqrt(max(1 - sin * sin, D(0)));&#10;            for(int j = 0; j &lt; 2; ++j){&#10;                P n = (c2 - c1) * P(sin, (1 - j * 2) * cos) / d;&#10;                lines.emplace_back(c1 + c1.r * n, c2 + (1 - i * 2)  * c2.r * n);&#10;                if(cos &lt; eps)&#10;                    break;&#10;            }&#10;        }&#10;        return lines;&#10;    }&#10;}&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
</templateSet>