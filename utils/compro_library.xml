<templateSet group="compro_library">
  <template name="calc_fact" value="auto calc_fact = [mpow]{&#10;	constexpr int N = 2e6;&#10;	vector&lt;mint&gt; fact(N + 1, 1);&#10;	vector&lt;mint&gt; inv(N + 1, 1);&#10;	for(int i = 1; i &lt; N; ++i){&#10;		fact[i + 1] = fact[i] * (i + 1);&#10;		inv[i + 1] = mpow(fact[i + 1], MOD - 2);&#10;	}&#10;	return make_pair(fact, inv);&#10;};&#10;vector&lt;mint&gt; fact, inv;&#10;tie(fact, inv) = calc_fact();&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="divisor" value="auto divisor = [](i64 x){&#10;	int sq = sqrt(x) + 1;&#10;	vector&lt;int&gt; ret;&#10;	for(i64 i = 1; i &lt; sq; ++i)&#10;		if(!(x % i)){&#10;			ret.emplace_back(i);&#10;			if(i * i != x)&#10;				ret.emplace_back(x / i);&#10;		}&#10;	sort(ret.begin(), ret.end());&#10;	return ret;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="eratisthenes" value="auto eratosthenes = []{&#10;	constexpr int N = 2e6;&#10;	bitset&lt;N&gt; not_prime(3);&#10;	for(int i = 2; i &lt; N; ++i)&#10;		if(!not_prime[i])&#10;			for(int j = 2 * i; j &lt; N; j += i)&#10;				not_prime.set(j);&#10;	return not_prime;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="factoring" value="auto factoring = [](i64 x){&#10;	int sq = sqrt(x) + 1;&#10;	vector&lt;int&gt; ret;&#10;	if(x == 1){&#10;		ret.emplace_back(1);&#10;		return ret;&#10;	}&#10;	for(i64 i = 2; i &lt; sq; ++i)&#10;		while(x % i == 0){&#10;			ret.emplace_back(i);&#10;			x /= i;&#10;		}&#10;	if(x != 1)&#10;		ret.emplace_back(x);&#10;	return ret;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="gcd" value="auto gcd = [](i64 x, i64 y){&#10;	while(y){&#10;		i64 z = x % y;&#10;		x = y;&#10;		y = z;&#10;	}&#10;	return x;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lcm" value="auto lcm = [gcd](i64 x, i64 y){&#10;	return x * y / gcd(x, y);&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="mo_query" value="template &lt;typename ResultType&gt;&#10;vector&lt;ResultType&gt; mo_query(Mo&amp; mo, vector&lt;pair&lt;int,int&gt;&gt;&amp; queries, function&lt;ResultType(int)&gt; get_func, int packet=512){&#10;    int q = queries.size();&#10;    vector&lt;tuple&lt;int,int,int&gt;&gt; sort_queries;&#10;    for(int i = 0; i &lt; q; ++i)&#10;        sort_queries.emplace_back(queries[i].first / packet, queries[i].second, i);&#10;    sort(sort_queries.begin(), sort_queries.end());&#10;    vector&lt;ResultType&gt; ans(q);&#10;    for(auto&amp; query : sort_queries){&#10;        int idx = get&lt;2&gt;(query);&#10;        mo.move(queries[idx].first, queries[idx].second);&#10;        ans[idx] = get_func(idx);&#10;    }&#10;    return ans;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="modpow" value="auto mpow = [](auto x, i64 y){&#10;	auto z = x;&#10;	decltype(x) val = y &amp; 1 ? x : decltype(x)(1);&#10;	while(z *= z, y &gt;&gt;= 1)&#10;		if(y &amp; 1)&#10;			val *= z;&#10;	return val;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="ncr" value="auto ncr = [&amp;fact, &amp;inv](int n, int r){&#10;	if(n &lt; 0 || r &lt; 0 || n &lt; r)&#10;		return mint(0);&#10;	return fact[n] * inv[r] * inv[n - r];&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="nhr" value="auto nhr = [ncr](int n, int r){&#10;	return ncr(n + r - 1, r);&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rerooting" value="template &lt;typename T&gt;&#10;// T f(T, T): 子の累積に使うもの 直径ならf(x, y): max(x, y)&#10;// T g(T, int): 子の累積を元に適用する際に使うもの 直径ならg(x, idx): x + 1&#10;vector&lt;T&gt; rerooting(vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;T&gt; v, function&lt;T(T, T)&gt; f, function&lt;T(T, int)&gt; g, T op){&#10;    int n = edges.size();&#10;    vector&lt;int&gt; visit(n, 0);&#10;    vector&lt;T&gt; dp1(v), dp2(n);&#10;    vector&lt;vector&lt;int&gt;&gt; childs(n);&#10;    vector&lt;vector&lt;T&gt;&gt; child_val(n), child_l(n), child_r(n);&#10;    function&lt;void(int)&gt; f1 = [&amp;](int x){&#10;        visit[x] = true;&#10;        T res = op;&#10;        for(auto y : edges[x]){&#10;            if(visit[y])&#10;                continue;&#10;            f1(y);&#10;            childs[x].push_back(y);&#10;            child_val[x].push_back(dp1[y]);&#10;            res = f(res, dp1[y]);&#10;        }&#10;        dp1[x] = g(res, x);&#10;        child_l[x].push_back(op);&#10;        child_r[x].push_back(op);&#10;        for(int i = 0; i &lt; childs[x].size(); ++i){&#10;            child_l[x].push_back(f(child_l[x].back(), child_val[x][i]));&#10;            child_r[x].push_back(f(child_r[x].back(), child_val[x][childs[x].size() - i - 1]));&#10;        }&#10;    };&#10;    f1(0);&#10;    function&lt;void(int, T)&gt; f2 = [&amp;](int x, T par_val){&#10;        T res = par_val;&#10;        for(int i = 0; i &lt; childs[x].size(); ++i){&#10;            int y = childs[x][i];&#10;            auto p = f(par_val, f(child_l[x][i], child_r[x][childs[x].size() - i - 1]));&#10;            T val = g(f(par_val, f(child_l[x][i], child_r[x][childs[x].size() - i - 1])), y);&#10;            res = f(res, dp1[y]);&#10;            f2(y, val);&#10;        }&#10;        dp2[x] = g(res, x);&#10;    };&#10;    f2(0, op);&#10;    return dp2;&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="scc" value="vector&lt;int&gt; scc(vector&lt;vector&lt;int&gt;&gt;&amp; edges){&#10;    int n = edges.size();&#10;    vector&lt;vector&lt;int&gt;&gt; rev(n);&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        for(auto&amp; x : edges[i])&#10;            rev[x].emplace_back(i);&#10;&#10;    vector&lt;i64&gt; dfs_num(n, -1);&#10;    vector&lt;i64&gt; flag(n, 0);&#10;    int num = 0;&#10;    function&lt;void(int)&gt; dfs = [&amp;](int pos){&#10;        flag[pos] = 1;&#10;        for(auto&amp; xx : edges[pos])&#10;            if(!flag[xx]){&#10;                dfs(xx);&#10;        }&#10;        dfs_num[pos] = num++;&#10;    };&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        if(!flag[i])&#10;            dfs(i);&#10;&#10;    vector&lt;int&gt; dfs_inv(n);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        dfs_inv[n - 1 - dfs_num[i]] = i;&#10;&#10;    num = 0;&#10;&#10;    vector&lt;int&gt; scc_vec(n, -1);&#10;&#10;    function&lt;void(int)&gt; rdfs = [&amp;](int pos){&#10;        scc_vec[pos] = num;&#10;        for(auto t : rev[pos])&#10;            if(scc_vec[t] == -1)&#10;                rdfs(t);&#10;    };&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        if(scc_vec[dfs_inv[i]] == -1){&#10;            rdfs(dfs_inv[i]);&#10;            ++num;&#10;        }&#10;&#10;    return scc_vec;&#10;}&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="scc_dag" value="struct Result{&#10;    int dag_size;&#10;    vector&lt;vector&lt;int&gt;&gt; dag_graph;&#10;    // 元のグラフでi番目の頂点が何番目の強連結成分に含まれるか&#10;    vector&lt;int&gt; elements;&#10;    // i番目の強連結成分に含まれる頂点のリスト&#10;    vector&lt;vector&lt;int&gt;&gt; tps_list;&#10;    // トポソしてi番目にくる頂点のindex&#10;    vector&lt;int&gt; tps_order;&#10;    // DAGのi番目の頂点をトポソした時の番号&#10;    vector&lt;int&gt; tps_index;&#10;};&#10;&#10;Result scc_dag(vector&lt;vector&lt;int&gt;&gt;&amp; edges){&#10;    int n = edges.size();&#10;    vector&lt;int&gt; scc_vec = scc(edges);&#10;    int m = *max_element(scc_vec.begin(), scc_vec.end()) + 1;&#10;    vector&lt;vector&lt;int&gt;&gt; dag_graph(m);&#10;&#10;    queue&lt;int&gt; tps_que;&#10;    vector&lt;int&gt; in_count(m, 0);&#10;    vector&lt;int&gt; tps(m, -1);&#10;    vector&lt;int&gt; tps_idx(m);&#10;    for(int i = 0; i &lt; n; ++i){&#10;        for(auto j : edges[i]){&#10;            if(scc_vec[i] == scc_vec[j])&#10;                continue;&#10;            dag_graph[scc_vec[i]].push_back(scc_vec[j]);&#10;            ++in_count[scc_vec[j]];&#10;        }&#10;    }&#10;    for(int i = 0; i &lt; m; ++i)&#10;        if(in_count[i] == 0)&#10;            tps_que.push(i);&#10;    int cnt = 0;&#10;    while(!tps_que.empty()){&#10;        int x = tps_que.front();&#10;        tps_idx[x] = cnt;&#10;        tps[cnt++] = x;&#10;        tps_que.pop();&#10;        for(auto y : dag_graph[x])&#10;            if(--in_count[y] == 0)&#10;                tps_que.push(y);&#10;    }&#10;    assert(cnt == m);&#10;&#10;    vector&lt;vector&lt;int&gt;&gt; tps_list(m);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        tps_list[scc_vec[i]].push_back(i);&#10;&#10;    Result res;&#10;    res.dag_size = m;&#10;    res.elements = move(scc_vec);&#10;    res.tps_index = move(tps_idx);&#10;    res.tps_order = move(tps);&#10;    res.tps_list = move(tps_list);&#10;    res.dag_graph = move(dag_graph);&#10;    return res;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="simple_graph" value="template &lt;typename T = pair&lt;int,int&gt;&gt;&#10;vector&lt;vector&lt;int&gt;&gt; simple_graph(vector&lt;vector&lt;T&gt;&gt;&amp; edges, function&lt;int(T)&gt; f = [](auto x){return x.first;}){&#10;    vector&lt;vector&lt;int&gt;&gt; simple_edges(edges.size());&#10;    for(int i = 0; i &lt; edges.size(); ++i)&#10;        for(auto&amp; x : edges[i])&#10;            simple_edges[i].push_back(f(x));&#10;    return simple_edges;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="twoedgeconnectedcomponents_tree" value="struct Result{&#10;    int group_cnt;&#10;    vector&lt;int&gt; group;&#10;    vector&lt;vector&lt;int&gt;&gt; group_elm_list;&#10;    // 同じ二重辺連結成分の辺をグループごとに列挙する, 片方向のみ(辺数倍化しない)&#10;    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; same_group_edges;&#10;    // 橋, 片方向のみ&#10;    vector&lt;pair&lt;int,int&gt;&gt; bridges;&#10;    // 関節点&#10;    vector&lt;int&gt; arts;&#10;    vector&lt;vector&lt;int&gt;&gt; tree_graph;&#10;    vector&lt;int&gt; par;&#10;    vector&lt;vector&lt;int&gt;&gt; childs;&#10;};&#10;&#10;Result two_edge_connected_components_tree(vector&lt;vector&lt;int&gt;&gt;&amp; edges){&#10;    int n = edges.size();&#10;    LowLink ll(edges);&#10;    vector&lt;vector&lt;int&gt;&gt; not_bridge_graph(n);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        for(auto j : edges[i]){&#10;            pair&lt;int,int&gt; min_max = minmax(i, j);&#10;            auto iter = lower_bound(ll.bridge.begin(), ll.bridge.end(), min_max);&#10;            if(iter == ll.bridge.end() || *iter != min_max)&#10;                not_bridge_graph[i].push_back(j);&#10;        }&#10;&#10;    vector&lt;int&gt; group(n, -1);&#10;    function&lt;void(int)&gt; group_dfs = [&amp;](int x){&#10;        for(auto y : not_bridge_graph[x])&#10;            if(group[y] == -1){&#10;                group[y] = group[x];&#10;                group_dfs(y);&#10;            }&#10;    };&#10;    int group_cnt = 0;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        if(group[i] == -1){&#10;            group[i] = group_cnt++;&#10;            group_dfs(i);&#10;        }&#10;    vector&lt;vector&lt;int&gt;&gt; group_elm_list(group_cnt);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        group_elm_list[group[i]].push_back(i);&#10;&#10;    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; same_group_edges(group_cnt);&#10;    vector&lt;vector&lt;int&gt;&gt; tree_edges(group_cnt);&#10;    vector&lt;int&gt; par(group_cnt, -1);&#10;    vector&lt;vector&lt;int&gt;&gt; childs(group_cnt);&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        for(auto j : edges[i])&#10;            if(group[i] == group[j] &amp;&amp; i &lt; j)&#10;                same_group_edges[group[i]].emplace_back(i, j);&#10;&#10;    for(auto&amp; p : ll.bridge){&#10;        tree_edges[group[p.first]].push_back(group[p.second]);&#10;        tree_edges[group[p.second]].push_back(group[p.first]);&#10;    }&#10;    vector&lt;bool&gt; flag(n, false);&#10;    function&lt;void(int)&gt; tree_dfs = [&amp;](int x){&#10;        for(auto y : tree_edges[x])&#10;            if(!flag[y]){&#10;                flag[y] = true;&#10;                par[y] = x;&#10;                childs[x].push_back(y);&#10;                tree_dfs(y);&#10;            }&#10;    };&#10;    flag[0] = true;&#10;    tree_dfs(0);&#10;&#10;    Result res;&#10;    res.group_cnt = group_cnt;&#10;    res.group_elm_list = move(group_elm_list);&#10;    res.same_group_edges = move(same_group_edges);&#10;    res.bridges = move(ll.bridge);&#10;    res.arts = move(ll.art);&#10;    res.group = move(group);&#10;    res.tree_graph = move(tree_edges);&#10;    res.par = move(par);&#10;    res.childs = move(childs);&#10;    return res;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="avl" value="template &lt;typename T&gt;&#10;struct AVL{&#10;    template &lt;typename U&gt;&#10;    struct Node{&#10;        int size, height;&#10;        U val, sum;&#10;        Node(U val, Node&lt;U&gt;* nil) : val(val), sum(val), size(1), height(1){c[0] = nil; c[1] = nil;}&#10;        Node&lt;U&gt;* c[2];&#10;    };&#10;&#10;    using NodePtr = Node&lt;T&gt;*;&#10;    function&lt;T(T, T)&gt; f = [](auto x, auto y){return x + y;};&#10;    T op;&#10;    NodePtr nil;&#10;&#10;    AVL(function&lt;T(T, T)&gt; f, T op) : f(f), op(op){&#10;        nil = new Node&lt;T&gt;(op, nullptr);&#10;        nil-&gt;size = 0;&#10;        nil-&gt;height = 0;&#10;        nil-&gt;c[0] = nil;&#10;        nil-&gt;c[1] = nil;&#10;    }&#10;&#10;    template &lt;bool inv&gt;&#10;    int balance_factor(NodePtr x){return (x-&gt;c[0]-&gt;height - x-&gt;c[1]-&gt;height) * (inv ? -1 : 1);}&#10;    void _update(NodePtr x){&#10;        if(x == nil)&#10;            return;&#10;        x-&gt;size = x-&gt;c[0]-&gt;size + x-&gt;c[1]-&gt;size + 1;&#10;        x-&gt;height = max(x-&gt;c[0]-&gt;height, x-&gt;c[1]-&gt;height) + 1;&#10;        x-&gt;sum = f(f(x-&gt;c[0]-&gt;sum, x-&gt;val), x-&gt;c[1]-&gt;sum);&#10;    }&#10;    template &lt;bool is_right&gt;&#10;    NodePtr rotate(NodePtr x){&#10;        NodePtr new_root = x-&gt;c[1 ^ is_right];&#10;        x-&gt;c[1 ^ is_right] = new_root-&gt;c[0 ^ is_right];&#10;        new_root-&gt;c[0 ^ is_right] = x;&#10;        _update(x);&#10;        _update(new_root);&#10;        return new_root;&#10;    }&#10;    template &lt;bool inv&gt;&#10;    NodePtr _balance(NodePtr x){&#10;        if(balance_factor&lt;inv&gt;(x) == 2){&#10;            if(balance_factor&lt;inv&gt;(x-&gt;c[0 ^ inv]) &lt; 0)&#10;                x-&gt;c[0 ^ inv] = rotate&lt;inv&gt;(x-&gt;c[0 ^ inv]);&#10;            x = rotate&lt;1 ^ inv&gt;(x);&#10;        }&#10;        return x;&#10;    }&#10;    NodePtr balance(NodePtr x){&#10;        x = _balance&lt;false&gt;(x);&#10;        x = _balance&lt;true&gt;(x);&#10;        _update(x);&#10;        return x;&#10;    }&#10;    NodePtr insert(NodePtr x, int idx, T val){&#10;        if(x == nil)&#10;            return new Node&lt;T&gt;(val, nil);&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt;= left_size)&#10;            x-&gt;c[0] = insert(x-&gt;c[0], idx, val);&#10;        else&#10;            x-&gt;c[1] = insert(x-&gt;c[1], idx - left_size - 1, val);&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;&#10;    // 子が片方しかない時にノードを削除する&#10;    NodePtr _erase_top(NodePtr x, bool del){&#10;        for(int i = 0; i &lt; 2; ++i){&#10;            if(x-&gt;c[i] == nil){&#10;                NodePtr new_node = x-&gt;c[i ^ 1];&#10;                if(del)&#10;                    delete(x);&#10;                return new_node;&#10;            }&#10;        }&#10;    }&#10;    // 最小の要素をdstにコピーしてから削除する&#10;    NodePtr _copy_erase(NodePtr x, NodePtr dst, bool del){&#10;        if(x-&gt;c[0] == nil){&#10;            dst-&gt;val = x-&gt;val;&#10;            return _erase_top(x, del);&#10;        }&#10;        x-&gt;c[0] = _copy_erase(x-&gt;c[0], dst, del);&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;    NodePtr erase(NodePtr x, int idx, bool del = true){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            x-&gt;c[0] = erase(x-&gt;c[0], idx, del);&#10;        else if(left_size &lt; idx)&#10;            x-&gt;c[1] = erase(x-&gt;c[1], idx - left_size - 1, del);&#10;        else{&#10;            if(x-&gt;c[0] == nil || x-&gt;c[1] == nil)&#10;                return _erase_top(x, del);&#10;            x-&gt;c[1] = _copy_erase(x-&gt;c[1], x, del);&#10;        }&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;    NodePtr getNode(NodePtr x, int idx){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            return getNode(x-&gt;c[0], idx);&#10;        else if(left_size &lt; idx)&#10;            return getNode(x-&gt;c[1], idx - left_size - 1);&#10;        else&#10;            return x;&#10;    }&#10;    T get(NodePtr x, int l, int r){&#10;        if(l &lt;= 0 &amp;&amp; x-&gt;size &lt;= r)&#10;            return x-&gt;sum;&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        T res = op;&#10;        if(l &lt;= left_size &amp;&amp; left_size &lt; r)&#10;            res = x-&gt;val;&#10;        if(l &lt; left_size)&#10;            res = f(get(x-&gt;c[0], l, r), res);&#10;        if(left_size + 1 &lt; r)&#10;            res = f(res, get(x-&gt;c[1], l - left_size - 1, r - left_size - 1));&#10;        return res;&#10;    }&#10;    NodePtr update(NodePtr x, int idx, T val, function&lt;T(T, T)&gt; g = [](auto x, auto y){return x + y;}){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            x-&gt;c[0] = update(x-&gt;c[0], idx, val, g);&#10;        else if(left_size &lt; idx)&#10;            x-&gt;c[1] = update(x-&gt;c[1], idx - left_size - 1, val, g);&#10;        else&#10;            x-&gt;val = g(x-&gt;val, val);&#10;        _update(x);&#10;&#10;        return x;&#10;    }&#10;    NodePtr set(NodePtr x, int idx, T val){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            x-&gt;c[0] = set(x-&gt;c[0], idx, val);&#10;        else if(left_size &lt; idx)&#10;            x-&gt;c[1] = set(x-&gt;c[1], idx - left_size - 1, val);&#10;        else&#10;            x-&gt;val = val;&#10;        _update(x);&#10;        return x;&#10;    }&#10;&#10;    void print(NodePtr x, int p = 0){&#10;        if(x == nil)return;&#10;        if(p == 0)&#10;            cout &lt;&lt; &quot;----print----&quot; &lt;&lt; endl;&#10;        print(x-&gt;c[0], p + 12);&#10;        for(int i = 0; i &lt; p; ++i)&#10;            cout &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;val:&quot; &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;sum:&quot; &lt;&lt; x-&gt;sum &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;size:&quot; &lt;&lt; x-&gt;size &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;height:&quot; &lt;&lt; x-&gt;height &lt;&lt; endl;&#10;        print(x-&gt;c[1], p + 12);&#10;        if(p == 0)&#10;            cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="binaryindexedtree" value="template &lt;typename T&gt;&#10;struct BIT{&#10;    vector&lt;T&gt; elm;&#10;    BIT(int n, T init = T()) : elm(n + 1, init){&#10;    }&#10;&#10;    // [0, x)&#10;    T sum(int x){&#10;        T val = 0;&#10;        for(; x &gt; 0; x -= x &amp; -x)&#10;            val += elm[x];&#10;        return val;&#10;    }&#10;&#10;    // [l, r)&#10;    T sum(int l, int r){&#10;        return sum(r) - sum(l);&#10;    }&#10;&#10;    void add(int x, T val){&#10;        for(++x; x &lt; elm.size(); x += x &amp; -x)&#10;            elm[x] += val;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="binarylifting" value="struct BinaryLifting{&#10;    int n;&#10;    vector&lt;vector&lt;int&gt;&gt; next;&#10;    vector&lt;int&gt; par;&#10;    vector&lt;vector&lt;int&gt;&gt; childs;&#10;    vector&lt;int&gt; depth;&#10;&#10;    BinaryLifting(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int root = 0) : n(edges.size()), depth(n, -1), par(n, -1), childs(n){&#10;        function&lt;void(int)&gt; dfs = [&amp;](int x){&#10;            for(auto y : edges[x])&#10;                if(depth[y] == -1){&#10;                    depth[y] = depth[x] + 1;&#10;                    par[y] = x;&#10;                    childs[x].push_back(y);&#10;                    dfs(y);&#10;                }&#10;        };&#10;        depth[root] = 0;&#10;        dfs(root);&#10;&#10;        next.push_back(par);&#10;        for(int k = 0;; ++k){&#10;            bool fl = false;&#10;            next.emplace_back(n, -1);&#10;            for(int i = 0; i &lt; n; ++i){&#10;                next[k + 1][i] = (next[k][i] == -1 ? -1 : next[k][next[k][i]]);&#10;                if(next[k + 1][i] != -1)&#10;                    fl = true;&#10;            }&#10;            if(!fl)&#10;                break;&#10;        }&#10;    }&#10;    // kth_next(x, 0) =&gt; x&#10;    int kth_next(int x, int k){&#10;        for(int i = 0; i &lt; next.size() &amp;&amp; k; ++i){&#10;            if(k &amp; (1 &lt;&lt; i)){&#10;                x = next[i][x];&#10;                if(x == -1)&#10;                    break;&#10;            }&#10;        }&#10;        return x;&#10;    }&#10;&#10;    int lca(int x, int y){&#10;        int min_depth = min(depth[x], depth[y]);&#10;        x = kth_next(x, depth[x] - min_depth);&#10;        y = kth_next(y, depth[y] - min_depth);&#10;        if(x == y)&#10;            return x;&#10;        for(int i = next.size() - 1; i &gt;= 0; --i)&#10;            if(next[i][x] != next[i][y]){&#10;                x = next[i][x];&#10;                y = next[i][y];&#10;            }&#10;        return next[0][x];&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="compression" value="template&lt;typename T&gt;&#10;struct Compression{&#10;    vector&lt;T&gt; compvec;&#10;    Compression(vector&lt;T&gt;&amp; inp){//圧縮する&#10;        compvec = inp;&#10;        sort(compvec.begin(), compvec.end());&#10;        compvec.erase(unique(compvec.begin(), compvec.end()), compvec.end());&#10;    }&#10;    int Index(T val){//圧縮を元に対応するインデックスを返す&#10;        auto it = lower_bound(compvec.begin(), compvec.end(), val);&#10;        return distance(compvec.begin(), it);&#10;    }&#10;    vector&lt;T&gt;&amp; operator*(){&#10;        return compvec;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="convexhulltrick" value="template &lt;typename T, typename U&gt;&#10;struct ConvexHullTrick{&#10;    // 任意の2関数で共有点が高々1個ならElmの中身を適切に変えれば通る&#10;&#10;    struct Elm{&#10;        T a, b;&#10;        U operator()(T x){&#10;            return a * x + b;&#10;        }&#10;    };&#10;&#10;    struct Node{&#10;        Elm f;&#10;        Node* l;&#10;        Node* r;&#10;        Node(Elm elm) : f(elm), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    U _min, _max, _inf;&#10;    Node* root;&#10;&#10;    ConvexHullTrick(U _min, U _max, U _inf) :&#10;        _min(_min),&#10;        _max(_max),&#10;        _inf(_inf),&#10;        root(nullptr)&#10;    {&#10;    }&#10;&#10;    Node* _insert(Node* p, T st, T en, Elm f){&#10;        if(!p)&#10;            return new Node(f);&#10;        if(p-&gt;f(st) &lt;= f(st) &amp;&amp; p-&gt;f(en) &lt;= f(en))&#10;            return p;&#10;        if(p-&gt;f(st) &gt;= f(st) &amp;&amp; p-&gt;f(en) &gt;= f(en)){&#10;            p-&gt;f = f;&#10;            return p;&#10;        }&#10;        T mid = (st + en) / 2;&#10;        if(p-&gt;f(mid) &gt; f(mid))&#10;            swap(p-&gt;f, f);&#10;        if(p-&gt;f(st) &gt;= f(st))&#10;            p-&gt;l = _insert(p-&gt;l, st, mid, f);&#10;        else&#10;            p-&gt;r = _insert(p-&gt;r, mid, en, f);&#10;        return p;&#10;    }&#10;&#10;    U _query(Node* p, T st, T en, T x){&#10;        if(!p)&#10;            return _inf;&#10;        if(st == en)&#10;            return p-&gt;f(x);&#10;        T mid = (st + en) / 2;&#10;        if(x &lt;= mid)&#10;            return min(p-&gt;f(x), _query(p-&gt;l, st, mid, x));&#10;        else&#10;            return min(p-&gt;f(x), _query(p-&gt;r, mid, en, x));&#10;    }&#10;&#10;    void insert(Elm f){&#10;        root = _insert(root, _min, _max, f);&#10;    }&#10;&#10;    U query(T x){&#10;        return _query(root, _min, _max, x);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dinic" value="template &lt;typename T&gt;&#10;struct Dinic{&#10;    struct Edge{&#10;        int to, rev;&#10;        T cap;&#10;        Edge(int to, T cap, int rev) : to(to), rev(rev), cap(cap){}&#10;    };&#10;&#10;    vector&lt;vector&lt;Edge&gt;&gt; edges;&#10;    T _inf;&#10;    vector&lt;T&gt; min_cost;&#10;    vector&lt;int&gt; cnt;&#10;&#10;    Dinic(int n) : edges(n), _inf(numeric_limits&lt;T&gt;::max()){}&#10;&#10;    void add(int from, int to, T cap){&#10;        edges[from].emplace_back(to, cap, static_cast&lt;int&gt;(edges[to].size()));&#10;        edges[to].emplace_back(from, 0, static_cast&lt;int&gt;(edges[from].size()) - 1);&#10;    }&#10;&#10;    bool bfs(int s, int t){&#10;        min_cost.assign(edges.size(), -1);&#10;        queue&lt;int&gt; que;&#10;        min_cost[s] = 0;&#10;        que.emplace(s);&#10;        while(!que.empty() &amp;&amp; min_cost[t] == -1){&#10;            int x = que.front();&#10;            que.pop();&#10;            for(auto&amp; ed : edges[x])&#10;                if(ed.cap &gt; 0 &amp;&amp; min_cost[ed.to] == -1){&#10;                    min_cost[ed.to] = min_cost[x] + 1;&#10;                    que.emplace(ed.to);&#10;                }&#10;        }&#10;        return min_cost[t] != -1;&#10;    }&#10;&#10;    T dfs(int idx, int t, T flow){&#10;        if(idx == t)&#10;            return flow;&#10;        T ret = 0;&#10;        while(cnt[idx] &lt; edges[idx].size()){&#10;            auto&amp; ed = edges[idx][cnt[idx]];&#10;            if(ed.cap &gt; 0 &amp;&amp; min_cost[idx] &lt; min_cost[ed.to]){&#10;                T d = dfs(ed.to, t, min(flow, ed.cap));&#10;                ed.cap -= d;&#10;                edges[ed.to][ed.rev].cap += d;&#10;                ret += d;&#10;                flow -= d;&#10;                if(flow == 0)&#10;                    break;&#10;            }&#10;            ++cnt[idx];&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    T solve(int s, int t){&#10;        T flow = 0;&#10;        while(bfs(s, t)){&#10;            cnt.assign(edges.size(), 0);&#10;            T f = 0;&#10;            while((f = dfs(s, t, _inf)) &gt; 0)&#10;                flow += f;&#10;        }&#10;        return flow;&#10;    }&#10;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="disjointsparsetable" value="template &lt;typename T&gt;&#10;struct DisjointSparseTable{&#10;    function&lt;T(T, T)&gt; f;&#10;    vector&lt;vector&lt;T&gt;&gt; v;&#10;&#10;    DisjointSparseTable(vector&lt;T&gt;&amp; inp, function&lt;T(T, T)&gt; f) : f(f){&#10;        int n = inp.size();&#10;        int b;&#10;        for(b = 0; (1 &lt;&lt; b) &lt;= inp.size(); ++b);&#10;        v.assign(b, vector&lt;T&gt;(n));&#10;        for(int i = 0; i &lt; n; ++i)&#10;            v[0][i] = inp[i];&#10;        for(int i = 1; i &lt; b; ++i){&#10;            int siz = 1 &lt;&lt; i;&#10;            for(int j = 0; j &lt; n; j += siz &lt;&lt; 1){&#10;                int t = min(j + siz, n);&#10;                v[i][t - 1] = inp[t - 1];&#10;                for(int k = t - 2; k &gt;= j; --k)&#10;                    v[i][k] = f(inp[k], v[i][k + 1]);&#10;                if(t &gt;= n)&#10;                    break;&#10;                v[i][t] = inp[t];&#10;                int r = min(t + siz, n);&#10;                for(int k = t + 1; k &lt; r; ++k)&#10;                    v[i][k] = f(v[i][k - 1], inp[k]);&#10;            }&#10;        }&#10;    }&#10;&#10;    T get(int l, int r){&#10;        if(l &gt;= --r)&#10;            return v[0][l];&#10;        int p = 31 - __builtin_clz(l ^ r);&#10;        return f(v[p][l], v[p][r]);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dynamiclazysegmenttree" value="template&lt;typename T, typename U&gt;&#10;struct Segtree{&#10;&#10;    struct SegNode{&#10;        T val;&#10;        U lazy;&#10;&#10;        SegNode* l;&#10;        SegNode* r;&#10;        SegNode(T val, U lazy) : val(val), lazy(lazy), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    i64 n;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;    T op_t;&#10;    U op_u;&#10;&#10;    SegNode* root;&#10;&#10;    Segtree(int n_, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t, U op_u) : f(f), g(g), h(h), op_t(op_t), op_u(op_u){&#10;        for(n = 1; n &lt; n_; n &lt;&lt;= 1);&#10;        root = new SegNode(op_t, op_u);&#10;    }&#10;&#10;    SegNode* getl(SegNode* node){&#10;        return node-&gt;l ? node-&gt;l : node-&gt;l = new SegNode(op_t, op_u);&#10;    }&#10;&#10;    SegNode* getr(SegNode* node){&#10;        return node-&gt;r ? node-&gt;r : node-&gt;r = new SegNode(op_t, op_u);&#10;    }&#10;&#10;    void eval(SegNode* node, i64 len){&#10;        node-&gt;val = g(node-&gt;val, node-&gt;lazy, len);&#10;        getl(node);&#10;        node-&gt;l-&gt;lazy = h(node-&gt;l-&gt;lazy, node-&gt;lazy);&#10;        getr(node);&#10;        node-&gt;r-&gt;lazy = h(node-&gt;r-&gt;lazy, node-&gt;lazy);&#10;        node-&gt;lazy = op_u;&#10;    }&#10;&#10;    void update(i64 x, i64 y, U val, SegNode* node = nullptr, i64 l = 0, i64 r = 0){&#10;        if(node == nullptr){&#10;            node = root;&#10;            r = n;&#10;        }&#10;        eval(node, r - l);&#10;        if(r &lt;= x || y &lt;= l)&#10;            return ;&#10;        if(x &lt;= l &amp;&amp; r &lt;= y){&#10;            node-&gt;lazy = h(node-&gt;lazy, val);&#10;            eval(node, r - l);&#10;        }else{&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;            update(x, y, val, getl(node), l, mid);&#10;            update(x, y, val, getr(node), mid, r);&#10;            node-&gt;val = f(node-&gt;l-&gt;val, node-&gt;r-&gt;val);&#10;        }&#10;    }&#10;&#10;    T get(i64 x, i64 y, SegNode* node = nullptr, i64 l = 0, i64 r = 0){&#10;        if(node	== nullptr){&#10;            node = root;&#10;            r = n;&#10;        }&#10;&#10;        if(r &lt;= x || y &lt;= l)&#10;            return op_t;&#10;        eval(node, r - l);&#10;        if(x &lt;= l &amp;&amp; r &lt;= y)&#10;            return node-&gt;val;&#10;&#10;        i64 val_l = op_t, val_r = op_t;&#10;        i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;        if(node-&gt;l)&#10;            val_l = get(x, y, node-&gt;l, l, mid);&#10;        if(node-&gt;r)&#10;            val_r = get(x, y, node-&gt;r, mid, r);&#10;        return f(val_l, val_r);&#10;    }&#10;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dynamicsegmenttree" value="template &lt;typename T&gt;&#10;struct Segtree{&#10;&#10;    struct SegNode;&#10;&#10;    struct SegNode{&#10;        T val;&#10;        SegNode* l;&#10;        SegNode* r;&#10;&#10;        SegNode(T val) : val(val), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    i64 n;&#10;    function&lt;T(T, T)&gt; f;&#10;    T op;&#10;    SegNode* root;&#10;&#10;    Segtree(int n_, function&lt;T(T, T)&gt; f, T op) : f(f), op(op){&#10;        for(n = 1; n &lt; n_; n &lt;&lt;= 1);&#10;        root = new SegNode(op);&#10;    }&#10;&#10;    SegNode* getl(SegNode* node, T val){&#10;        return node-&gt;l == nullptr ? node-&gt;l = new SegNode(val) : node-&gt;l;&#10;    }&#10;&#10;    SegNode* getr(SegNode* node, T val){&#10;        return node-&gt;r == nullptr ? node-&gt;r = new SegNode(val) : node-&gt;r;&#10;    }&#10;&#10;    void eval(SegNode* node){&#10;        node-&gt;val = f(node-&gt;l == nullptr ? op : node-&gt;l-&gt;val, node-&gt;r == nullptr ? op : node-&gt;r-&gt;val);&#10;    }&#10;&#10;    void set(i64 x, T val){&#10;        assert(0 &lt;= x &amp;&amp; x &lt; n);&#10;&#10;        SegNode* node = root;&#10;        stack&lt;SegNode*&gt; nodes;&#10;        i64 l = 0, r = n;&#10;&#10;        while(r - l &gt; 1){&#10;            nodes.push(node);&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;            if(x &lt; mid){&#10;                node = getl(node, x);&#10;                r = mid;&#10;            }else{&#10;                node = getr(node, x);&#10;                l = mid;&#10;            }&#10;        }&#10;&#10;        node-&gt;val = val;&#10;        while(!nodes.empty()){&#10;            eval(nodes.top());&#10;            nodes.pop();&#10;        }&#10;    }&#10;&#10;    void update(i64 x, T val){&#10;        assert(0 &lt;= x &amp;&amp; x &lt; n);&#10;&#10;        SegNode* node = root;&#10;        stack&lt;SegNode*&gt; nodes;&#10;        i64 l = 0, r = n;&#10;&#10;        while(r - l &gt; 1){&#10;            nodes.push(node);&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;            if(x &lt; mid){&#10;                node = getl(node, x);&#10;                r = mid;&#10;            }else{&#10;                node = getr(node, x);&#10;                l = mid;&#10;            }&#10;        }&#10;&#10;        node-&gt;val = f(node-&gt;val, val);&#10;        while(!nodes.empty()){&#10;            eval(nodes.top());&#10;            nodes.pop();&#10;        }&#10;    }&#10;&#10;    T get(i64 x, i64 y, SegNode* node = nullptr, i64 l = 0,  i64 r = 0){&#10;&#10;        if(node == nullptr){&#10;            node = root;&#10;            r = n;&#10;        }&#10;&#10;        if(x &lt;= l &amp;&amp; r &lt;= y)&#10;            return node-&gt;val;&#10;&#10;        if(r &lt;= x || y &lt;= l)&#10;            return op;&#10;&#10;        T val_l = op, val_r = op;&#10;        i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;        if(node-&gt;l != nullptr)&#10;            val_l = f(val_l, get(x, y, node-&gt;l, l, mid));&#10;        if(node-&gt;r != nullptr)&#10;            val_r = f(get(x, y, node-&gt;r, mid, r), val_r);&#10;&#10;        return f(val_l, val_r);&#10;    }&#10;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="eulertour" value="struct EulerTour{&#10;    int n;&#10;    vector&lt;int&gt; in, out;&#10;    EulerTour(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int par = 0) : n(edges.size()), in(n, -1), out(n, -1){&#10;        int cnt = 0;&#10;        function&lt;void(int)&gt; f = [&amp;](int x){&#10;            in[x] = cnt++;&#10;            for(auto y : edges[x]){&#10;                if(in[y] == -1)&#10;                    f(y);&#10;            }&#10;            out[x] = cnt;&#10;        };&#10;        f(par);&#10;    }&#10;    int get_pos(int x){&#10;        return in[x];&#10;    }&#10;    // 自身を含みたくない場合は(in[x] + 1, out[x])&#10;    pair&lt;int,int&gt; get_subtree(int x){&#10;        return make_pair(in[x], out[x]);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="hashmap" value="template &lt;typename T, typename U, T del = numeric_limits&lt;T&gt;::max(), T null = numeric_limits&lt;T&gt;::max() - 1&gt;&#10;struct HashMap{&#10;    static constexpr __int128_t z = 0xf332ac987401cba5;&#10;    uint64_t n, q, d;&#10;&#10;    vector&lt;pair&lt;T, U&gt;&gt; v;&#10;&#10;    HashMap() : n(0), q(0), d(1),  v(2, make_pair(null, U())){&#10;    }&#10;&#10;    inline uint64_t hash(T key){return uint64_t((z * __int128_t(key)) &gt;&gt; (64 - d)) &amp; ((1LL &lt;&lt; d) - 1);}&#10;&#10;    pair&lt;U, bool&gt; find(T x){&#10;        for(uint64_t i = hash(x); v[i].first != null; i = (i + 1) &amp; ((1 &lt;&lt; d) - 1))&#10;            if(v[i].first == x)&#10;                return make_pair(v[i].second, true);&#10;        return make_pair(U(), false);&#10;    }&#10;&#10;    bool add(T x, U val){&#10;        if(find(x).second)&#10;            return false;&#10;        if(((q + 1) &lt;&lt; 1) &gt; (1 &lt;&lt; d) || (1 &lt;&lt; d) &lt; 3 * n)&#10;            resize();&#10;        uint64_t i = hash(x);&#10;        for(; v[i].first != null &amp;&amp; v[i].first != del; i = (i + 1) &amp; ((1 &lt;&lt; d) - 1));&#10;        q += (v[i].first == null);&#10;        ++n;&#10;        v[i] = make_pair(x, val);&#10;        return true;&#10;    }&#10;&#10;    bool erase(T x){&#10;        uint64_t i = hash(x);&#10;        for(; v[i].first != null &amp;&amp; v[i].first != x; i = (i + 1) &amp; ((1 &lt;&lt; d) - 1));&#10;        if(v[i].first == null)&#10;            return false;&#10;        --n;&#10;        v[i] = make_pair(del, U());&#10;        return true;&#10;    }&#10;&#10;    void resize(){&#10;        ++d;&#10;        vector&lt;pair&lt;T, U&gt;&gt; old_table;&#10;        q = n;&#10;        swap(old_table, v);&#10;        v.assign(1 &lt;&lt; d, make_pair(null, U()));&#10;        n = 0;&#10;        for(int i = 0; i &lt; old_table.size(); ++i)&#10;            if(old_table[i].first != null &amp;&amp; old_table[i].first != del)&#10;                add(old_table[i].first, old_table[i].second);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="heavylightdecomposition" value="struct HeavyLightDecomposition{&#10;    int n;&#10;    vector&lt;int&gt; size, par, in, in_rev, heavy_root, depth, heavy_depth, out;&#10;    vector&lt;vector&lt;int&gt;&gt; childs;&#10;    HeavyLightDecomposition(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int root = 0) : n(edges.size()), size(n, 1), par(n, -2), depth(n, 0), childs(n), in(n), in_rev(n), heavy_root(n), heavy_depth(n, 0), out(n){&#10;        function&lt;void(int)&gt; swap_dfs = [&amp;](int x){&#10;            int size_max = 0;&#10;            int max_idx = 0;&#10;            for(int i = 0; i &lt; edges[x].size(); ++i){&#10;                int y = edges[x][i];&#10;                if(par[y] == -2){&#10;                    par[y] = x;&#10;                    depth[y] = depth[x] + 1;&#10;                    childs[x].push_back(y);&#10;                    swap_dfs(y);&#10;                    size[x] += size[y];&#10;                    if(chmax(size_max, size[y])){&#10;                        max_idx = childs[x].size() - 1;&#10;                    }&#10;                }&#10;            }&#10;            if(max_idx){&#10;                swap(childs[x][0], childs[x][max_idx]);&#10;            }&#10;        };&#10;        par[root] = -1;&#10;        swap_dfs(root);&#10;&#10;        int cnt = 0;&#10;        function&lt;void(int,int)&gt; dfs = [&amp;](int x, int segment_root){&#10;            heavy_root[x] = segment_root;&#10;            in_rev[cnt] = x;&#10;            in[x] = cnt++;&#10;            for(int i = 0; i &lt; childs[x].size(); ++i){&#10;                int y = childs[x][i];&#10;                if(i == 0){&#10;                    dfs(y, segment_root);&#10;                }&#10;                else{&#10;                    heavy_depth[y] = heavy_depth[segment_root] + 1;&#10;                    dfs(y, y);&#10;                }&#10;            }&#10;            out[x] = cnt;&#10;        };&#10;        dfs(root, root);&#10;    }&#10;    int lca(int x, int y){&#10;        while(heavy_root[x] != heavy_root[y]){&#10;            if(heavy_depth[heavy_root[x]] &gt; heavy_depth[heavy_root[y]])&#10;                swap(x, y);&#10;            y = par[heavy_root[y]];&#10;        }&#10;        return depth[x] &lt; depth[y] ? x : y;&#10;    }&#10;    // x以下の部分木を返す&#10;    pair&lt;int,int&gt; subtree(int x){&#10;        return make_pair(in[x], out[x]);&#10;    }&#10;    // x-zのパスとy-zのパスを返す(両方とも根側に進むので注意)&#10;    // それぞれのHeavy-Pathは根側の方がindexが小さいので注意(可換クエリ処理で気をつける)&#10;    pair&lt;vector&lt;pair&lt;int,int&gt;&gt;, vector&lt;pair&lt;int,int&gt;&gt;&gt; two_point_path(int x, int y){&#10;        vector&lt;pair&lt;int,int&gt;&gt; xz, yz;&#10;        int z = lca(x, y);&#10;        while(heavy_root[x] != heavy_root[z]){&#10;            xz.emplace_back(in[heavy_root[x]], in[x] + 1);&#10;            x = par[heavy_root[x]];&#10;        }&#10;        while(heavy_root[y] != heavy_root[z]){&#10;            yz.emplace_back(in[heavy_root[y]], in[y] + 1);&#10;            y = par[heavy_root[y]];&#10;        }&#10;        // 辺属性にしたい場合はここをin[z] + 1, in[x] + 1にする&#10;        xz.emplace_back(in[z], in[x] + 1);&#10;        yz.emplace_back(in[z] + 1, in[y] + 1);&#10;        return make_pair(xz, yz);&#10;    }&#10;    // 頂点xがEuler-Tour上で何番目に位置するかを返す&#10;    // in[元の頂点index] = 内部でのindex&#10;    // in_rev[内部でのindex] = 元の頂点index&#10;    int get_idx(int x){&#10;        return in[x];&#10;    }&#10;    // xが属するHeavy-Pathの深さを返す&#10;    int get_heavy_depth(int x){&#10;        return heavy_depth[heavy_root[x]];&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lazysegtree" value="template&lt;typename T, typename U&gt;&#10;struct Segtree{&#10;    int n;&#10;    T op_t;&#10;    U op_u;&#10;    vector&lt;T&gt; elm;&#10;    vector&lt;U&gt; lazy;&#10;    vector&lt;int&gt; length;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;&#10;    Segtree(int n, T init, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t = T(), U op_u = U()) :&#10;        n(n),&#10;        op_t(op_t),&#10;        op_u(op_u),&#10;        elm(2 * n, init),&#10;        lazy(2 * n, op_u),&#10;        length(2 * n, 0),&#10;        f(f),&#10;        g(g),&#10;        h(h)&#10;    {&#10;        for(int i = n - 1; i &gt; 0; --i){&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;            length[i] = length[2 * i] + 1;&#10;        }&#10;    }&#10;&#10;    Segtree(int n, vector&lt;T&gt; init, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t = T(), U op_u = U()) :&#10;        n(n),&#10;        op_t(op_t),&#10;        op_u(op_u),&#10;        elm(2 * n),&#10;        lazy(2 * n, op_u),&#10;        length(2 * n, 0),&#10;        f(f),&#10;        g(g),&#10;        h(h)&#10;    {&#10;        for(int i = 0; i &lt; n; ++i)&#10;            elm[i + n] = init[i];&#10;&#10;        for(int i = n - 1; i &gt; 0; --i){&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;            length[i] = length[2 * i] + 1;&#10;        }&#10;    }&#10;&#10;    vector&lt;int&gt; get_list(int x, int y){&#10;&#10;        vector&lt;int&gt; ret_list;&#10;        for(x += n, y += n - 1; x; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            ret_list.emplace_back(x);&#10;            if(x != y)&#10;                ret_list.emplace_back(y);&#10;        }&#10;&#10;        return ret_list;&#10;    }&#10;&#10;    void eval(int x){&#10;&#10;        elm[x] = g(elm[x], lazy[x], 1 &lt;&lt; length[x]);&#10;        if(x &lt; n){&#10;            lazy[2 * x] = h(lazy[2 * x], lazy[x]);&#10;            lazy[2 * x + 1] = h(lazy[2 * x + 1], lazy[x]);&#10;        }&#10;        lazy[x] = op_u;&#10;    }&#10;&#10;    void update(int x, int y, U val){&#10;&#10;        if(x == y)&#10;            return;&#10;        vector&lt;int&gt; index_list = get_list(x, y);&#10;        for(int i = index_list.size() - 1; i &gt;= 0; --i)&#10;            eval(index_list[i]);&#10;&#10;        for(x += n, y += n - 1; x &lt;= y; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            if(x &amp; 1){&#10;                lazy[x] = h(lazy[x], val);&#10;                eval(x++);&#10;            }&#10;            if(!(y &amp; 1)){&#10;                lazy[y] = h(lazy[y], val);&#10;                eval(y--);&#10;            }&#10;        }&#10;&#10;        for(auto index : index_list){&#10;            if(index &lt; n){&#10;                eval(2 * index);&#10;                eval(2 * index + 1);&#10;                elm[index] = f(elm[2 * index], elm[2 * index + 1]);&#10;            }&#10;        }&#10;    }&#10;&#10;    T get(int x, int y){&#10;&#10;        vector&lt;int&gt; index_list = get_list(x, y);&#10;        for(int i = index_list.size() - 1; i &gt;= 0; --i)&#10;            eval(index_list[i]);&#10;&#10;        T l = op_t, r = op_t;&#10;        for(x += n, y += n - 1; x &lt;= y; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            if(x &amp; 1){&#10;                eval(x);&#10;                l = f(l, elm[x++]);&#10;            }&#10;            if(!(y &amp; 1)){&#10;                eval(y);&#10;                r = f(elm[y--], r);&#10;            }&#10;        }&#10;        return f(l, r);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lazyskiplist" value="template &lt;typename T, typename U&gt;&#10;struct SkipList{&#10;&#10;    static uint32_t rnd(){&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = 0; // time(0);&#10;        uint32_t t = x ^ (x &lt;&lt; 11);&#10;        x = y, y = z, z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return w;&#10;    }&#10;&#10;    struct Node{&#10;        int height;&#10;        vector&lt;Node*&gt; next, prev;&#10;        vector&lt;T&gt; sum;&#10;        vector&lt;U&gt; lazy;&#10;        vector&lt;int&gt; size;&#10;        Node(T val, int height, U op_u) : height(height), next(height, nullptr), prev(height, nullptr), sum(height, val), lazy(height, op_u), size(height, 1){}&#10;    };&#10;&#10;    using NodePtr = Node*;&#10;    int max_height;&#10;    NodePtr front, back;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;    T op_t;&#10;    U op_u;&#10;&#10;    SkipList(function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t, U op_u) : max_height(0), f(f), g(g), h(h), op_t(op_t), op_u(op_u){&#10;        front = new Node(op_t, 21, op_u);&#10;        back = new Node(op_t, 21, op_u);&#10;        front-&gt;next[0] = back;&#10;        back-&gt;prev[0] = front;&#10;    }&#10;&#10;    int size(){&#10;        return front-&gt;size[max_height] - 1;&#10;    }&#10;&#10;    T get_val(NodePtr ptr, int height){&#10;        return ptr-&gt;lazy[height] == op_u ? ptr-&gt;sum[height] : g(ptr-&gt;sum[height], ptr-&gt;lazy[height], ptr-&gt;size[height]);&#10;    }&#10;&#10;    NodePtr insert_next(NodePtr pre, T key){&#10;        uint32_t r = max(rnd(), uint32_t(1));&#10;        int height = min(__builtin_ffs(r), 20);&#10;        while(max_height &lt; height){&#10;            ++max_height;&#10;            front-&gt;size[max_height] = front-&gt;size[max_height - 1];&#10;            front-&gt;next[max_height] = back;&#10;            back-&gt;prev[max_height] = front;&#10;            front-&gt;sum[max_height] = front-&gt;sum[max_height - 1];&#10;            front-&gt;lazy[max_height] = front-&gt;lazy[max_height - 1];&#10;            front-&gt;lazy[max_height - 1] = op_u;&#10;        }&#10;        NodePtr node = new Node(key, height, op_u);&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; node_list = get_list(pre);&#10;        for(int i = node_list.size() - 1; i &gt;= 0; --i)&#10;            eval(node_list[i].first, node_list[i].second);&#10;        int pre_size = 1;&#10;        T pre_sum = pre-&gt;sum[0];&#10;        T nex_sum = key;&#10;        NodePtr nex = pre-&gt;next[0];&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            ++pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = node;&#10;                node-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = node;&#10;                node-&gt;prev[i] = pre;&#10;                int range_size = pre-&gt;size[i];&#10;                pre-&gt;size[i] = pre_size;&#10;                pre-&gt;sum[i] = pre_sum;&#10;                node-&gt;size[i] = range_size - pre_size;&#10;                node-&gt;sum[i] = nex_sum;&#10;            }&#10;            else{&#10;                pre-&gt;sum[i] = f(pre_sum, nex_sum);&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i]){&#10;                pre_sum = f(get_val(pre-&gt;prev[i], i), pre_sum);&#10;                pre_size += pre-&gt;prev[i]-&gt;size[i];&#10;            }&#10;            for(; nex-&gt;height == i + 1 &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i]){&#10;                nex_sum = f(nex_sum, get_val(nex, i));&#10;            }&#10;        }&#10;		return node;&#10;    }&#10;&#10;    // idx番目(idx=0なら先頭)に挿入する&#10;    NodePtr insert_index(int idx, T key){&#10;        NodePtr pre = access(idx - 1);&#10;        return insert_next(pre, key);&#10;    }&#10;&#10;    NodePtr insert_key(T key){&#10;        NodePtr pre = lower_bound(key)-&gt;prev[0];&#10;        return insert_next(pre, key);&#10;    }&#10;&#10;    NodePtr erase(NodePtr target){&#10;        // メモリ解放はしない(してもいいけど)&#10;        int height = target-&gt;height;&#10;        NodePtr pre = target-&gt;prev[0];&#10;        NodePtr nex = target-&gt;next[0];&#10;		NodePtr ret = nex;&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; node_list = get_list(pre, target);&#10;        for(int i = node_list.size() - 1; i &gt;= 0; --i)&#10;            eval(node_list[i].first, node_list[i].second);&#10;        T sum = pre-&gt;sum[0];&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            pre-&gt;sum[i] = sum;&#10;            --pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = pre;&#10;                pre-&gt;size[i] += target-&gt;size[i];&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i])&#10;                sum = f(get_val(pre-&gt;prev[i], i), sum);&#10;            for(; nex-&gt;height == i + 1 &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i])&#10;                sum = f(sum, get_val(nex, i));&#10;        }&#10;		return ret;&#10;    }&#10;&#10;    NodePtr erase_index(int idx){&#10;        NodePtr target = access(idx);&#10;        return erase(target);&#10;    }&#10;&#10;    NodePtr erase_key(T key){&#10;        NodePtr target = lower_bound(key);&#10;        if(target == back || target-&gt;sum[0] != key)&#10;            return target;&#10;        return erase(target);&#10;    }&#10;&#10;    NodePtr lower_bound(T key){&#10;        NodePtr pre = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; pre-&gt;next.size() &amp;&amp; pre-&gt;next[i] != back &amp;&amp; pre-&gt;next[i]-&gt;sum[0] &lt; key; pre = pre-&gt;next[i]);&#10;        return pre-&gt;next[0];&#10;    }&#10;&#10;    NodePtr upper_bound(T key){&#10;        NodePtr pre = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; pre-&gt;next.size() &amp;&amp; pre-&gt;next[i] != back &amp;&amp; pre-&gt;next[i]-&gt;sum[0] &lt;= key; pre = pre-&gt;next[i]);&#10;        return pre-&gt;next[0];&#10;    }&#10;&#10;    bool contains(T key){&#10;        NodePtr ptr = lower_bound(key);&#10;        return ptr != back &amp;&amp; ptr-&gt;key == key;&#10;    }&#10;&#10;    // (k個先のノード, [ptr, ptr + k)を覆う区間のリスト)を返す&#10;    pair&lt;NodePtr, vector&lt;pair&lt;NodePtr, int&gt;&gt;&gt; kth_next(NodePtr ptr, int k){&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; node_list;&#10;        for(; ptr-&gt;size[ptr-&gt;height - 1] &lt;= k; ptr = ptr-&gt;next[ptr-&gt;height - 1]){&#10;            k -= ptr-&gt;size[ptr-&gt;height - 1];&#10;            node_list.emplace_back(ptr, ptr-&gt;height - 1);&#10;        }&#10;        for(int i = ptr-&gt;height - 2; k; --i)&#10;            for(; ptr-&gt;size[i] &lt;= k; ptr = ptr-&gt;next[i]){&#10;                k -= ptr-&gt;size[i];&#10;                node_list.emplace_back(ptr, i);&#10;            }&#10;        return make_pair(ptr, node_list);&#10;    }&#10;&#10;    // 0-indexedでアクセスする&#10;    NodePtr access(int idx){&#10;        ++idx;&#10;        assert(0 &lt;= idx &amp;&amp; idx &lt;= size());&#10;        NodePtr ptr = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; ptr-&gt;next.size() &amp;&amp; ptr-&gt;next[i] != back &amp;&amp; ptr-&gt;size[i] &lt;= idx; idx -= ptr-&gt;size[i], ptr = ptr-&gt;next[i]);&#10;        return ptr;&#10;    }&#10;&#10;    vector&lt;pair&lt;NodePtr, int&gt;&gt; get_list(NodePtr ptr){&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; node_list;&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            node_list.emplace_back(ptr, i);&#10;            for(; ptr-&gt;height == i + 1 &amp;&amp; ptr-&gt;prev[i] != nullptr; ptr = ptr-&gt;prev[i]);&#10;        }&#10;        return node_list;&#10;    }&#10;&#10;    vector&lt;pair&lt;NodePtr, int&gt;&gt; get_list(NodePtr l_ptr, NodePtr r_ptr){&#10;        NodePtr ptr = l_ptr;&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; ptr_list;&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            ptr_list.emplace_back(l_ptr, i);&#10;            if(l_ptr != r_ptr)&#10;                ptr_list.emplace_back(r_ptr, i);&#10;            for(; l_ptr-&gt;height == i + 1 &amp;&amp; l_ptr-&gt;prev[i] != nullptr; l_ptr = l_ptr-&gt;prev[i]);&#10;            for(; r_ptr-&gt;height == i + 1 &amp;&amp; r_ptr-&gt;prev[i] != nullptr; r_ptr = r_ptr-&gt;prev[i]);&#10;        }&#10;        return ptr_list;&#10;    }&#10;&#10;    vector&lt;NodePtr&gt; get_child(NodePtr ptr, int height){&#10;        vector&lt;NodePtr&gt; node_vec;&#10;        if(height == 0)&#10;            return node_vec;&#10;        int diff = ptr-&gt;size[height];&#10;        for(; diff; ptr = ptr-&gt;next[height - 1]){&#10;            diff -= ptr-&gt;size[height - 1];&#10;            node_vec.emplace_back(ptr);&#10;        }&#10;        return node_vec;&#10;    }&#10;&#10;    void eval(NodePtr ptr, int height){&#10;        U lazy = ptr-&gt;lazy[height];&#10;        if(lazy == op_u)&#10;            return;&#10;        ptr-&gt;sum[height] = get_val(ptr, height);&#10;        vector&lt;NodePtr&gt; child_list = get_child(ptr, height);&#10;        for(auto child : child_list)&#10;            child-&gt;lazy[height - 1] = h(child-&gt;lazy[height - 1], lazy);&#10;        ptr-&gt;lazy[height] = op_u;&#10;    }&#10;&#10;    T get(int idx){&#10;        NodePtr ptr = access(idx);&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; node_list = get_list(ptr);&#10;        T sum = node_list[0].first-&gt;sum[0];&#10;        for(int i = node_list.size() - 1; i &gt;= 0; --i){&#10;            NodePtr node = node_list[i].first;&#10;            int height = node_list[i].second;&#10;            sum = g(sum, node-&gt;lazy[height], node-&gt;size[height]);&#10;        }&#10;        return sum;&#10;    }&#10;&#10;    T get(int l, int r){&#10;        NodePtr l_ptr = access(l);&#10;        NodePtr r_ptr;&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; segment_list;&#10;        tie(r_ptr, segment_list) = kth_next(l_ptr, r - l);&#10;        r_ptr = r_ptr-&gt;prev[0];&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; ptr_list = get_list(l_ptr, r_ptr);&#10;        for(int i = ptr_list.size() - 1; i &gt;= 0; --i)&#10;            eval(ptr_list[i].first, ptr_list[i].second);&#10;        T sum = op_t;&#10;        for(auto p : segment_list){&#10;            NodePtr ptr = p.first;&#10;            int height = p.second;&#10;            sum = f(sum, get_val(ptr, height));&#10;        }&#10;        return sum;&#10;    }&#10;&#10;    void update(int l, int r, U val){&#10;        NodePtr l_ptr = access(l);&#10;        NodePtr r_ptr;&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; segment_list;&#10;        tie(r_ptr, segment_list) = kth_next(l_ptr, r - l);&#10;        r_ptr = r_ptr-&gt;prev[0];&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; ptr_list = get_list(l_ptr, r_ptr);&#10;        for(int i = ptr_list.size() - 1; i &gt;= 0; --i)&#10;            eval(ptr_list[i].first, ptr_list[i].second);&#10;        for(auto p : segment_list){&#10;            int height = p.second;&#10;            NodePtr ptr = p.first;&#10;            ptr-&gt;lazy[height] = h(ptr-&gt;lazy[height], val);&#10;        }&#10;        for(auto p : ptr_list){&#10;            NodePtr node = p.first;&#10;            int height = p.second;&#10;            if(!height)&#10;                continue;&#10;            vector&lt;NodePtr&gt; child_list = get_child(node, height);&#10;            T sum = op_t;&#10;            for(auto child : child_list)&#10;                sum = f(sum, get_val(child, height - 1));&#10;            node-&gt;sum[height] = sum;&#10;        }&#10;    }&#10;&#10;    void print(bool eval_flag = false){&#10;        int idx = -1;&#10;        for(NodePtr node = front; node != nullptr; node = node-&gt;next[0], ++idx){&#10;            if(node == front || node == back)&#10;                printf(&quot;  null: &quot;);&#10;            else&#10;                printf(&quot;%6d: &quot;, eval_flag ? get(idx) : node-&gt;sum[0]);&#10;            for(int i = 0; i &lt; node-&gt;height; ++i)&#10;                printf(&quot;%2d: &quot;, eval_flag ? get_val(node, i) : node-&gt;sum[i]);&#10;                // cout &lt;&lt; node-&gt;size[i] &lt;&lt; &quot; &quot;;&#10;            cout &lt;&lt; endl;&#10;        }&#10;        cout &lt;&lt; endl;&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lowlink" value="struct LowLink{&#10;    vector&lt;vector&lt;int&gt;&gt;&amp; edges;&#10;    // 関節点&#10;    vector&lt;int&gt; art;&#10;    vector&lt;pair&lt;int,int&gt;&gt; bridge;&#10;&#10;    vector&lt;int&gt; used, ord, low;&#10;    int k;&#10;&#10;    void dfs(int idx, int par){&#10;        ord[idx] = k++;&#10;        low[idx] = ord[idx];&#10;        bool is_art = false;&#10;        int cnt = 0;&#10;        for(auto&amp; to : edges[idx]){&#10;            if(ord[to] == -1){&#10;                ++cnt;&#10;                dfs(to, idx);&#10;                low[idx] = min(low[idx], low[to]);&#10;                is_art |= par != -1 &amp;&amp; low[to] &gt;= ord[idx];&#10;                if(ord[idx] &lt; low[to])&#10;                    bridge.emplace_back(idx, to);&#10;            }else if(to != par)&#10;                low[idx] = min(low[idx], ord[to]);&#10;        }&#10;        is_art |= (par == -1 &amp;&amp; cnt &gt; 1);&#10;        if(is_art)&#10;            art.emplace_back(idx);&#10;    }&#10;&#10;    LowLink(vector&lt;vector&lt;int&gt;&gt;&amp; edges) :&#10;        edges(edges),&#10;        ord(edges.size(), -1),&#10;        low(edges.size(), 0),&#10;        k(0)&#10;    {&#10;        for(int i = 0; i &lt; edges.size(); ++i)&#10;            if(ord[i] == -1)&#10;                dfs(i, -1);&#10;        for(auto&amp; b : bridge)&#10;            b = make_pair(min(b.first, b.second), max(b.first, b.second));&#10;        sort(art.begin(), art.end());&#10;        sort(bridge.begin(), bridge.end());&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="matrix" value="template &lt;typename T&gt;&#10;struct Matrix{&#10;    int h, w;&#10;    vector&lt;T&gt; v;&#10;&#10;    Matrix() : h(1), w(1), v(1, 1){}&#10;    Matrix(int n){*this = makeUnit(n);}&#10;    Matrix(int h, int w) : h(h), w(w), v(h * w, 0){}&#10;&#10;    Matrix(vector&lt;vector&lt;T&gt;&gt; v_) : h(v_.size()), w(v_[0].size()), v(h * w){&#10;        for(int i = 0; i &lt; h; ++i)&#10;            for(int j = 0; j &lt; w; ++j)&#10;                v[i * w + j] = v_[i][j];&#10;    }&#10;&#10;    static Matrix makeUnit(int n){&#10;        Matrix mat(n, n);&#10;        for(int i = 0; i &lt; n; ++i)&#10;            mat.at(i, i) = 1;&#10;        return mat;&#10;    }&#10;&#10;    T&amp; at(int i, int j){&#10;        assert(0 &lt;= i &amp;&amp; i &lt;= h &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; w);&#10;        return v[i * w + j];&#10;    };&#10;&#10;    Matrix pow(i64 x){&#10;        assert(h == w);&#10;        auto mat = x &amp; 1 ? *this : makeUnit(h);&#10;        auto u = *this;&#10;        while(u = u * u, x &gt;&gt;= 1)&#10;            if(x &amp; 1)&#10;                mat *= u;&#10;        return mat;&#10;    }&#10;&#10;    Matrix&amp; operator+=(const Matrix&amp; mat){&#10;        assert(h == mat.h &amp;&amp; w == mat.w);&#10;        for(int i = 0; i &lt; h * w; ++i)&#10;            v[i] += mat.v[i];&#10;        return *this;&#10;    }&#10;&#10;    Matrix&amp; operator-=(const Matrix&amp; mat){&#10;        assert(h == mat.h &amp;&amp; w == mat.w);&#10;        for(int i = 0; i &lt; h * w; ++i)&#10;            v[i] -= mat.v[i];&#10;        return *this;&#10;    }&#10;&#10;    Matrix&amp; operator%=(const T mod){&#10;        for(int i = 0; i &lt; h * w; ++i)&#10;            v[i] %= mod;&#10;        return *this;&#10;    }&#10;&#10;    Matrix operator*(const Matrix&amp; mat){&#10;        assert(w == mat.h);&#10;        Matrix ret(h, mat.w);&#10;        for(int i = 0; i &lt; h; ++i)&#10;            for(int k = 0; k &lt; w; ++k)&#10;                for(int j = 0; j &lt; mat.w; ++j)&#10;                    ret.v[i * mat.w + j] += v[i * w + k] * mat.v[k * mat.w + j];&#10;        return ret;&#10;    }&#10;&#10;    Matrix operator+(const Matrix&amp; mat){return Matrix(*this) += mat;}&#10;    Matrix operator-(const Matrix&amp; mat){return Matrix(*this) -= mat;}&#10;    Matrix operator%(const T mod){return Matrix(*this) %= mod;}&#10;    Matrix&amp; operator*=(const Matrix&amp; mat){return *this = *this * mat;}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="mo" value="struct Mo{&#10;    int l, r;&#10;    function&lt;void(int)&gt; left_add, left_erase, right_add, right_erase;&#10;    Mo(function&lt;void(int)&gt; left_add, function&lt;void(int)&gt; left_erase,&#10;       function&lt;void(int)&gt; right_add, function&lt;void(int)&gt; right_erase,&#10;       int sl = 0, int sr = 0) :&#10;       l(sl), r(sr), left_add(left_add), left_erase(left_erase), right_add(right_add), right_erase(right_erase){}&#10;    void move(int next_l, int next_r){&#10;        for(int i = l; i &lt; next_l; ++i)&#10;            left_erase(i);&#10;        for(int i = l - 1; i &gt;= next_l; --i)&#10;            left_add(i);&#10;        for(int i = r; i &lt; next_r; ++i)&#10;            right_add(i);&#10;        for(int i = r - 1; i &gt;= next_r; --i)&#10;            right_erase(i);&#10;        l = next_l, r = next_r;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="modint" value="template &lt;i64 mod = MOD&gt;&#10;struct ModInt{&#10;    i64 p;&#10;&#10;    ModInt() : p(0){}&#10;    ModInt(i64 x){p = x &gt;= 0 ? x % mod : x + (-x + mod - 1) / mod * mod;}&#10;&#10;    ModInt&amp; operator+=(const ModInt&amp; y){p = p + *y - ((p + *y) &gt;= mod ? mod : 0); return *this;}&#10;    ModInt&amp; operator-=(const ModInt&amp; y){p = p - *y + (p - *y &lt; 0 ? mod : 0); return *this;}&#10;    ModInt&amp; operator*=(const ModInt&amp; y){p = (p * *y) % mod; return *this;}&#10;    ModInt&amp; operator%=(const ModInt&amp; y){if(y)p %= *y; return *this;}&#10;&#10;    ModInt operator+(const ModInt&amp; y) const{ModInt x = *this; return x += y;}&#10;    ModInt operator-(const ModInt&amp; y) const{ModInt x = *this; return x -= y;}&#10;    ModInt operator*(const ModInt&amp; y) const{ModInt x = *this; return x *= y;}&#10;    ModInt operator%(const ModInt&amp; y) const{ModInt x = *this; return x %= y;}&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; stream, const ModInt&lt;mod&gt;&amp; x){&#10;        stream &lt;&lt; *x;&#10;        return stream;&#10;    }&#10;&#10;    friend ostream&amp; operator&gt;&gt;(ostream&amp; stream, const ModInt&lt;mod&gt;&amp; x){&#10;        stream &gt;&gt; *x;&#10;        return stream;&#10;    }&#10;&#10;    ModInt&amp; operator++(){p = (p + 1) % mod; return *this;}&#10;    ModInt&amp; operator--(){p = (p - 1 + mod) % mod; return *this;}&#10;&#10;    bool operator==(const ModInt&amp; y) const{return p == *y;}&#10;    bool operator!=(const ModInt&amp; y) const{return p != *y;}&#10;&#10;    const i64&amp; operator*() const{return p;}&#10;    i64&amp; operator*(){return p;}&#10;&#10;};&#10;&#10;using mint = ModInt&lt;&gt;;&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="persistentdynamiclazysegmenttree" value="template&lt;typename T, typename U&gt;&#10;struct Segtree{&#10;&#10;    struct SegNode{&#10;        T val;&#10;        U lazy;&#10;&#10;        shared_ptr&lt;SegNode&gt; l;&#10;        shared_ptr&lt;SegNode&gt; r;&#10;        SegNode(T val, U lazy) : val(val), lazy(lazy), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    i64 n;&#10;    shared_ptr&lt;SegNode&gt; nil;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;    T op_t;&#10;    U op_u;&#10;&#10;    shared_ptr&lt;SegNode&gt; root;&#10;&#10;    Segtree(int n_, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t, U op_u) : f(f), g(g), h(h), op_t(op_t), op_u(op_u){&#10;        for(n = 1; n &lt; n_; n &lt;&lt;= 1);&#10;        root = make_shared&lt;SegNode&gt;(op_t, op_u);&#10;    }&#10;&#10;    void eval(shared_ptr&lt;SegNode&gt; node, i64 len, bool make = true){&#10;        node-&gt;val = g(node-&gt;val, node-&gt;lazy, len);&#10;        if(make){&#10;            node-&gt;l = node-&gt;l ? make_shared&lt;SegNode&gt;(*node-&gt;l) : make_shared&lt;SegNode&gt;(op_t, op_u);&#10;            node-&gt;r = node-&gt;r ? make_shared&lt;SegNode&gt;(*node-&gt;r) : make_shared&lt;SegNode&gt;(op_t, op_u);&#10;        }&#10;        node-&gt;l-&gt;lazy = h(node-&gt;l-&gt;lazy, node-&gt;lazy);&#10;        node-&gt;r-&gt;lazy = h(node-&gt;r-&gt;lazy, node-&gt;lazy);&#10;        node-&gt;lazy = op_u;&#10;    }&#10;&#10;    // if root -&gt; make new node      -&gt; eval(make child)&#10;    void update(i64 x, i64 y, U val, shared_ptr&lt;SegNode&gt; node = nullptr, i64 l = -1, i64 r = -1){&#10;        bool root_flag = (node == nullptr);&#10;        if(root_flag){&#10;            root = make_shared&lt;SegNode&gt;(*root);&#10;            node = root;&#10;        }&#10;        if(l == -1){&#10;            l = 0;&#10;            r = n;&#10;        }&#10;        eval(node, r - l);&#10;        if(r &lt;= x || y &lt;= l)&#10;            return ;&#10;        if(x &lt;= l &amp;&amp; r &lt;= y){&#10;            node-&gt;lazy = h(node-&gt;lazy, val);&#10;            eval(node, r - l, false);&#10;        }else{&#10;            eval(node, r - l);&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;            update(x, y, val, node-&gt;l, l, mid);&#10;            update(x, y, val, node-&gt;r, mid, r);&#10;            node-&gt;val = f(node-&gt;l-&gt;val, node-&gt;r-&gt;val);&#10;        }&#10;        return ;&#10;    }&#10;&#10;    T get(i64 x, i64 y, shared_ptr&lt;SegNode&gt; node = nullptr, i64 l = -1, i64 r = -1){&#10;        bool root_flag = (node == nullptr);&#10;        if(root_flag){&#10;            root = make_shared&lt;SegNode&gt;(*root);&#10;            node = root;&#10;        }&#10;        if(l == -1){&#10;            l = 0;&#10;            r = n;&#10;        }&#10;&#10;        if(r &lt;= x || y &lt;= l)&#10;            return op_t;&#10;        eval(node, r - l);&#10;        if(x &lt;= l &amp;&amp; r &lt;= y)&#10;            return node-&gt;val;&#10;&#10;        i64 val_l = op_t, val_r = op_t;&#10;        i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;        if(node-&gt;l)&#10;            val_l = get(x, y, node-&gt;l, l, mid);&#10;        if(node-&gt;r)&#10;            val_r = get(x, y, node-&gt;r, mid, r);&#10;&#10;        return f(val_l, val_r);&#10;    }&#10;&#10;};&#10;&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="persistentunionfind" value="struct UnionFind{&#10;    vector&lt;int&gt; par, time;&#10;    int count;&#10;    UnionFind(int n) : par(n, -1), time(n, MOD), count(0){}&#10;    // [0, t]の間に併合されたかどうか&#10;    int Find(int x, int t){return par[x] &lt; 0 || time[x] &gt; t ? x : Find(par[x], t);}&#10;    int Size(int x){return par[x] &lt; 0 ? -par[x] : Size(par[x]);}&#10;    // 現在のcount+1のタイミングで併合された事にする&#10;    // Unite失敗時もcountが増えるので注意&#10;    int Unite(int x, int y){&#10;        x = Find(x, MOD + 1);&#10;        y = Find(y, MOD + 1);&#10;        ++count;&#10;        if(x == y)&#10;            return 0;&#10;        if(par[x] &gt; par[y])&#10;            swap(x, y);&#10;        par[x] += par[y];&#10;        par[y] = x;&#10;        time[y] = count;&#10;        return count;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="primaldual" value="template &lt;typename T, typename U&gt;&#10;struct PrimalDual{&#10;    struct Edge{&#10;        int to, rev;&#10;        U cap;&#10;        T cost;&#10;        Edge(int to, U cap, T cost, int rev) :&#10;            to(to), rev(rev), cap(cap), cost(cost){}&#10;    };&#10;    vector&lt;vector&lt;Edge&gt;&gt; edges;&#10;    T _inf;&#10;    vector&lt;T&gt; potential, min_cost;&#10;    vector&lt;int&gt; prev_v, prev_e;&#10;&#10;    PrimalDual(int n) : edges(n), _inf(numeric_limits&lt;T&gt;::max()){}&#10;&#10;    void add(int from, int to, U cap, T cost){&#10;        edges[from].emplace_back(to, cap, cost, static_cast&lt;int&gt;(edges[to].size()));&#10;        edges[to].emplace_back(from, 0, -cost, static_cast&lt;int&gt;(edges[from].size()) - 1);&#10;    }&#10;&#10;    T solve(int s, int t, U flow){&#10;        int n = edges.size();&#10;        T ret = 0;&#10;        priority_queue&lt;pair&lt;T,int&gt;, vector&lt;pair&lt;T,int&gt;&gt;, greater&lt;pair&lt;T,int&gt;&gt;&gt; que;&#10;        potential.assign(n, 0);&#10;        prev_v.assign(n, -1);&#10;        prev_e.assign(n, -1);&#10;        while(flow &gt; 0){&#10;            min_cost.assign(n, _inf);&#10;            que.emplace(0, s);&#10;            min_cost[s] = 0;&#10;            while(!que.empty()){&#10;                T fl;&#10;                int pos;&#10;                tie(fl, pos) = que.top();&#10;                que.pop();&#10;                if(min_cost[pos] != fl)&#10;                    continue;&#10;                for(int i = 0; i &lt; edges[pos].size(); ++i){&#10;                    auto&amp; ed = edges[pos][i];&#10;                    T nex = fl + ed.cost + potential[pos] - potential[ed.to];&#10;                    if(ed.cap &gt; 0 &amp;&amp; min_cost[ed.to] &gt; nex){&#10;                        min_cost[ed.to] = nex;&#10;                        prev_v[ed.to] = pos;&#10;                        prev_e[ed.to] = i;&#10;                        que.emplace(min_cost[ed.to], ed.to);&#10;                    }&#10;                }&#10;            }&#10;            if(min_cost[t] == _inf)&#10;                return -1;&#10;            for(int i = 0; i &lt; n; ++i)&#10;                potential[i] += min_cost[i];&#10;            T add_flow = flow;&#10;            for(int x = t; x != s; x = prev_v[x])&#10;                add_flow = min(add_flow, edges[prev_v[x]][prev_e[x]].cap);&#10;            flow -= add_flow;&#10;            ret += add_flow * potential[t];&#10;            for(int x = t; x != s; x = prev_v[x]){&#10;                auto&amp; ed = edges[prev_v[x]][prev_e[x]];&#10;                ed.cap -= add_flow;&#10;                edges[x][ed.rev].cap += add_flow;&#10;            }&#10;        }&#10;        return ret;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rectanglesum" value="struct RectangleSum{//O(HW)で初期化してO(1)で長方形の和を出す(半開区間)&#10;    vector&lt;vector&lt;i64&gt;&gt; sum;&#10;    int h, w;&#10;    RectangleSum(vector&lt;vector&lt;i64&gt;&gt;&amp; v) :&#10;        h(v.size()),&#10;        w(v[0].size()),&#10;        sum(v)&#10;    {}&#10;&#10;    // 半開区間で設定する事に注意する&#10;    void set(int sx, int sy, int ex, int ey, i64 val){&#10;        sum[sx][sy] += val;&#10;        sum[sx][ey] -= val;&#10;        sum[ex][sy] -= val;&#10;        sum[ex][ey] += val;&#10;    }&#10;&#10;    void run(){&#10;&#10;        for(int i = 0; i &lt; h; ++i)&#10;            for(int j = 0; j &lt; w + 1; ++j)&#10;                sum[i + 1][j] += sum[i][j];&#10;&#10;        for(int i = 0; i &lt; h + 1; ++i)&#10;            for(int j = 0; j &lt; w; ++j)&#10;                sum[i][j + 1] += sum[i][j];&#10;    }&#10;&#10;    i64 getSum(int sx, int sy, int ex, int ey){&#10;        return sum[ex][ey] + sum[sx][sy] - sum[sx][ey] - sum[ex][sy];&#10;    }&#10;};&#10;&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rollinghash" value="template &lt;i64 mod1 = MOD, i64 mod2 = MOD + 2, i64 base = 10007, typename T = string&gt;&#10;struct RollingHash{&#10;&#10;    using mint1 = ModInt&lt;mod1&gt;;&#10;    using mint2 = ModInt&lt;mod2&gt;;&#10;    using pair_type = pair&lt;mint1, mint2&gt;;&#10;    int len;&#10;    std::vector&lt;pair_type&gt; v;&#10;    static std::vector&lt;pair_type&gt; power, inv;&#10;&#10;    RollingHash(T s) :&#10;    len(s.size())&#10;    {&#10;        v.assign(1, make_pair(mint1(0), mint2(0)));&#10;        for(int i = 0; i &lt; len; ++i){&#10;            auto c = s[i];&#10;            v.emplace_back(v.back().first + power[i].first * c,&#10;                           v.back().second + power[i].second * c);&#10;            if(static_cast&lt;int&gt;(power.size()) == i + 1){&#10;                power.emplace_back(power.back().first * base,&#10;                                   power.back().second * base);&#10;                inv.emplace_back(mpow(power.back().first, mod1 - 2),&#10;                                 mpow(power.back().second, mod2 - 2));&#10;            }&#10;        }&#10;    };&#10;&#10;    pair_type get(int l = 0, int r = -1){&#10;        if(r == -1)&#10;            r = len;&#10;        assert(l &lt;= r);&#10;        assert(r &lt;= len);&#10;        auto l_cut = make_pair(v[r].first - v[l].first,&#10;                               v[r].second - v[l].second);&#10;        return make_pair(l_cut.first * inv[l].first,&#10;                         l_cut.second * inv[l].second);&#10;    }&#10;&#10;    pair_type connect(pair_type l, pair_type r, int l_len){&#10;        return make_pair(l.first + power[l_len].first * r.first,&#10;                         l.second + power[l_len].second * r.second);&#10;    }&#10;};&#10;&#10;using RH = RollingHash&lt;MOD, MOD + 2, 10007&gt;;&#10;template&lt;&gt; vector&lt;pair&lt;ModInt&lt;MOD&gt;, ModInt&lt;MOD + 2&gt;&gt;&gt; RH::power = {make_pair(ModInt&lt;MOD&gt;(1), ModInt&lt;MOD + 2&gt;(1))};&#10;template&lt;&gt; vector&lt;pair&lt;ModInt&lt;MOD&gt;, ModInt&lt;MOD + 2&gt;&gt;&gt; RH::inv = {make_pair(ModInt&lt;MOD&gt;(1), ModInt&lt;MOD + 2&gt;(1))};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="segmentset" value="template &lt;typename T&gt;&#10;struct SegmentSet{&#10;    set&lt;pair&lt;T, T&gt;&gt; s;&#10;    set&lt;pair&lt;T, T&gt;&gt; s_rev;&#10;    SegmentSet(){}&#10;    // [l, r)を追加する&#10;    void insert(T l, T r){&#10;        auto iter = get(l).second;&#10;        if(iter != s.end() &amp;&amp; iter-&gt;first &lt;= l &amp;&amp; r &lt;= iter-&gt;second)&#10;            return;&#10;        vector&lt;pair&lt;T, T&gt;&gt; erase_elm;&#10;        for(auto it = s.lower_bound(make_pair(l, numeric_limits&lt;T&gt;::min())); it != s.end() &amp;&amp; it-&gt;first &lt;= r; ++it)&#10;            erase_elm.emplace_back(*it);&#10;        for(auto it = s_rev.lower_bound(make_pair(l, numeric_limits&lt;T&gt;::min())); it != s_rev.end() &amp;&amp; it-&gt;first &lt;= r; ++it)&#10;            erase_elm.emplace_back(it-&gt;second, it-&gt;first);&#10;        for(auto&amp; p : erase_elm){&#10;            chmin(l, p.first);&#10;            chmax(r, p.second);&#10;            s.erase(p);&#10;            s_rev.erase(make_pair(p.second, p.first));&#10;        }&#10;        s.emplace(l, r);&#10;        s_rev.emplace(r, l);&#10;    }&#10;    // xが含まれるような区間を返す&#10;    pair&lt;bool, typename set&lt;pair&lt;T, T&gt;&gt;::const_iterator&gt; get(T x){&#10;        auto it = s.lower_bound(make_pair(x, numeric_limits&lt;T&gt;::min()));&#10;        if(it != s.begin())&#10;            --it;&#10;        return make_pair(x &lt; it-&gt;second, it);&#10;    }&#10;    set&lt;pair&lt;T, T&gt;&gt;&amp; operator*(){return s;}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="segtree" value="template&lt;typename T&gt;&#10;struct Segtree{&#10;    int n;&#10;    T op;&#10;    vector&lt;T&gt; elm;&#10;    function&lt;T(T, T)&gt; f;&#10;&#10;    Segtree(int n, T init, function&lt;T(T, T)&gt; f, T op = T()) :&#10;        n(n),&#10;        op(op),&#10;        elm(2 * n, init),&#10;        f(f)&#10;    {&#10;        for(int i = n - 1; i &gt;= 1; --i)&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;    }&#10;&#10;    Segtree(int n, vector&lt;T&gt; init, function&lt;T(T, T)&gt; f, T op = T()) :&#10;        n(n),&#10;        op(op),&#10;        elm(2 * n),&#10;        f(f)&#10;    {&#10;        for(int i = 0; i &lt; n; ++i)&#10;            elm[i + n] = init[i];&#10;        for(int i = n - 1; i &gt;= 1; --i)&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;    }&#10;&#10;    void set(int x, T val){&#10;        x += n;&#10;        elm[x] = val;&#10;        while(x &gt;&gt;= 1)&#10;            elm[x] = f(elm[2 * x], elm[2 * x + 1]);&#10;    }&#10;&#10;    void update(int x, T val){&#10;        x += n;&#10;        elm[x] = f(elm[x], val);&#10;        while(x &gt;&gt;= 1)&#10;            elm[x] = f(elm[2 * x], elm[2 * x + 1]);&#10;    }&#10;&#10;    T get(int x, int y) const{&#10;        T l = op, r = op;&#10;        for(x += n, y += n - 1; x &lt;= y; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            if(x &amp; 1)&#10;                l = f(l, elm[x++]);&#10;            if(!(y &amp; 1))&#10;                r = f(elm[y--], r);&#10;        }&#10;        return f(l, r);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="skiplist" value="template &lt;typename T&gt;&#10;struct SkipList{&#10;&#10;    static uint32_t rnd(){&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = time(0);&#10;        uint32_t t = x ^ (x &lt;&lt; 11);&#10;        x = y, y = z, z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return w;&#10;    }&#10;&#10;    struct Node{&#10;        int height;&#10;        T val;&#10;        vector&lt;Node*&gt; next, prev;&#10;        vector&lt;T&gt; sum;&#10;        vector&lt;int&gt; size;&#10;        Node(T val, int height) : val(val), height(height), next(height, nullptr), prev(height, nullptr), sum(height, val), size(height, 1){}&#10;    };&#10;&#10;    using NodePtr = Node*;&#10;    int max_height;&#10;    NodePtr front, back;&#10;    function&lt;T(T, T)&gt; f;&#10;    T op;&#10;&#10;    SkipList(function&lt;T(T, T)&gt; f = [](auto x, auto y){return x;}, T op = T()) : max_height(0), f(f), op(op){&#10;        front = new Node(op, 32);&#10;        back = new Node(op, 32);&#10;        front-&gt;next[0] = back;&#10;        back-&gt;prev[0] = front;&#10;    }&#10;&#10;    int size(){&#10;        return front-&gt;size[max_height] - 1;&#10;    }&#10;&#10;    void insert_next(NodePtr pre, T key){&#10;        uint32_t r = max(rnd(), uint32_t(1));&#10;        int height = __builtin_ffs(r);&#10;        while(max_height &lt; height){&#10;            ++max_height;&#10;            front-&gt;size[max_height] = front-&gt;size[max_height - 1];&#10;            front-&gt;next[max_height] = back;&#10;            back-&gt;prev[max_height] = front;&#10;            front-&gt;sum[max_height] = front-&gt;sum[max_height - 1];&#10;        }&#10;        NodePtr node = new Node(key, height);&#10;&#10;        int pre_size = 1;&#10;        T pre_sum = pre-&gt;val;&#10;        T nex_sum = key;&#10;        NodePtr nex = pre-&gt;next[0];&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            ++pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = node;&#10;                node-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = node;&#10;                node-&gt;prev[i] = pre;&#10;                int range_size = pre-&gt;size[i];&#10;                pre-&gt;size[i] = pre_size;&#10;                pre-&gt;sum[i] = pre_sum;&#10;                node-&gt;size[i] = range_size - pre_size;&#10;                node-&gt;sum[i] = nex_sum;&#10;            }&#10;            else{&#10;                pre-&gt;sum[i] = f(pre_sum, nex_sum);&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i]){&#10;                pre_sum = f(pre-&gt;prev[i]-&gt;sum[i], pre_sum);&#10;                pre_size += pre-&gt;prev[i]-&gt;size[i];&#10;            }&#10;            for(; nex-&gt;height == i + 1  &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i]){&#10;                nex_sum = f(nex_sum, nex-&gt;sum[i]);&#10;            }&#10;        }&#10;    }&#10;&#10;    // idx番目(idx=0なら先頭)に挿入する&#10;    void insert_index(int idx, T key){&#10;        NodePtr pre = access(idx - 1);&#10;        insert_next(pre, key);&#10;    }&#10;&#10;    void insert_key(T key){&#10;        NodePtr pre = lower_bound(key)-&gt;prev[0];&#10;        insert_next(pre, key);&#10;    }&#10;&#10;    void erase(NodePtr target){&#10;        // メモリ解放はしない(してもいいけど)&#10;        int height = target-&gt;height;&#10;        NodePtr pre = target-&gt;prev[0];&#10;        NodePtr nex = target-&gt;next[0];&#10;        T sum = pre-&gt;val;&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            pre-&gt;sum[i] = sum;&#10;            --pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = pre;&#10;                pre-&gt;size[i] += target-&gt;size[i];&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i])&#10;                sum = f(pre-&gt;prev[i]-&gt;sum[i], sum);&#10;            for(; nex-&gt;height == i + 1 &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i])&#10;                sum = f(sum, nex-&gt;sum[i]);&#10;        }&#10;    }&#10;&#10;    void erase_index(int idx){&#10;        NodePtr target = access(idx);&#10;        erase(target);&#10;    }&#10;    void erase_key(T key){&#10;        NodePtr target = lower_bound(key);&#10;        if(target == back || target-&gt;val != key)&#10;            return;&#10;        erase(target);&#10;    }&#10;&#10;    NodePtr lower_bound(T key){&#10;        NodePtr pre = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; pre-&gt;next.size() &amp;&amp; pre-&gt;next[i] != back &amp;&amp; pre-&gt;next[i]-&gt;val &lt; key; pre = pre-&gt;next[i]);&#10;        return pre-&gt;next[0];&#10;    }&#10;&#10;    NodePtr upper_bound(T key){&#10;        NodePtr pre = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; pre-&gt;next.size() &amp;&amp; pre-&gt;next[i] != back &amp;&amp; pre-&gt;next[i]-&gt;val &lt;= key; pre = pre-&gt;next[i]);&#10;        return pre-&gt;next[0];&#10;    }&#10;&#10;    bool contains(T key){&#10;        NodePtr ptr = lower_bound(key);&#10;        return ptr != back &amp;&amp; ptr-&gt;key == key;&#10;    }&#10;&#10;    // 0-indexedでアクセスする&#10;    NodePtr access(int idx){&#10;        ++idx;&#10;        assert(0 &lt;= idx &amp;&amp; idx &lt;= size());&#10;        NodePtr ptr = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; ptr-&gt;next.size() &amp;&amp; ptr-&gt;next[i] != back &amp;&amp; ptr-&gt;size[i] &lt;= idx; idx -= ptr-&gt;size[i], ptr = ptr-&gt;next[i]);&#10;        return ptr;&#10;    }&#10;&#10;    T get(int l, int r){&#10;        NodePtr ptr = access(l);&#10;        T sum = op;&#10;        int diff = r - l;&#10;        int height_bound = 32;&#10;        for(; ptr-&gt;size[ptr-&gt;height - 1] &lt;= diff; ptr = ptr-&gt;next[ptr-&gt;height - 1]){&#10;            diff -= ptr-&gt;size[ptr-&gt;height - 1];&#10;            sum = f(sum, ptr-&gt;sum[ptr-&gt;height - 1]);&#10;        }&#10;        for(int i = ptr-&gt;height - 2; diff; --i)&#10;            for(; ptr-&gt;size[i] &lt;= diff; ptr = ptr-&gt;next[i]){&#10;                diff -= ptr-&gt;size[i];&#10;                sum = f(sum, ptr-&gt;sum[i]);&#10;            }&#10;        return sum;&#10;    }&#10;&#10;    void print(){&#10;        for(NodePtr node = front; node != nullptr; node = node-&gt;next[0]){&#10;            if(node == front || node == back)&#10;                printf(&quot;  null: &quot;);&#10;            else&#10;                printf(&quot;%6lld: &quot;, node-&gt;val);&#10;            for(int i = 0; i &lt; node-&gt;height; ++i)&#10;                printf(&quot;%2d &quot;, node-&gt;sum[i]);&#10;                // cout &lt;&lt; node-&gt;size[i] &lt;&lt; &quot; &quot;;&#10;            cout &lt;&lt; endl;&#10;        }&#10;        cout &lt;&lt; endl;&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="skiplist_sset" value="template &lt;typename T&gt;&#10;struct SSet{&#10;&#10;    static uint32_t rnd(){&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = time(0);&#10;        uint32_t t = x ^(x &lt;&lt; 11);&#10;        x = y, y = z, z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return w;&#10;    }&#10;&#10;    struct Node{&#10;        int height;&#10;        T val;&#10;        vector&lt;Node *&gt; next, prev;&#10;        vector&lt;int&gt; size;&#10;        Node(T val, int height) : val(val), height(height), next(height, nullptr), prev(height, nullptr), size(height, 1){}&#10;    };&#10;&#10;    using NodePtr = Node*;&#10;    int max_height;&#10;    NodePtr front, back;&#10;&#10;    SSet(Node* fr = nullptr, Node* ba = nullptr) : max_height(0), front(fr), back(ba){&#10;        if(front == nullptr){&#10;            front = new Node(T(), 21);&#10;            back = new Node(T(), 21);&#10;            front-&gt;next[0] = back;&#10;            back-&gt;prev[0] = front;&#10;        }&#10;    }&#10;&#10;    int size(){&#10;        return front-&gt;size[max_height] - 1;&#10;    }&#10;&#10;    void insert_next(NodePtr pre, T key, int height = -1){&#10;        if(height == -1){&#10;            uint32_t r = max(rnd(), uint32_t(1));&#10;            height = min(20, __builtin_ffs(r));&#10;        }&#10;        while(max_height &lt; height){&#10;            ++max_height;&#10;            front-&gt;size[max_height] = front-&gt;size[max_height - 1];&#10;            front-&gt;next[max_height] = back;&#10;            back-&gt;prev[max_height] = front;&#10;        }&#10;        NodePtr node = new Node(key, height);&#10;&#10;        int pre_size = 1;&#10;        NodePtr nex = pre-&gt;next[0];&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            ++pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = node;&#10;                node-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = node;&#10;                node-&gt;prev[i] = pre;&#10;                int range_size = pre-&gt;size[i];&#10;                pre-&gt;size[i] = pre_size;&#10;                node-&gt;size[i] = range_size - pre_size;&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i])&#10;                pre_size += pre-&gt;prev[i]-&gt;size[i];&#10;            for(; nex-&gt;height == i + 1 &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i]);&#10;        }&#10;    }&#10;&#10;    void insert(T key){&#10;        NodePtr pre = lower_bound(key)-&gt;prev[0];&#10;        insert_next(pre, key);&#10;    }&#10;&#10;    void erase(NodePtr target){&#10;        // メモリ解放はしない(してもいいけど)&#10;        int height = target-&gt;height;&#10;        NodePtr pre = target-&gt;prev[0];&#10;        NodePtr nex = target-&gt;next[0];&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            --pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = pre;&#10;                pre-&gt;size[i] += target-&gt;size[i];&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i]);&#10;            for(; nex-&gt;height == i + 1 &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i]);&#10;        }&#10;    }&#10;&#10;    void erase_index(int idx){&#10;        NodePtr target = access(idx);&#10;        erase(target);&#10;    }&#10;&#10;    void erase_key(T key){&#10;        NodePtr target = lower_bound(key);&#10;        if(target == back || target-&gt;val != key)&#10;            return;&#10;        erase(target);&#10;    }&#10;&#10;    NodePtr lower_bound(T key){&#10;        NodePtr pre = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; pre-&gt;next.size() &amp;&amp; pre-&gt;next[i] != back &amp;&amp; pre-&gt;next[i]-&gt;val &lt; key; pre = pre-&gt;next[i]);&#10;        return pre-&gt;next[0];&#10;    }&#10;&#10;    // 0-indexedでアクセスする&#10;    NodePtr access(int idx){&#10;        ++idx;&#10;        assert(0 &lt;= idx &amp;&amp; idx &lt;= size());&#10;        NodePtr ptr = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; ptr-&gt;next.size() &amp;&amp; ptr-&gt;next[i] != back &amp;&amp; ptr-&gt;size[i] &lt;= idx; idx -= ptr-&gt;size[i], ptr = ptr-&gt;next[i]);&#10;        return ptr;&#10;    }&#10;&#10;    // [0, k), [k, n)で分割し、[k, n)を返す&#10;    SSet&lt;T&gt; split(int k){&#10;        int max_h = max_height;&#10;        NodePtr pre = access(k - 1);&#10;        insert_next(pre, T(), 21);&#10;        NodePtr l_back = pre-&gt;next[0];&#10;        insert_next(l_back, T(), 21);&#10;        NodePtr r_front = l_back-&gt;next[0];&#10;        NodePtr l_front = front, r_back = back;&#10;        for(int i = 0; i &lt; l_back-&gt;height; ++i){&#10;            l_back-&gt;next[i] = nullptr;&#10;            r_front-&gt;prev[i] = nullptr;&#10;            l_back-&gt;size[i] = 1;&#10;        }&#10;        max_height = max_h;&#10;        NodePtr ptr = l_back;&#10;        int size = 1;&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            ptr-&gt;size[i] = size;&#10;            for(; ptr-&gt;height == i + 1 &amp;&amp; ptr-&gt;prev[i] != nullptr; ptr = ptr-&gt;prev[i])&#10;                size += ptr-&gt;prev[i]-&gt;size[i];&#10;        }&#10;        back = l_back;&#10;        SSet&lt;T&gt; sset(r_front, r_back);&#10;        sset.max_height = max_h;&#10;        return sset;&#10;    }&#10;&#10;    // thisの末尾にslistを結合する&#10;    void merge(SSet&lt;T&gt;&amp; slist){&#10;        while(max_height &lt; slist.max_height){&#10;            ++max_height;&#10;            front-&gt;size[max_height] = front-&gt;size[max_height - 1];&#10;            front-&gt;next[max_height] = back;&#10;            back-&gt;prev[max_height] = front;&#10;        }&#10;        while(slist.max_height &lt; max_height){&#10;            ++slist.max_height;&#10;            slist.front-&gt;size[slist.max_height] = slist.front-&gt;size[slist.max_height - 1];&#10;            slist.front-&gt;next[slist.max_height] = slist.back;&#10;            slist.back-&gt;prev[slist.max_height] = slist.front;&#10;        }&#10;        NodePtr a = back, b = slist.front;&#10;        for(int i = 0; i &lt; back-&gt;height; ++i){&#10;            a-&gt;next[i] = b;&#10;            b-&gt;prev[i] = a;&#10;        }&#10;        back = slist.back;&#10;        erase(a);&#10;        erase(b);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="splaytree_sset" value="template &lt;typename T&gt;&#10;struct SplayTree{&#10;    struct Node{&#10;        int size;&#10;        T val;&#10;        Node* par;&#10;        Node* c[2];&#10;        Node(){}&#10;        Node(T val, Node* nil) : val(val), size(1), par(nil){c[0] = nil; c[1] = nil;}&#10;    };&#10;    using NodePtr = Node*;&#10;    NodePtr nil;&#10;&#10;    SplayTree(){&#10;        nil = new Node(T(), nullptr);&#10;        nil-&gt;size = 0;&#10;        nil-&gt;par = nil-&gt;c[0] = nil-&gt;c[1] = nil;&#10;    }&#10;&#10;    NodePtr make(T val){&#10;        return new Node(val, nil);&#10;    }&#10;&#10;    void _update(NodePtr x){&#10;        if(x == nil)&#10;            return;&#10;        assert(x != x-&gt;c[0]);&#10;        assert(x != x-&gt;c[1]);&#10;        assert(x-&gt;c[0] == nil || x-&gt;c[0] != x-&gt;c[1]);&#10;        x-&gt;size = x-&gt;c[0]-&gt;size + x-&gt;c[1]-&gt;size + 1;&#10;        assert(x-&gt;size &gt; 0);&#10;    }&#10;&#10;    // idx側の子を上に持っていく&#10;    void rotate(NodePtr p, bool p_right){&#10;        NodePtr x = p-&gt;c[p_right];&#10;        NodePtr q = p-&gt;par;&#10;        // xに元々ついてた辺をpに張り替え&#10;        assert(p-&gt;c[p_right] == x);&#10;        p-&gt;c[p_right] = x-&gt;c[p_right ^ 1];&#10;        if(x-&gt;c[p_right ^ 1] != nil){&#10;            p-&gt;c[p_right]-&gt;par = p;&#10;            assert(p != p-&gt;c[p_right]);&#10;        }&#10;        // xp間の辺の張り替え&#10;        p-&gt;par = x;&#10;        x-&gt;c[p_right ^ 1] = p;&#10;        // pq間の辺の張り替え&#10;        x-&gt;par = q;&#10;        if(q != nil){&#10;            bool q_right = (q-&gt;c[1] == p);&#10;            assert(q-&gt;c[q_right] == p);&#10;            q-&gt;c[q_right] = x;&#10;        }&#10;        _update(p), _update(x), _update(q);&#10;    }&#10;&#10;    void reroot(NodePtr x){&#10;        while(x-&gt;par != nil){&#10;            NodePtr p = x-&gt;par;&#10;            NodePtr q = p-&gt;par;&#10;            bool q_right = (q-&gt;c[1] == p);&#10;            bool p_right = (p-&gt;c[1] == x);&#10;            if(p-&gt;par == nil){&#10;                rotate(p, p_right);&#10;                break;&#10;            }&#10;            // 同じ向きの二回回転&#10;            if(q_right == p_right){&#10;                rotate(q, q_right), rotate(p, p_right);&#10;            }&#10;            else{&#10;                rotate(p, p_right), rotate(q, q_right);&#10;            }&#10;        }&#10;    }&#10;&#10;    pair&lt;NodePtr, bool&gt; _lower_bound(NodePtr p, T key){&#10;        if(p == nil)&#10;            return make_pair(nil, false);&#10;        if(p-&gt;val &lt; key){&#10;            auto res = _lower_bound(p-&gt;c[1], key);&#10;            return res.second ? res : make_pair(p, false);&#10;        }&#10;        else{&#10;            auto res = _lower_bound(p-&gt;c[0], key);&#10;            return res.second ? res : make_pair(p, true);&#10;        }&#10;    }&#10;&#10;    pair&lt;NodePtr, bool&gt; lower_bound(NodePtr p, T key){&#10;        if(p == nil)&#10;            return make_pair(p, false);&#10;        auto res = _lower_bound(p, key);&#10;        reroot(res.first);&#10;        assert(res.first != nil);&#10;        return res;&#10;    }&#10;&#10;    NodePtr access(NodePtr p, int idx){&#10;        if(p == nil)&#10;            return nil;&#10;        while(p-&gt;c[0]-&gt;size != idx){&#10;            if(p-&gt;c[0]-&gt;size &lt; idx)&#10;                idx -= p-&gt;c[0]-&gt;size + 1, p = p-&gt;c[1];&#10;            else&#10;                p = p-&gt;c[0];&#10;            if(p == nil)&#10;                return nil;&#10;        }&#10;        reroot(p);&#10;        return p;&#10;    }&#10;&#10;    NodePtr next(NodePtr p){&#10;        reroot(p);&#10;        p = p-&gt;c[1];&#10;        while(p-&gt;c[0] != nil)&#10;            p = p-&gt;c[0];&#10;        if(p != nil)&#10;            reroot(p);&#10;        return p;&#10;    }&#10;&#10;    NodePtr prev(NodePtr p){&#10;        reroot(p);&#10;        p = p-&gt;c[0];&#10;        while(p-&gt;c[1] != nil)&#10;            p = p-&gt;c[1];&#10;        if(p != nil)&#10;            reroot(p);&#10;        return p;&#10;    }&#10;&#10;    pair&lt;NodePtr, bool&gt; insert(NodePtr root, T key){&#10;        if(root == nil)&#10;            return make_pair(make(key), true);&#10;        NodePtr l, r, np;&#10;        bool exist;&#10;        // lower_boundの結果からsplitする時、lower_boundの結果がnilだとバグるので注意&#10;        tie(np, exist) = lower_bound(root, key);&#10;        if(exist){&#10;            if(np-&gt;val == key)&#10;                return make_pair(np, false);&#10;            tie(l, r) = split(np);&#10;            return make_pair(merge(merge(l, make(key)), r), true);&#10;        }&#10;        else{&#10;            return make_pair(merge(np, make(key)), true);&#10;        }&#10;    }&#10;&#10;    pair&lt;NodePtr, bool&gt; erase(NodePtr root, T key){&#10;        NodePtr p = lower_bound(root, key).first;&#10;        reroot(p);&#10;        if(p == nil || p-&gt;val != key)&#10;            return make_pair(p, false);&#10;        NodePtr l = p-&gt;c[0], r = p-&gt;c[1];&#10;        l-&gt;par = r-&gt;par = nil;&#10;        delete(p);&#10;        return make_pair(merge(l, r), true);&#10;    }&#10;&#10;    // [0, p), [p, n)でsplist&#10;    pair&lt;NodePtr, NodePtr&gt; split(NodePtr p){&#10;        if(p == nil)&#10;            return make_pair(nil, nil);&#10;        reroot(p);&#10;        NodePtr l = p-&gt;c[0];&#10;        l-&gt;par = nil;&#10;        p-&gt;c[0] = nil;&#10;        _update(p);&#10;        return make_pair(l, p);&#10;    }&#10;&#10;    NodePtr merge(NodePtr p, NodePtr q){&#10;        reroot(p);&#10;        reroot(q);&#10;        if(q == nil)&#10;            return p;&#10;        if(p == nil)&#10;            return q;&#10;        while(p-&gt;c[1] != nil)&#10;            p = p-&gt;c[1];&#10;        reroot(p);&#10;        assert(p-&gt;c[1] == nil);&#10;        p-&gt;c[1] = q;&#10;        q-&gt;par = p;&#10;        _update(p);&#10;        assert(p != nil);&#10;        return p;&#10;    }&#10;&#10;    void print(NodePtr x, int p = 0){&#10;        if(x == nil)return;&#10;        if(p == 0)&#10;            cout &lt;&lt; &quot;----print----&quot; &lt;&lt; endl;&#10;        print(x-&gt;c[0], p + 8);&#10;        for(int i = 0; i &lt; p; ++i)&#10;            cout &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;val:&quot; &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;size:&quot; &lt;&lt; x-&gt;size &lt;&lt; endl;&#10;        print(x-&gt;c[1], p + 8);&#10;        if(p == 0)&#10;            cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="treap" value="template &lt;typename T, typename U = int&gt;&#10;struct Node{&#10;&#10;    using np = Node&lt;T, U&gt;*;&#10;&#10;    static np nil;&#10;&#10;    T val;&#10;    U lazy;&#10;    uint32_t pri;&#10;&#10;    int size;&#10;    T sum;&#10;&#10;    np l = nil;&#10;    np r = nil;&#10;&#10;    Node(T v, U OU = U()) : val(v), lazy(OU), pri(rndpri()), size(1), sum(v), l(nil), r(nil){}&#10;    Node(T v, U OU, uint32_t p) : val(v), lazy(OU), pri(p), size(1), sum(v), l(nil), r(nil){}&#10;&#10;    static uint32_t rndpri() {&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = time(0);&#10;        uint32_t t = x ^ (x &lt;&lt; 11);&#10;        x = y;&#10;        y = z;&#10;        z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return max&lt;uint32_t&gt;(1, w &amp; 0x3FFFFFFF);&#10;    }&#10;};&#10;&#10;&#10;template &lt;typename T, typename U = int&gt;&#10;class Treap{&#10;&#10;    using nt = Node&lt;T, U&gt;;&#10;    using np = nt*;&#10;    using F = function&lt;T(T, T)&gt;;&#10;    using G = function&lt;T(T, U, int)&gt;;&#10;    using H = function&lt;U(U, U)&gt;;&#10;&#10;public:&#10;&#10;    np root;&#10;    bool is_list;&#10;    F f;&#10;    G g;&#10;    H h;&#10;    T OT;&#10;    U OU;&#10;&#10;    Treap(bool is_list, F f, G g, H h, T OT, U OU) : root(nt::nil), is_list(is_list), f(f), g(g), h(h), OT(OT), OU(OU){}&#10;&#10;    Treap(T val, bool is_list, F f, G g, H h, T OT, U OU) : root(new nt(val)), is_list(is_list), f(f), g(g), h(h), OT(OT), OU(OU){}&#10;&#10;    // 配列で初期化する&#10;    Treap(vector&lt;T&gt; v, bool is_list, F f, G g, H h, T OT, U OU) : root(nt::nil), is_list(is_list), f(f), g(g), h(h), OT(OT), OU(OU){&#10;        for(auto&amp; xx : v)&#10;            root = _merge(root, new nt(xx, OU));&#10;    }&#10;&#10;    static Treap make(bool is_list, F f = [](T x, T){return x;}, T OT = T(), G g = [](auto x, auto, auto){return x;}, H h = [](auto x, auto){return x;}, U OU = U()){&#10;        assert(nt::nil != nullptr);&#10;        return Treap(is_list, f, g, h, OT, OU);&#10;    }&#10;&#10;    static Treap make(T val, bool is_list, F f = [](auto x, auto){return x;}, T OT = T(), G g = [](auto x, auto, auto){return x;}, H h = [](auto x, auto){return x;}, U OU = U()){&#10;        assert(nt::nil != nullptr);&#10;        return Treap(val, is_list, f, g, h, OT, OU);&#10;    }&#10;&#10;    static Treap make(vector&lt;T&gt; val, bool is_list, F f = [](auto x, auto){return x;}, T OT = T(), G g = [](auto x, auto, auto){return x;}, H h = [](auto x, auto){return x;}, U OU = U()){&#10;        assert(nt::nil != nullptr);&#10;        return Treap(val, is_list, f, g, h, OT, OU);&#10;    }&#10;&#10;    ~Treap(){&#10;        clear();&#10;        if(root != nt::nil)&#10;            delete root;&#10;    }&#10;&#10;    int _size(np x){return x == nt::nil ? 0 : x-&gt;size;}&#10;    T _sum(np x){return x == nt::nil ? OT : x-&gt;sum;}&#10;&#10;    np _update(np x){&#10;&#10;        if(x == nt::nil)&#10;            return x;&#10;&#10;        if(is_list){&#10;            _push(x);&#10;            _push(x-&gt;l);&#10;            _push(x-&gt;r);&#10;        }&#10;&#10;		x-&gt;sum = f(f(_sum(x-&gt;l), x-&gt;val), _sum(x-&gt;r));&#10;		x-&gt;size = _size(x-&gt;l) + _size(x-&gt;r) + 1;&#10;        return x;&#10;    }&#10;&#10;    void _push(np x){&#10;        if(x-&gt;lazy == OU)&#10;            return ;&#10;&#10;        x-&gt;sum = g(x-&gt;sum, x-&gt;lazy, x-&gt;size);&#10;        x-&gt;val = g(x-&gt;val, x-&gt;lazy, 1);&#10;&#10;        if(x-&gt;l != nt::nil)&#10;            x-&gt;l-&gt;lazy = h(x-&gt;l-&gt;lazy, x-&gt;lazy);&#10;        if(x-&gt;r != nt::nil)&#10;            x-&gt;r-&gt;lazy = h(x-&gt;r-&gt;lazy, x-&gt;lazy);&#10;&#10;        x-&gt;lazy = OU;&#10;&#10;    }&#10;&#10;    np _merge(np l, np r){&#10;        if(l == nt::nil || r ==nt::nil)&#10;            return l == nt::nil ? r : l;&#10;&#10;        if(l-&gt;pri &gt; r-&gt;pri){&#10;            l-&gt;r = _merge(l-&gt;r, r);&#10;            return _update(l);&#10;        }else{&#10;            r-&gt;l = _merge(l, r-&gt;l);&#10;            return _update(r);&#10;        }&#10;    }&#10;&#10;    pair&lt;np,np&gt; _split(np x, int k){&#10;        if(x == nt::nil)&#10;            return make_pair(nt::nil, nt::nil);&#10;&#10;        assert(0 &lt;= k &amp;&amp; k &lt;= _size(x));&#10;&#10;        if(k &lt;= _size(x-&gt;l)){&#10;            pair&lt;np, np&gt; s = _split(x-&gt;l, k);&#10;            x-&gt;l = s.second;&#10;            return make_pair(s.first, _update(x));&#10;&#10;        }else{&#10;            pair&lt;np, np&gt; s = _split(x-&gt;r, k - _size(x-&gt;l) - 1);&#10;            x-&gt;r = s.first;&#10;            return make_pair(_update(x), s.second);&#10;        }&#10;    }&#10;&#10;    np _insert(np x, int k, T val){&#10;        np l, r;&#10;        tie(l, r) = _split(x, k);&#10;        return _merge(_merge(l, new nt(val, OU)), r);&#10;    }&#10;&#10;    np _erase(np x, int k){&#10;        np l, r, m;&#10;        tie(l, r) = _split(x, k);&#10;        tie(m, r) = _split(r, 1);&#10;        if(m != nt::nil)&#10;            delete m;&#10;        return _merge(l, r);&#10;    }&#10;&#10;    void _set(np x, int k, T val){&#10;        _update(x);&#10;&#10;        if(k &lt; _size(x-&gt;l))&#10;            _set(x-&gt;l, k, val);&#10;        else if(_size(x-&gt;l) == k)&#10;            x-&gt;val = val;&#10;        else&#10;            _set(x-&gt;r, k - _size(x-&gt;l) - 1, val);&#10;&#10;        _update(x);&#10;    }&#10;&#10;    void _add(np x, int l, int r, U val){&#10;        assert(is_list);&#10;        _update(x);&#10;&#10;        if(x == nt::nil)&#10;            return ;&#10;        l = max(l, 0);&#10;        r = min(r, _size(x));&#10;&#10;        int sl = _size(x-&gt;l);&#10;&#10;        if(l &gt;= r)&#10;            return ;&#10;&#10;        if (l == 0 &amp;&amp; r == _size(x)){&#10;            x-&gt;lazy = h(x-&gt;lazy, val);&#10;        }&#10;        else{&#10;            if(l &lt;= sl &amp;&amp; sl &lt; r)&#10;                x-&gt;val = g(x-&gt;val, val, 1);&#10;&#10;            _add(x-&gt;l, l, r, val);&#10;            _add(x-&gt;r, l - sl - 1, r - sl - 1, val);&#10;        }&#10;&#10;        _update(x);&#10;    }&#10;&#10;    np _getnode(np x, int k){&#10;&#10;        _update(x);&#10;&#10;        assert(0 &lt;= k &amp;&amp; k &lt; _size(x));&#10;&#10;        if(k &lt; _size(x-&gt;l))&#10;            return _getnode(x-&gt;l, k);&#10;        else if(_size(x-&gt;l) == k)&#10;            return x;&#10;        else&#10;            return _getnode(x-&gt;r, k - _size(x-&gt;l) - 1);&#10;    }&#10;&#10;    T _get(np x, int k){&#10;        return _getnode(x, k)-&gt;val;&#10;    }&#10;&#10;    T _rangesum(np x, int l, int r){&#10;        _update(x);&#10;&#10;        l = max(l, 0);&#10;        r = min(r, _size(x));&#10;        if(l &gt;= r)&#10;            return OT;&#10;        if(l == 0 &amp;&amp; r == _size(x))&#10;            return _sum(x);&#10;&#10;        int sl = _size(x-&gt;l);&#10;        T ret = (l &lt;= sl &amp;&amp; sl &lt; r ? x-&gt;val : OT);&#10;        ret = f(_rangesum(x-&gt;l, l, r), ret);&#10;        ret = f(ret, _rangesum(x-&gt;r, l - sl - 1, r - sl - 1));&#10;        return ret;&#10;    }&#10;&#10;    int _lowerbound(np x, T val){&#10;        _update(x);&#10;&#10;        if(x == nt::nil)&#10;            return 0;&#10;        if(val &lt;= x-&gt;val)&#10;            return _lowerbound(x-&gt;l, val);&#10;        else&#10;            return _lowerbound(x-&gt;r,val) + _size(x-&gt;l) + 1;&#10;    }&#10;&#10;    int _upperbound(np x, T val){&#10;        _update(x);&#10;&#10;        if(x == nt::nil)&#10;            return 0;&#10;        if(val &lt; x-&gt;val)&#10;            return _upperbound(x-&gt;l, val);&#10;        else&#10;            return _upperbound(x-&gt;r,val) + _size(x-&gt;l) + 1;&#10;    }&#10;&#10;    np _insert(np x, T val){&#10;        return _insert(x, _lowerbound(x, val), val);&#10;    }&#10;&#10;    void _clear(np x){&#10;        if(x-&gt;l != nt::nil){&#10;            _clear(x-&gt;l);&#10;            delete(x-&gt;l);&#10;            x-&gt;l = nt::nil;&#10;        }&#10;        if(x-&gt;r != nt::nil){&#10;            _clear(x-&gt;r);&#10;            delete(x-&gt;r);&#10;            x-&gt;r = nt::nil;&#10;        }&#10;    }&#10;&#10;    void push_front(T val){&#10;        root = _merge(new nt(val, OU), root);&#10;    }&#10;&#10;    void push_back(T val){&#10;        root = _merge(root, new nt(val, OU));&#10;    }&#10;&#10;    void pop_front(){&#10;        root = _split(root, 1).second;&#10;    }&#10;&#10;    void pop_back(){&#10;        root = _split(root, _size(root) - 1).first;&#10;    }&#10;&#10;    // [0, k)と[k, size)に分割して, [k, size)側を返す&#10;    Treap split_left(int k){&#10;        np p;&#10;        tie(root, p) = _split(root, k);&#10;        return decltype(this)(f, g, h, p);&#10;    }&#10;&#10;    // [0, k)と[k, size)に分割して, [0, k)側を返す&#10;    Treap split_right(int k){&#10;        np p;&#10;        tie(p, root) = _split(root, k);&#10;        return decltype(this)(f, g, h, p);&#10;    }&#10;&#10;    // rootを含めたサイズの出力&#10;    int size(){&#10;        return (root == nt::nil ? 0 : root-&gt;size);&#10;    }&#10;&#10;    // k番目への代入&#10;    void set(int k, T val){&#10;        return _set(root, k, val);&#10;    }&#10;&#10;    // k番目への加算&#10;    void add(int k, U val){&#10;        assert(is_list);&#10;        return _add(root, k, k + 1, val);&#10;    }&#10;&#10;    // [l, r)への一様加算&#10;    void add(int l, int r, U val){&#10;        assert(is_list);&#10;        return _add(root, l, r, val);&#10;    }&#10;&#10;    // k番目の取得&#10;    T get(int k){&#10;        return _get(root, k);&#10;    }&#10;&#10;    // [l, r)の総和 (同様の実装でRMQ等も可能)&#10;    T get(int l, int r){&#10;        return _rangesum(root, l, r);&#10;    }&#10;&#10;    // k番目への挿入&#10;    void insert(int k, T val){&#10;        assert(is_list);&#10;        root = _insert(root, k, val);&#10;    }&#10;&#10;    // 適切な位置への挿入&#10;    void insert(T val){&#10;        root = _insert(root, val);&#10;    }&#10;&#10;    // val &lt;= get(k) となるような最小のk&#10;    int lowerbound(T val){&#10;        return _lowerbound(root, val);&#10;    }&#10;&#10;    // val &lt; get(k) となるような最小のk&#10;    int upperbound(T val){&#10;        return _upperbound(root, val);&#10;    }&#10;&#10;    // k番目の要素削除&#10;    void erase(int k){&#10;        root = _erase(root, k);&#10;    }&#10;&#10;    // 要素の全削除&#10;    void clear(){&#10;        if(root != nt::nil){&#10;            _clear(root);&#10;            delete(root);&#10;            root = nt::nil;&#10;        }&#10;    }&#10;};&#10;&#10;const i64 val = 0;&#10;const i64 op = -1e9;&#10;using node_type = Node&lt;i64, i64&gt;;&#10;template&lt;&gt; node_type* node_type::nil = new node_type(0, op, 0);&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="trie" value="template &lt;int size = 26, int start = 'a'&gt;&#10;struct Trie{&#10;    struct Node{&#10;        // 値, prefixに含む文字列の数, 文字列の数&#10;        int val, len, cnt, exist_cnt;&#10;        // 子のindex, 子の(indexの)一覧&#10;        vector&lt;int&gt; next, exist;&#10;        Node(int val = -1, int len = 0, bool back = false) : val(val), len(len), cnt(0), exist_cnt(back), next(size, -1){}&#10;    };&#10;&#10;    vector&lt;Node&gt; nodes;&#10;    Trie() : nodes(1){}&#10;&#10;    int insert(string&amp; s, int str_index = 0){&#10;        int pos = 0, idx = str_index;&#10;        while(idx != s.size()){&#10;            ++nodes[pos].cnt;&#10;            int c = s[idx] - start;&#10;            assert(c &lt; size);&#10;&#10;            if(nodes[pos].next[c] == -1){&#10;                nodes[pos].next[c] = nodes.size();&#10;                nodes[pos].exist.emplace_back(nodes.size());&#10;                nodes.emplace_back(c, nodes[pos].len + 1);&#10;            }&#10;            pos = nodes[pos].next[c];&#10;            ++idx;&#10;        }&#10;        ++nodes[pos].cnt;&#10;        ++nodes[pos].exist_cnt;&#10;        return pos;&#10;    }&#10;&#10;    // (sの部分文字列, s, sを部分文字列に含む文字列)に対して関数を実行する&#10;    // ラムダ内でtrie.nodes[idx].exist_cntを判定する事で, 挿入された文字列そのもの以外判定しなくなる&#10;    void query(string&amp; s, function&lt;void(int, string&amp;)&gt; f, bool from_prefix, bool correct, bool to_prefix, int str_index = 0){&#10;        int pos = 0, idx = str_index;&#10;        string str;&#10;        while(idx != s.size()){&#10;            if(from_prefix)&#10;                f(pos, str);&#10;            int c = s[idx] - start;&#10;            assert(c &lt; size);&#10;&#10;            if(nodes[pos].next[c] == -1)&#10;                return ;&#10;            pos = nodes[pos].next[c];&#10;            str += static_cast&lt;char&gt;(nodes[pos].val + start);&#10;            ++idx;&#10;        }&#10;        if(correct)&#10;            f(pos, str);&#10;        function&lt;void(int)&gt; dfs = [&amp;](int pos){&#10;            for(auto&amp; next : nodes[pos].exist){&#10;                char c = nodes[next].val + start;&#10;                if(to_prefix)&#10;                    f(pos, str);&#10;                str += c;&#10;                dfs(next);&#10;                str.pop_back();&#10;            }&#10;        };&#10;        dfs(pos);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="unionfind" value="struct UnionFind{&#10;    vector&lt;int&gt; par;&#10;    int count;&#10;    UnionFind(int n) : par(n, -1), count(0){}&#10;    int Find(int x){return par[x] &lt; 0 ? x : Find(par[x]);}&#10;    int Size(int x){return par[x] &lt; 0 ? -par[x] : Size(par[x]);}&#10;    bool Unite(int x, int y){&#10;        x = Find(x);&#10;        y = Find(y);&#10;        if(x == y)&#10;            return false;&#10;        if(par[x] &gt; par[y])&#10;            swap(x, y);&#10;        par[x] += par[y];&#10;        par[y] = x;&#10;        return ++count;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="vanemdeboastree" value="template &lt;uint32_t W, uint32_t NULL_FLAG = ~0u&gt;&#10;struct VanEmdeBoasTree{&#10;&#10;    // サイズ2^(2^U)のノード&#10;    // U=0からでサイズが2, 4, 16, 256, 65536, となる&#10;    struct Node{&#10;        uint32_t u, ma, mi;&#10;        Node* aux;&#10;        vector&lt;Node*&gt; c;&#10;        Node(int u, int n) : u(u), mi(NULL_FLAG), ma(0){&#10;            if(u){&#10;                while(n){&#10;                    int d = min(1 &lt;&lt; (1 &lt;&lt; (u - 1)), n);&#10;                    Node *node = new Node(u - 1, d);&#10;                    c.push_back(node);&#10;                    n -= d;&#10;                }&#10;                aux = new Node(u - 1, c.size());&#10;            }&#10;        }&#10;    };&#10;    Node* root;&#10;    VanEmdeBoasTree(){&#10;        root = new Node(32 - __builtin_clz(W - 1), 1 &lt;&lt; W);&#10;        insert((1 &lt;&lt; W) - 1, root);&#10;    }&#10;&#10;    bool insert(uint32_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;u == 0){&#10;            bool fl = (ptr-&gt;ma &lt; key) || (key &lt; ptr-&gt;mi);&#10;            ptr-&gt;ma = max(ptr-&gt;ma, key);&#10;            ptr-&gt;mi = min(ptr-&gt;mi, key);&#10;            return fl;&#10;        }&#10;        if(ptr-&gt;mi &gt; ptr-&gt;ma){&#10;            ptr-&gt;mi = ptr-&gt;ma = key;&#10;            return true;&#10;        }&#10;        if(key &lt; ptr-&gt;mi){&#10;            swap(key, ptr-&gt;mi);&#10;        }&#10;        else if(ptr-&gt;mi == key)&#10;            return false;&#10;        if(ptr-&gt;ma &lt; key)&#10;            ptr-&gt;ma = key;&#10;&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        uint32_t idx = uint64_t(key) &gt;&gt; shift_cnt;&#10;        uint32_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1u);&#10;&#10;        assert(idx &lt; ptr-&gt;c.size());&#10;&#10;        if(ptr-&gt;c[idx]-&gt;mi &gt; ptr-&gt;c[idx]-&gt;ma){&#10;            insert(idx, ptr-&gt;aux);&#10;        }&#10;        return insert(next_key, ptr-&gt;c[idx]);&#10;    }&#10;&#10;    bool erase(uint32_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;mi &gt; ptr-&gt;ma){&#10;            return false;&#10;        }&#10;        if(ptr-&gt;mi == ptr-&gt;ma){&#10;            if(ptr-&gt;mi == key){&#10;                ptr-&gt;mi = NULL_FLAG;&#10;                ptr-&gt;ma = 0;&#10;                return true;&#10;            }&#10;            return false;&#10;        }&#10;        if(ptr-&gt;u == 0){&#10;            // 2要素あるうちの1要素が残る&#10;            assert(ptr-&gt;mi == key || ptr-&gt;ma == key);&#10;            i64 x = ptr-&gt;mi == key ? ptr-&gt;ma : ptr-&gt;mi;&#10;            ptr-&gt;mi = ptr-&gt;ma = x;&#10;            return true;&#10;        }&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        if(ptr-&gt;mi == key)&#10;            ptr-&gt;mi = key = ((ptr-&gt;aux-&gt;mi &lt;&lt; shift_cnt) | ptr-&gt;c[ptr-&gt;aux-&gt;mi]-&gt;mi);&#10;&#10;        uint32_t idx = uint64_t(key) &gt;&gt; shift_cnt;&#10;        uint32_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1u);&#10;        auto nex = ptr-&gt;c[idx];&#10;        if(erase(next_key, nex)){&#10;            if(nex-&gt;mi &gt; nex-&gt;ma)&#10;                erase(idx, ptr-&gt;aux);&#10;            if(ptr-&gt;ma == key){&#10;                if(ptr-&gt;aux-&gt;mi &gt; ptr-&gt;aux-&gt;ma)&#10;                    ptr-&gt;ma = ptr-&gt;mi;&#10;                else&#10;                    ptr-&gt;ma = ((ptr-&gt;aux-&gt;ma &lt;&lt; shift_cnt) | ptr-&gt;c[ptr-&gt;aux-&gt;ma]-&gt;ma);&#10;            }&#10;            return true;&#10;        }&#10;        else&#10;            return false;&#10;    }&#10;&#10;    uint32_t lower_bound(uint32_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;u == 0){&#10;            assert(key &lt;= ptr-&gt;ma);&#10;            return key &lt;= ptr-&gt;mi ? ptr-&gt;mi : ptr-&gt;ma;&#10;        }&#10;        if(key &lt;= ptr-&gt;mi){&#10;            assert(ptr-&gt;mi != NULL_FLAG);&#10;            return ptr-&gt;mi;&#10;        }&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        uint32_t idx = uint64_t(key) &gt;&gt; shift_cnt;&#10;        uint32_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1u);&#10;        assert(idx &lt; ptr-&gt;c.size());&#10;&#10;        auto nex = ptr-&gt;c[idx];&#10;        if(nex-&gt;mi != NULL_FLAG &amp;&amp; next_key &lt;= nex-&gt;ma){&#10;            return (idx &lt;&lt; shift_cnt) | lower_bound(next_key, nex);&#10;        }&#10;&#10;        uint64_t i = lower_bound(idx + 1, ptr-&gt;aux);&#10;        return (i &lt;&lt; shift_cnt) | ptr-&gt;c[i]-&gt;mi;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="vanemdeboastree2" value="// 必要な所だけ作るvEB木&#10;template &lt;uint32_t W, uint64_t NULL_FLAG = ~0uLL&gt;&#10;struct VanEmdeBoasTree{&#10;&#10;    struct Node{&#10;        uint64_t u, ma, mi;&#10;        Node* aux;&#10;        HashMap&lt;int, Node*&gt; c;&#10;        Node(int u) : u(u), mi(NULL_FLAG), ma(0){&#10;            if(u)&#10;                aux = new Node(u - 1);&#10;        }&#10;    };&#10;    Node* root;&#10;    VanEmdeBoasTree(){&#10;        root = new Node(64 - __builtin_clzll(W - 1));&#10;        insert((1uLL &lt;&lt; W) - 1, root);&#10;    }&#10;&#10;    Node* child(Node* ptr, uint64_t idx){&#10;        assert(ptr-&gt;u &gt; 0);&#10;        auto res = ptr-&gt;c.find(idx);&#10;        if(res.second)&#10;            return res.first;&#10;        ptr-&gt;c.add(idx, new Node(ptr-&gt;u - 1));&#10;        return ptr-&gt;c.find(idx).first;&#10;    }&#10;&#10;    bool insert(uint64_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;u == 0){&#10;            bool fl = (ptr-&gt;ma &lt; key) || (key &lt; ptr-&gt;mi);&#10;            ptr-&gt;ma = max(ptr-&gt;ma, key);&#10;            ptr-&gt;mi = min(ptr-&gt;mi, key);&#10;            return fl;&#10;        }&#10;        if(ptr-&gt;mi &gt; ptr-&gt;ma){&#10;            ptr-&gt;mi = ptr-&gt;ma = key;&#10;            return true;&#10;        }&#10;        if(key &lt; ptr-&gt;mi){&#10;            swap(key, ptr-&gt;mi);&#10;        }&#10;        else if(ptr-&gt;mi == key)&#10;            return false;&#10;        if(ptr-&gt;ma &lt; key)&#10;            ptr-&gt;ma = key;&#10;&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        uint64_t idx = key &gt;&gt; shift_cnt;&#10;        uint64_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1);&#10;&#10;        if(child(ptr, idx)-&gt;mi &gt; child(ptr, idx)-&gt;ma)&#10;            insert(idx, ptr-&gt;aux);&#10;        return insert(next_key, child(ptr, idx));&#10;    }&#10;&#10;    bool erase(uint64_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;mi &gt; ptr-&gt;ma)&#10;            return false;&#10;        if(ptr-&gt;mi == ptr-&gt;ma){&#10;            if(ptr-&gt;mi == key){&#10;                ptr-&gt;mi = NULL_FLAG;&#10;                ptr-&gt;ma = 0;&#10;                return true;&#10;            }&#10;            return false;&#10;        }&#10;        if(ptr-&gt;u == 0){&#10;            // 2要素あるうちの1要素が残る&#10;            assert(ptr-&gt;mi == key || ptr-&gt;ma == key);&#10;            uint64_t x = ptr-&gt;mi == key ? ptr-&gt;ma : ptr-&gt;mi;&#10;            ptr-&gt;mi = ptr-&gt;ma = x;&#10;            return true;&#10;        }&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        if(ptr-&gt;mi == key)&#10;            ptr-&gt;mi = key = ((ptr-&gt;aux-&gt;mi &lt;&lt; shift_cnt) | child(ptr, ptr-&gt;aux-&gt;mi)-&gt;mi);&#10;&#10;        uint64_t idx = uint64_t(key) &gt;&gt; shift_cnt;&#10;        uint64_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1);&#10;        auto nex = child(ptr, idx);&#10;        if(erase(next_key, nex)){&#10;            if(nex-&gt;mi &gt; nex-&gt;ma)&#10;                erase(idx, ptr-&gt;aux);&#10;            if(ptr-&gt;ma == key){&#10;                if(ptr-&gt;aux-&gt;mi &gt; ptr-&gt;aux-&gt;ma)&#10;                    ptr-&gt;ma = ptr-&gt;mi;&#10;                else&#10;                    ptr-&gt;ma = ((ptr-&gt;aux-&gt;ma &lt;&lt; shift_cnt) | child(ptr, ptr-&gt;aux-&gt;ma)-&gt;ma);&#10;            }&#10;            return true;&#10;        }&#10;        else&#10;            return false;&#10;    }&#10;&#10;    uint32_t lower_bound(uint64_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;u == 0){&#10;            assert(key &lt;= ptr-&gt;ma);&#10;            return key &lt;= ptr-&gt;mi ? ptr-&gt;mi : ptr-&gt;ma;&#10;        }&#10;        if(key &lt;= ptr-&gt;mi){&#10;            assert(ptr-&gt;mi != NULL_FLAG);&#10;            return ptr-&gt;mi;&#10;        }&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        uint64_t idx = uint64_t(key) &gt;&gt; shift_cnt;&#10;        uint64_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1);&#10;&#10;        auto nex = child(ptr, idx);&#10;        if(nex-&gt;mi != NULL_FLAG &amp;&amp; next_key &lt;= nex-&gt;ma){&#10;            return (idx &lt;&lt; shift_cnt) | lower_bound(next_key, nex);&#10;        }&#10;&#10;        uint64_t i = lower_bound(idx + 1, ptr-&gt;aux);&#10;        return (i &lt;&lt; shift_cnt) | child(ptr, i)-&gt;mi;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="waveletmatrix" value="&#10;struct BitVector{&#10;    int n, m;&#10;    vector&lt;int&gt; l;&#10;    vector&lt;uint64_t&gt; s;&#10;&#10;    BitVector(int n) : n(n){&#10;        m = (n + 63) &gt;&gt; 6;&#10;        l.assign(m, 0);&#10;        s.assign(m, 0);&#10;    }&#10;&#10;    void set(int i, bool flag = true){&#10;        if(flag)&#10;            s[i &gt;&gt; 6] |= (1uLL &lt;&lt; (i &amp; 63));&#10;        else&#10;            s[i &gt;&gt; 6] &amp;= ~(1uLL &lt;&lt; (i &amp; 63));&#10;    }&#10;&#10;    void build(){&#10;        l[0] = 0;&#10;        for(int i = 1; i &lt; m; ++i)&#10;            l[i] = l[i - 1] + __builtin_popcountll(s[i - 1]);&#10;    }&#10;&#10;    // [0, r) count flag&#10;    int rank(int r, bool flag = true){&#10;        if(flag)&#10;            return l[r &gt;&gt; 6] + __builtin_popcountll(s[r &gt;&gt; 6] &amp; ((1uLL &lt;&lt; (r &amp; 63)) - 1));&#10;        else&#10;            return r - (l[r &gt;&gt; 6] + __builtin_popcountll(s[r &gt;&gt; 6] &amp; ((1uLL &lt;&lt; (r &amp; 63)) - 1)));&#10;    }&#10;&#10;};&#10;&#10;template &lt;typename T&gt;&#10;struct WaveletMatrix{&#10;    int n, m;&#10;    vector&lt;BitVector&gt; b;&#10;    vector&lt;int&gt; border;&#10;    WaveletMatrix(vector&lt;T&gt; a) : n(a.size()){&#10;        T max_val = *max_element(a.begin(), a.end());&#10;        m = (max_val == 0) ? 1 : 64 - __builtin_clzll(max_val);&#10;        b.resize(m, BitVector(n));&#10;        border.resize(m);&#10;        vector&lt;vector&lt;T&gt;&gt; v(2, vector&lt;T&gt;(n));&#10;        for(int j = m - 1; j &gt;= 0; --j){&#10;            vector&lt;int&gt; cnt(2, 0);&#10;            for(int i = 0; i &lt; n; ++i){&#10;                bool fl = ((a[i] &gt;&gt; j) &amp; 1);&#10;                if(fl)&#10;                    b[j].set(i);&#10;                v[fl][cnt[fl]++] = a[i];&#10;            }&#10;            swap(a, v[0]);&#10;            for(int i = 0; i &lt; cnt[1]; ++i) {&#10;                a[i + cnt[0]] = v[1][i];&#10;            }&#10;            b[j].build();&#10;            border[j] = cnt[0];&#10;        }&#10;    }&#10;&#10;    // [l, r) count x&#10;    int count(int l, int r, T x){&#10;        for(int j = m - 1; j &gt;= 0; --j){&#10;            bool fl = (x &gt;&gt; j) &amp; 1;&#10;            r = b[j].rank(r, fl) + (fl ? border[j] : 0);&#10;            l = b[j].rank(l, fl) + (fl ? border[j] : 0);&#10;        }&#10;        return r - l;&#10;    }&#10;&#10;    // [l, r) count k (x &lt;= k)&#10;    int count_lower(int l, int r, T x){&#10;        int cnt = 0;&#10;        for(int j = m - 1; j &gt;= 0; --j){&#10;            bool fl = (x &gt;&gt; j) &amp; 1;&#10;            if(fl)&#10;                cnt += (l - r) - b[j].rank(l, 0);&#10;            r = b[j].rank(r, fl) + (fl ? border[j] : 0);&#10;            l = b[j].rank(l, fl) + (fl ? border[j] : 0);&#10;        }&#10;        return cnt + (r - l);&#10;    }&#10;&#10;    // [l, r) count k (x &lt;= k &lt; y)&#10;    int count_range(int l, int r, T x, T y){&#10;        return count_lower(l, r, y - 1) - count_lower(l, r, x - 1);&#10;    }&#10;&#10;    // [l, r) k-th min value (k: 0-indexed)&#10;    T kth_min(int l, int r, int k){&#10;        if(r - l &lt; k)&#10;            return -1;&#10;        T ret = 0;&#10;        for(int j = m - 1; j &gt;= 0; --j){&#10;            int x = b[j].rank(r, false) - b[j].rank(l, false);&#10;            bool fl = (k &gt;= x);&#10;            if(fl){&#10;                ret |= (1uLL &lt;&lt; j);&#10;                k -= x;&#10;            }&#10;            r = b[j].rank(r, fl) + (fl ? border[j] : 0);&#10;            l = b[j].rank(l, fl) + (fl ? border[j] : 0);&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    // [l, r) k-th min value (k: 0-indexed)&#10;    T kth_max(int l, int r, int k){&#10;        return kth_min(l, r, (r - l - 1) - k);&#10;    }&#10;&#10;    // [l, r) upper_bound(k) value&#10;    T next_value_T(int l, int r, T k){&#10;        return kth_min(count_lower(l, r, k) + 1);&#10;    }&#10;&#10;    // [l, r) prev(lower_bound(k)) value&#10;    T prev_value(int l, int r, T k){&#10;        return kth_min(count_lower(l, r, k - 1));&#10;    }&#10;&#10;};" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="xfasttrie" value="template &lt;typename T, int W = 31, T HASHMAP_NULL = (1LL &lt;&lt; W) - 1, T HASHMAP_DEL = (1LL &lt;&lt; W) - 2&gt;&#10;struct XFastTrie{&#10;    struct Node{&#10;        T val;&#10;        int exist;&#10;        Node* c[2];&#10;        Node(T val) : val(val), exist(0){&#10;            // 子が存在するなら子へのポインタを持つ&#10;            // 葉なら左右はそれぞれprev,next&#10;            // 左の子が存在しないなら左はprevへのショートカット&#10;            // 右のが存在しないなら右はnextへのショートカット&#10;            c[0] = nullptr;&#10;            c[1] = nullptr;&#10;        }&#10;    };&#10;    int n;&#10;    Node* root;&#10;    Node* front;&#10;    Node* back;&#10;    array&lt;HashMap&lt;T, Node*, HASHMAP_NULL, HASHMAP_DEL&gt;, W&gt; hashmap;&#10;&#10;    XFastTrie() : n(0){&#10;        root = new Node(0);&#10;        front = new Node(0);&#10;        back = new Node(0);&#10;        front-&gt;exist = 2;&#10;        front-&gt;c[1] = back;&#10;        back-&gt;exist = 1;&#10;        back-&gt;c[0] = front;&#10;        root-&gt;c[0] = back;&#10;        root-&gt;c[1] = front;&#10;    }&#10;&#10;    void insert(T key){&#10;        // 存在しているノードは全部葉があると仮定する&#10;        T val = 0;&#10;        Node* ptr = root;&#10;        Node* nex = nullptr;&#10;        Node* pre = nullptr;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            bool exist = (ptr-&gt;exist &gt;&gt; fl) &amp; 1;&#10;            if(fl)&#10;                val += (1LL &lt;&lt; i);&#10;            if(!exist){&#10;                if(!nex){&#10;                    if(fl){&#10;                        pre = ptr-&gt;c[1];&#10;                        nex = pre-&gt;c[1];&#10;                    }&#10;                    else{&#10;                        nex = ptr-&gt;c[0];&#10;                        pre = nex-&gt;c[0];&#10;                    }&#10;                }&#10;                ptr-&gt;exist |= (1 &lt;&lt; fl);&#10;                ptr-&gt;c[fl] = new Node(val);&#10;                hashmap[i].add(val, ptr-&gt;c[fl]);&#10;                ptr-&gt;c[fl]-&gt;c[0] = back;&#10;                ptr-&gt;c[fl]-&gt;c[1] = front;&#10;            }&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        if(nex == nullptr)&#10;            return;&#10;        ++n;&#10;        assert(nex == back || key &lt; nex-&gt;val);&#10;        assert(pre == front || pre-&gt;val &lt; key);&#10;        pre-&gt;c[1] = ptr;&#10;        ptr-&gt;c[1] = nex;&#10;        nex-&gt;c[0] = ptr;&#10;        ptr-&gt;c[0] = pre;&#10;        assert(val == key &amp;&amp; ptr-&gt;val == key);&#10;&#10;        Node* new_node = ptr;&#10;        ptr = root;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            if(!(ptr-&gt;exist &amp; 1) &amp;&amp; (ptr-&gt;c[0] == back || key &lt; ptr-&gt;c[0]-&gt;val)){&#10;                ptr-&gt;c[0] = new_node;&#10;            }&#10;            if(!(ptr-&gt;exist &amp; 2) &amp;&amp; (ptr-&gt;c[1] == front || ptr-&gt;c[1]-&gt;val &lt; key)){&#10;                ptr-&gt;c[1] = new_node;&#10;            }&#10;            ptr = ptr-&gt;c[(key &gt;&gt; i) &amp; 1];&#10;        }&#10;    }&#10;&#10;    void erase(T key){&#10;        Node* ptr = root;&#10;        Node* cut_ptr = nullptr;&#10;        bool cut_fl = false;&#10;        stack&lt;Node*&gt; node_stack;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            if(!((ptr-&gt;exist &gt;&gt; fl) &amp; 1))&#10;                return;&#10;            if((ptr-&gt;exist &gt;&gt; (!fl)) &amp; 1){&#10;                while(!node_stack.empty())node_stack.pop();&#10;                cut_ptr = ptr;&#10;                cut_fl = fl;&#10;            }&#10;            else if(i != W - 1)&#10;                node_stack.push(ptr);&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        Node* target = ptr;&#10;        Node* pre = target-&gt;c[0];&#10;        Node* nex = target-&gt;c[1];&#10;        if(nex == nullptr || target-&gt;val != key)&#10;            return;&#10;        pre-&gt;c[1] = nex;&#10;        nex-&gt;c[0] = pre;&#10;        int h = 0;&#10;        for(int i = 0; !node_stack.empty(); ++i){&#10;            Node* node = node_stack.top();&#10;            hashmap[i + 1].erase(node-&gt;val);&#10;            node_stack.pop();&#10;            assert(node != target);&#10;        }&#10;        hashmap[0].erase(key);&#10;        if(!cut_ptr){&#10;            *this = XFastTrie();&#10;            return;&#10;        }&#10;        cut_ptr-&gt;c[cut_fl] = cut_fl ? pre : nex;&#10;        cut_ptr-&gt;exist &amp;= ~(1 &lt;&lt; cut_fl);&#10;        ptr = root;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            if(ptr-&gt;c[0] == target){&#10;                ptr-&gt;c[0] = nex;&#10;            }&#10;            if(ptr-&gt;c[1] == target){&#10;                ptr-&gt;c[1] = pre;&#10;            }&#10;            if(!(ptr-&gt;exist &amp; (1 &lt;&lt; fl)))&#10;                break;&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        --n;&#10;        delete(target);&#10;    }&#10;&#10;    Node* lower_bound(T key){&#10;        Node* ptr = root;&#10;        int lb = W, rb = -1;&#10;        int mid;&#10;        bool fl;&#10;        Node* res;&#10;        while(lb - rb &gt; 1){&#10;            mid = (lb + rb) &gt;&gt; 1;&#10;            tie(res, fl) = hashmap[mid].find(key &amp; ~((1LL &lt;&lt; mid) - 1));&#10;            if(fl)&#10;                ptr = res;&#10;            (fl ? lb : rb) = mid;&#10;        }&#10;        if(lb){&#10;            if((key &gt;&gt; rb) &amp; 1)&#10;                ptr = ptr-&gt;c[1]-&gt;c[1];&#10;            else&#10;                ptr = ptr-&gt;c[0];&#10;        }&#10;        return ptr;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="xfasttrie_yft" value="// y-fast trie用のx-fast trie&#10;template &lt;typename T, int W = 31, T HASHMAP_NULL = (1LL &lt;&lt; W) - 1, T HASHMAP_DEL = (1LL &lt;&lt; W) - 2&gt;&#10;struct XFastTrie_yft{&#10;    using SplayNode = typename SplayTree&lt;T&gt;::NodePtr;&#10;    struct Node{&#10;        T val;&#10;        int exist;&#10;        Node* c[2];&#10;        SplayNode node;&#10;        Node(T val) : val(val), exist(0), node(nullptr){&#10;            // 子が存在するなら子へのポインタを持つ&#10;            // 葉なら左右はそれぞれprev,next&#10;            // 左の子が存在しないなら左はprevへのショートカット&#10;            // 右のが存在しないなら右はnextへのショートカット&#10;            c[0] = nullptr;&#10;            c[1] = nullptr;&#10;        }&#10;    };&#10;    int n;&#10;    Node* root;&#10;    Node* front;&#10;    Node* back;&#10;    array&lt;HashMap&lt;T, Node*, HASHMAP_NULL, HASHMAP_DEL&gt;, W&gt; hashmap;&#10;&#10;    XFastTrie_yft() : n(0), hashmap(){&#10;        root = new Node(0);&#10;        front = new Node(0);&#10;        back = new Node(0);&#10;        front-&gt;exist = 2;&#10;        front-&gt;c[1] = back;&#10;        back-&gt;exist = 1;&#10;        back-&gt;c[0] = front;&#10;        root-&gt;c[0] = back;&#10;        root-&gt;c[1] = front;&#10;    }&#10;&#10;    Node* insert(SplayNode node){&#10;        T key = node-&gt;val;&#10;        // 存在しているノードは全部葉があると仮定する&#10;        T val = 0;&#10;        Node* ptr = root;&#10;        Node* nex = nullptr;&#10;        Node* pre = nullptr;&#10;        bool make_flag = false;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            bool exist = (ptr-&gt;exist &gt;&gt; fl) &amp; 1;&#10;            if(fl)&#10;                val += (1LL &lt;&lt; i);&#10;            if(!exist){&#10;                if(!nex){&#10;                    if(fl){&#10;                        pre = ptr-&gt;c[1];&#10;                        nex = pre-&gt;c[1];&#10;                    }&#10;                    else{&#10;                        nex = ptr-&gt;c[0];&#10;                        pre = nex-&gt;c[0];&#10;                    }&#10;                }&#10;                make_flag = true;&#10;                ptr-&gt;exist |= (1 &lt;&lt; fl);&#10;                ptr-&gt;c[fl] = new Node(val);&#10;                hashmap[i].add(val, ptr-&gt;c[fl]);&#10;                ptr-&gt;c[fl]-&gt;c[0] = back;&#10;                ptr-&gt;c[fl]-&gt;c[1] = front;&#10;            }&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        if(!make_flag)&#10;            return nullptr;&#10;        ++n;&#10;        assert(nex == back || key &lt; nex-&gt;val);&#10;        assert(pre == front || pre-&gt;val &lt; key);&#10;&#10;        ptr-&gt;node = node;&#10;        pre-&gt;c[1] = ptr;&#10;        ptr-&gt;c[1] = nex;&#10;        nex-&gt;c[0] = ptr;&#10;        ptr-&gt;c[0] = pre;&#10;        assert(val == key &amp;&amp; ptr-&gt;val == key);&#10;&#10;        Node* new_node = ptr;&#10;        ptr = root;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            if(!(ptr-&gt;exist &amp; 1) &amp;&amp; (ptr-&gt;c[0] == back || key &lt; ptr-&gt;c[0]-&gt;val)){&#10;                ptr-&gt;c[0] = new_node;&#10;            }&#10;            if(!(ptr-&gt;exist &amp; 2) &amp;&amp; (ptr-&gt;c[1] == front || ptr-&gt;c[1]-&gt;val &lt; key)){&#10;                ptr-&gt;c[1] = new_node;&#10;            }&#10;            ptr = ptr-&gt;c[(key &gt;&gt; i) &amp; 1];&#10;        }&#10;        return new_node;&#10;    }&#10;&#10;    bool erase(T key){&#10;        Node* ptr = root;&#10;        Node* cut_ptr = nullptr;&#10;        bool cut_fl = false;&#10;        stack&lt;Node*&gt; node_stack;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            if(!((ptr-&gt;exist &gt;&gt; fl) &amp; 1))&#10;                return false;&#10;            if((ptr-&gt;exist &gt;&gt; (!fl)) &amp; 1){&#10;                while(!node_stack.empty())node_stack.pop();&#10;                cut_ptr = ptr;&#10;                cut_fl = fl;&#10;            }&#10;            else if(i != W - 1)&#10;                node_stack.push(ptr);&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        Node* target = ptr;&#10;        Node* pre = target-&gt;c[0];&#10;        Node* nex = target-&gt;c[1];&#10;        pre-&gt;c[1] = nex;&#10;        nex-&gt;c[0] = pre;&#10;        int h = 0;&#10;        for(int i = 0; !node_stack.empty(); ++i){&#10;            Node* node = node_stack.top();&#10;            hashmap[i + 1].erase(node-&gt;val);&#10;            node_stack.pop();&#10;            assert(node != target);&#10;        }&#10;        hashmap[0].erase(key);&#10;        if(!cut_ptr){&#10;            *this = XFastTrie_yft();&#10;            return true;&#10;        }&#10;        cut_ptr-&gt;c[cut_fl] = cut_fl ? pre : nex;&#10;        cut_ptr-&gt;exist &amp;= ~(1 &lt;&lt; cut_fl);&#10;        ptr = root;&#10;        if(target-&gt;val != key)&#10;            return false;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            if(ptr-&gt;c[0] == target){&#10;                ptr-&gt;c[0] = nex;&#10;            }&#10;            if(ptr-&gt;c[1] == target){&#10;                ptr-&gt;c[1] = pre;&#10;            }&#10;            if(!(ptr-&gt;exist &amp; (1 &lt;&lt; fl)))&#10;                break;&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        --n;&#10;        delete(target);&#10;        return true;&#10;    }&#10;&#10;    Node* lower_bound(T key){&#10;        Node* ptr = root;&#10;        int lb = W, rb = -1;&#10;        while(lb - rb &gt; 1){&#10;            int mid = (lb + rb) &gt;&gt; 1;&#10;            bool fl;&#10;            Node* res;&#10;            tie(res, fl) = hashmap[mid].find(key &amp; ~((1LL &lt;&lt; mid) - 1));&#10;            if(fl)&#10;                ptr = res;&#10;            (fl ? lb : rb) = mid;&#10;        }&#10;        if(!lb)return ptr;&#10;        int fl = (key &gt;&gt; rb) &amp; 1;&#10;        return fl ? ptr-&gt;c[fl]-&gt;c[1] : ptr-&gt;c[fl];&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="yfasttrie" value="// 乱択で挿入先を決めるy-fast trie&#10;template &lt;typename T, int W = 31, T HASHMAP_NULL = (1LL &lt;&lt; W) - 1, T HASHMAP_DEL = (1LL &lt;&lt; W) - 2&gt;&#10;struct YFastTrie{&#10;&#10;    static uint32_t rnd(){&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = 0; // time(0);&#10;        uint32_t t = x ^ (x &lt;&lt; 11);&#10;        x = y, y = z, z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return w;&#10;    }&#10;&#10;    using SplayNode = typename SplayTree&lt;T&gt;::NodePtr;&#10;    int n;&#10;    XFastTrie_yft&lt;T, W, HASHMAP_NULL, HASHMAP_DEL&gt; xft;&#10;    SplayTree&lt;T&gt; splay;&#10;&#10;    YFastTrie() : n(1), xft(), splay(){&#10;        SplayNode node = splay.make((1LL &lt;&lt; W) - 1);&#10;        xft.insert(node);&#10;    }&#10;&#10;    SplayNode lower_bound(T key){&#10;        auto xft_ptr = xft.lower_bound(key);&#10;        assert(xft_ptr != xft.back);&#10;        return xft_ptr-&gt;node = splay.lower_bound(xft_ptr-&gt;node, key).first;&#10;    }&#10;&#10;    bool insert(T key){&#10;        auto xft_ptr = xft.lower_bound(key);&#10;         pair&lt;SplayNode , bool&gt; res;&#10;        if(xft_ptr-&gt;val == key)&#10;            return false;&#10;        if(rnd() % W == 0){&#10;            res = splay.lower_bound(xft_ptr-&gt;node, key);&#10;            assert(res.second);&#10;            SplayNode l;&#10;            tie(l, xft_ptr-&gt;node) = splay.split(res.first);&#10;            assert(xft_ptr-&gt;node != splay.nil);&#10;            res = splay.insert(l, key);&#10;            n += res.second;&#10;            assert(res.first != splay.nil);&#10;            xft.insert(splay.access(res.first, res.first-&gt;size - 1));&#10;        }&#10;        else{&#10;            res = splay.insert(xft_ptr-&gt;node, key);&#10;            n += res.second;&#10;            xft_ptr-&gt;node = res.first;&#10;        }&#10;        return res.second;&#10;    }&#10;&#10;    bool erase(T key){&#10;        pair&lt;SplayNode, bool&gt; res;&#10;        auto xft_ptr = xft.lower_bound(key);&#10;        if(xft_ptr-&gt;val == key){&#10;            auto r = xft_ptr-&gt;c[1];&#10;            r-&gt;node = splay.merge(xft_ptr-&gt;node, r-&gt;node);&#10;            res = splay.erase(r-&gt;node, key);&#10;            r-&gt;node = res.first;&#10;            if(res.second){&#10;                xft_ptr-&gt;node = nullptr;&#10;                xft.erase(xft_ptr-&gt;val);&#10;            }&#10;        }&#10;        else{&#10;            res = splay.erase(xft_ptr-&gt;node, key);&#10;            xft_ptr-&gt;node = res.first;&#10;        }&#10;        n -= res.second;&#10;        return res.second;&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="yfasttrie2" value="// サイズを保つようにsplit/mergeをするy-fast trie&#10;template &lt;typename T, int W = 31, T HASHMAP_NULL = (1LL &lt;&lt; W) - 1, T HASHMAP_DEL = (1LL &lt;&lt; W) - 2&gt;&#10;struct YFastTrie2{&#10;&#10;    using SplayNode = typename SplayTree&lt;T&gt;::NodePtr;&#10;    int n;&#10;    XFastTrie_yft&lt;T, W, HASHMAP_NULL, HASHMAP_DEL&gt; xft;&#10;    SplayTree&lt;T&gt; splay;&#10;&#10;    YFastTrie2() : n(1), xft(), splay(){&#10;        SplayNode node = splay.make((1LL &lt;&lt; W) - 1);&#10;        xft.insert(node);&#10;    }&#10;&#10;    SplayNode lower_bound(T key){&#10;        auto xft_ptr = xft.lower_bound(key);&#10;        assert(xft_ptr != xft.back);&#10;        auto res = splay.lower_bound(xft_ptr-&gt;node, key);&#10;        xft_ptr-&gt;node = res.first;&#10;        if(!res.second){&#10;            xft_ptr = xft_ptr-&gt;c[1];&#10;            xft_ptr-&gt;node = splay.access(xft_ptr-&gt;node, 0);&#10;        }&#10;        return xft_ptr-&gt;node;&#10;    }&#10;&#10;    bool insert(T key){&#10;        auto xft_ptr = xft.lower_bound(key);&#10;        auto res = splay.insert(xft_ptr-&gt;node, key);&#10;        xft_ptr-&gt;node = res.first;&#10;        n += res.second;&#10;        split(xft_ptr);&#10;        return res.second;&#10;    }&#10;&#10;    bool erase(T key){&#10;        auto xft_ptr = xft.lower_bound(key);&#10;        auto res = splay.erase(xft_ptr-&gt;node, key);&#10;        assert(res.first != splay.nil);&#10;        xft_ptr-&gt;node = res.first;&#10;        n -= res.second;&#10;        merge(xft_ptr);&#10;        return res.second;&#10;    }&#10;&#10;    void split(typename XFastTrie_yft&lt;T, W&gt;::Node* xft_node){&#10;        if(xft_node-&gt;node-&gt;size &lt;= (W &lt;&lt; 1))&#10;            return;&#10;        SplayNode l, r;&#10;        tie(l, r) = splay.split(splay.access(xft_node-&gt;node, xft_node-&gt;node-&gt;size &gt;&gt; 1));&#10;        xft_node-&gt;node = r;&#10;        l = splay.access(l, l-&gt;size - 1);&#10;        xft.insert(l);&#10;    }&#10;&#10;    void merge(typename XFastTrie_yft&lt;T, W&gt;::Node* xft_ptr){&#10;        if(xft_ptr-&gt;node-&gt;size &gt;= (W &gt;&gt; 2))&#10;            return;&#10;        if(xft_ptr-&gt;c[0] != xft.front)&#10;            merge(xft_ptr-&gt;c[0], xft_ptr);&#10;        else if(xft_ptr-&gt;c[1] != xft.back)&#10;            merge(xft_ptr, xft_ptr-&gt;c[1]);&#10;    }&#10;&#10;    void merge(typename XFastTrie_yft&lt;T, W&gt;::Node* xft_l, typename XFastTrie_yft&lt;T, W&gt;::Node* xft_r){&#10;        xft_r-&gt;node = splay.merge(xft_l-&gt;node, xft_r-&gt;node);&#10;        xft_l-&gt;node = nullptr;&#10;        xft.erase(xft_l-&gt;val);&#10;        split(xft_r);&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="geometry" value="namespace geometry{&#10;    using D = long double;&#10;    constexpr D eps =1e-9;&#10;&#10;    struct Point;&#10;    bool near_eq(Point, Point);&#10;    D norm(Point);&#10;&#10;    struct Point{&#10;        D x, y;&#10;        Point(D x = 0.0, D y = 0.0) : x(x), y(y){}&#10;        friend bool operator&lt;(const Point&amp; a, const Point&amp; b){&#10;            return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#10;        }&#10;        Point&amp; operator+=(Point a){x += a.x, y += a.y; return *this;}&#10;        Point&amp; operator-=(Point a){x -= a.x, y -= a.y; return *this;}&#10;        Point&amp; operator*=(D p){x *= p, y *= p; return *this;}&#10;        Point&amp; operator*=(Point b){return *this = *this * b;}&#10;        Point&amp; operator/=(D p){x /= p, y /= p; return *this;}&#10;        Point&amp; operator/=(Point b){return *this = *this / b;}&#10;        friend Point operator+(Point a, Point b){return Point(a) += b;}&#10;        friend Point operator-(Point a, Point b){return Point(a) -= b;}&#10;        friend Point operator*(Point a, D p){return Point(a) *= p;}&#10;        friend Point operator*(Point a, Point b){return Point(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);}&#10;        friend Point operator/(Point a, D b){return Point(a) /= b;}&#10;        friend Point operator/(Point a, Point b){return Point(a.x * b.x + a.y * b.y, b.x * a.y - a.x * b.y) / norm(b);}&#10;    };&#10;    using P = Point;&#10;&#10;    struct Circle : public Point{&#10;        D r;&#10;        Circle(Point p = Point(), D r = 1) : Point(p), r(r){}&#10;        Circle(D x = 0.0, D y = 0.0, D r = 1) : Point(x, y), r(r){}&#10;    };&#10;    using C = Circle;&#10;&#10;    bool near_eq(D a, D b = 0.0){return abs(a - b) &lt; eps;}&#10;    bool near_eq(P a, P b = Point()){return near_eq(a.x, b.x) &amp;&amp; near_eq(a.y, b.y);}&#10;    D diag(P a){&#10;        assert(!near_eq(a));&#10;        return atan2(a.y, a.x);&#10;    }&#10;    D norm(P a){return a.x * a.x + a.y * a.y;}&#10;    D abs(P a){return sqrt(norm(a));}&#10;    D dist(P a, P b){return abs(a - b);}&#10;    D dot(P a, P b){return a.x * b.x + a.y * b.y;}&#10;    D cross(P a, P b){return a.x * b.y - a.y * b.x;}&#10;    int ccw(P a, P b, P c){&#10;        b -= a;&#10;        c -= a;&#10;        if(cross(b, c) &gt; eps)return 1;&#10;        if(cross(b, c) &lt; -eps)return -1;&#10;        if(dot(b, c) &lt; -eps)return 2;&#10;        if(norm(b) &lt; norm(c))return -2;&#10;        return 0;&#10;    }&#10;    bool is_on_line(P a1, P a2, P b){return abs(ccw(a1, a2, b)) != -1;}&#10;    bool is_on_segment(P a1, P a2, P b){return !ccw(a1, a2, b);}&#10;    P proj(P a1, P a2, P b){return a1 + dot(a2 - a1, b - a1) / norm(a2 - a1) * (a2 - a1);} // 直線への射影点&#10;    D dist(P a1, P a2, P b){return dist(proj(a1, a2, b), b);}&#10;    bool intersect(P a1, P a2, P b1, P b2){&#10;        return ccw(a1, a2, b1) * ccw(a1, a2, b2) &lt;= 0 &amp;&amp;&#10;               ccw(b1, b2, a1) * ccw(b1, b2, a2) &lt;= 0;&#10;    }&#10;    P cross_point(P a1, P a2, P b1, P b2){&#10;        D d1 = cross(b2 - b1, b1 - a1);&#10;        D d2 = cross(b2 - b1, a2 - a1);&#10;        if(near_eq(d1) &amp;&amp; near_eq(d2))return a1;&#10;        assert(!near_eq(d2));&#10;        return a1 + d1 / d2 * (a2 - a1);&#10;    }&#10;    vector&lt;Point&gt; cross_point(C c1, C c2){&#10;        vector&lt;Point&gt; cross;&#10;        P diff = c2 - c1;&#10;        D d = abs(diff);&#10;        D crl = (norm(diff) + c1.r * c1.r - c2.r * c2.r) / (2 * d);&#10;        if(near_eq(d) || c1.r &lt; abs(crl))&#10;            return cross;&#10;        P abn = diff * P(0, sqrt(c1.r * c1.r - crl * crl) / d);&#10;        P cp = c1 + crl / d * diff;&#10;        cross.push_back(cp + abn);&#10;        if(!near_eq(abn))&#10;            cross.push_back(cp - abn);&#10;        return cross;&#10;    }&#10;    vector&lt;pair&lt;P, P&gt;&gt; tangent_lines(C c1, C c2){ // 共通接線、接線の両端は円との接点&#10;        vector&lt;pair&lt;P, P&gt;&gt; lines;&#10;        D d = dist(c1, c2);&#10;        for(int i = 0; i &lt; 2; ++i){&#10;            D sin =(c1.r - (1 - i * 2) * c2.r) / d;&#10;            if(!(sin * sin &lt; 1 + eps))&#10;                break;&#10;            D cos = sqrt(max(1 - sin * sin, D(0)));&#10;            for(int j = 0; j &lt; 2; ++j){&#10;                P n = (c2 - c1) * P(sin, (1 - j * 2) * cos) / d;&#10;                lines.emplace_back(c1 + c1.r * n, c2 + (1 - i * 2)  * c2.r * n);&#10;                if(cos &lt; eps)&#10;                    break;&#10;            }&#10;        }&#10;        return lines;&#10;    }&#10;}&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
</templateSet>