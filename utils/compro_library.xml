<templateSet group="compro_library">
  <template name="calc_fact" value="// doc: https://shibh308.github.io/library/library/lib/functions/calc_fact.cpp.html&#10;auto calc_fact = [mpow]{&#10;	constexpr int N = 2e6;&#10;	vector&lt;mint&gt; fact(N + 1, 1);&#10;	vector&lt;mint&gt; inv(N + 1, 1);&#10;	for(int i = 1; i &lt; N; ++i){&#10;		fact[i + 1] = fact[i] * (i + 1);&#10;		inv[i + 1] = mpow(fact[i + 1], MOD - 2);&#10;	}&#10;	return make_pair(fact, inv);&#10;};&#10;vector&lt;mint&gt; fact, inv;&#10;tie(fact, inv) = calc_fact();&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="divisor" value="// doc: https://shibh308.github.io/library/library/lib/functions/divisor.cpp.html&#10;auto divisor = [](i64 x){&#10;	int sq = sqrt(x) + 1;&#10;	vector&lt;int&gt; ret;&#10;	for(i64 i = 1; i &lt; sq; ++i)&#10;		if(!(x % i)){&#10;			ret.emplace_back(i);&#10;			if(i * i != x)&#10;				ret.emplace_back(x / i);&#10;		}&#10;	sort(ret.begin(), ret.end());&#10;	return ret;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="eratisthenes" value="// doc: https://shibh308.github.io/library/library/lib/functions/eratisthenes.cpp.html&#10;auto eratosthenes = []{&#10;	constexpr int N = 2e6;&#10;	bitset&lt;N&gt; not_prime(3);&#10;	for(int i = 2; i &lt; N; ++i)&#10;		if(!not_prime[i])&#10;			for(int j = 2 * i; j &lt; N; j += i)&#10;				not_prime.set(j);&#10;	return not_prime;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="factoring" value="// doc: https://shibh308.github.io/library/library/lib/functions/factoring.cpp.html&#10;auto factoring = [](i64 x){&#10;	int sq = sqrt(x) + 1;&#10;	vector&lt;int&gt; ret;&#10;	if(x == 1){&#10;		ret.emplace_back(1);&#10;		return ret;&#10;	}&#10;	for(i64 i = 2; i &lt; sq; ++i)&#10;		while(x % i == 0){&#10;			ret.emplace_back(i);&#10;			x /= i;&#10;		}&#10;	if(x != 1)&#10;		ret.emplace_back(x);&#10;	return ret;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="gcd" value="// doc: https://shibh308.github.io/library/library/lib/functions/gcd.cpp.html&#10;auto gcd = [](i64 x, i64 y){&#10;	while(y){&#10;		i64 z = x % y;&#10;		x = y;&#10;		y = z;&#10;	}&#10;	return x;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lcm" value="// doc: https://shibh308.github.io/library/library/lib/functions/lcm.cpp.html&#10;auto lcm = [gcd](i64 x, i64 y){&#10;	return x * y / gcd(x, y);&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="mo_query" value="// doc: https://shibh308.github.io/library/library/lib/functions/mo_query.cpp.html&#10;template &lt;typename ResultType&gt;&#10;vector&lt;ResultType&gt; mo_query(Mo&amp; mo, vector&lt;pair&lt;int,int&gt;&gt;&amp; queries, function&lt;ResultType(int)&gt; get_func, int packet=512){&#10;    int q = queries.size();&#10;    vector&lt;tuple&lt;int,int,int&gt;&gt; sort_queries;&#10;    for(int i = 0; i &lt; q; ++i)&#10;        sort_queries.emplace_back(queries[i].first / packet, queries[i].second, i);&#10;    sort(sort_queries.begin(), sort_queries.end());&#10;    vector&lt;ResultType&gt; ans(q);&#10;    for(auto&amp; query : sort_queries){&#10;        int idx = get&lt;2&gt;(query);&#10;        mo.move(queries[idx].first, queries[idx].second);&#10;        ans[idx] = get_func(idx);&#10;    }&#10;    return ans;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="modpow" value="// doc: https://shibh308.github.io/library/library/lib/functions/modpow.cpp.html&#10;auto mpow = [](auto x, i64 y){&#10;	auto z = x;&#10;	decltype(x) val = y &amp; 1 ? x : decltype(x)(1);&#10;	while(z *= z, y &gt;&gt;= 1)&#10;		if(y &amp; 1)&#10;			val *= z;&#10;	return val;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="ncr" value="// doc: https://shibh308.github.io/library/library/lib/functions/ncr.cpp.html&#10;auto ncr = [&amp;fact, &amp;inv](int n, int r){&#10;	if(n &lt; 0 || r &lt; 0 || n &lt; r)&#10;		return mint(0);&#10;	return fact[n] * inv[r] * inv[n - r];&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="nhr" value="// doc: https://shibh308.github.io/library/library/lib/functions/nhr.cpp.html&#10;auto nhr = [ncr](int n, int r){&#10;	return ncr(n + r - 1, r);&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rerooting" value="// doc: https://shibh308.github.io/library/library/lib/functions/rerooting.cpp.html&#10;template &lt;typename T&gt;&#10;// T f(T, T): 子の累積に使うもの 直径ならf(x, y): max(x, y)&#10;// T g(T, int): 子の累積を元に適用する際に使うもの 直径ならg(x, idx): x + 1&#10;vector&lt;T&gt; rerooting(vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;T&gt; v, function&lt;T(T, T)&gt; f, function&lt;T(T, int)&gt; g, T op){&#10;    int n = edges.size();&#10;    vector&lt;int&gt; visit(n, 0);&#10;    vector&lt;T&gt; dp1(v), dp2(n);&#10;    vector&lt;vector&lt;int&gt;&gt; childs(n);&#10;    vector&lt;vector&lt;T&gt;&gt; child_val(n), child_l(n), child_r(n);&#10;    function&lt;void(int)&gt; f1 = [&amp;](int x){&#10;        visit[x] = true;&#10;        T res = op;&#10;        for(auto y : edges[x]){&#10;            if(visit[y])&#10;                continue;&#10;            f1(y);&#10;            childs[x].push_back(y);&#10;            child_val[x].push_back(dp1[y]);&#10;            res = f(res, dp1[y]);&#10;        }&#10;        dp1[x] = g(res, x);&#10;        child_l[x].push_back(op);&#10;        child_r[x].push_back(op);&#10;        for(int i = 0; i &lt; childs[x].size(); ++i){&#10;            child_l[x].push_back(f(child_l[x].back(), child_val[x][i]));&#10;            child_r[x].push_back(f(child_r[x].back(), child_val[x][childs[x].size() - i - 1]));&#10;        }&#10;    };&#10;    f1(0);&#10;    function&lt;void(int, T)&gt; f2 = [&amp;](int x, T par_val){&#10;        T res = par_val;&#10;        for(int i = 0; i &lt; childs[x].size(); ++i){&#10;            int y = childs[x][i];&#10;            auto p = f(par_val, f(child_l[x][i], child_r[x][childs[x].size() - i - 1]));&#10;            T val = g(f(par_val, f(child_l[x][i], child_r[x][childs[x].size() - i - 1])), y);&#10;            res = f(res, dp1[y]);&#10;            f2(y, val);&#10;        }&#10;        dp2[x] = g(res, x);&#10;    };&#10;    f2(0, op);&#10;    return dp2;&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="run" value="// doc: https://shibh308.github.io/library/library/lib/functions/run.cpp.html&#10;struct RunInfo{&#10;    // (t, l, r) の形で返す tは最小周期で0-indexed半開区間&#10;    set&lt;tuple&lt;int,int,int&gt;&gt; run;&#10;    // 最大のLyndon wordを持つ [2][n]で1側が反転&#10;    vector&lt;vector&lt;int&gt;&gt; l;&#10;    // Lyndon Factorization (開始位置列挙)&#10;    vector&lt;int&gt; lyndon_fac;&#10;};&#10;&#10;RunInfo getRunInfo(string s){&#10;    vector&lt;StringUtils&gt; su;&#10;    int n = s.size();&#10;    s += &quot;$&quot; + string(s.rbegin(), s.rend());&#10;    vector&lt;int&gt; v(s.begin(), s.end());&#10;    su.emplace_back(v);&#10;    for(int i = 0; i &lt; s.size(); ++i)&#10;        v[i] *= -1;&#10;    su.emplace_back(v);&#10;    vector&lt;vector&lt;int&gt;&gt; l(2, vector&lt;int&gt;(n, 0));&#10;    for(int fl = 0; fl &lt; 2; ++fl){&#10;        stack&lt;pair&lt;int,int&gt;&gt; st;&#10;        for(int i = n - 1; i &gt;= 0; --i){&#10;            int j = i + 1;&#10;            while(!st.empty()){&#10;                int x, y;&#10;                tie(x, y) = st.top();&#10;                if(!su[fl].le(i, j, x, y))&#10;                    break;&#10;                j = y;&#10;                st.pop();&#10;            }&#10;            l[fl][i] = j;&#10;            st.emplace(i, j);&#10;        }&#10;    }&#10;    set&lt;tuple&lt;int,int,int&gt;&gt; run;&#10;    for(int fl = 0; fl &lt; 2; ++fl){&#10;        for(int i = 0; i &lt; n; ++i){&#10;            int j = l[fl][i];&#10;            int t = j - i;&#10;            int l_lcp = su[fl].get_lcp(s.size() - j, s.size() - i);&#10;            int r_lcp = su[fl].get_lcp(i, j);&#10;            int ii = i - l_lcp;&#10;            int jj = j + r_lcp;&#10;            if(jj - ii &gt;= 2 * t)&#10;                run.emplace(t, ii, jj);&#10;        }&#10;    }&#10;    vector&lt;int&gt; dec;&#10;    for(int i = 0; i &lt; n; i = l[0][i])&#10;        dec.emplace_back(i);&#10;    return RunInfo{run, l, dec};&#10;}&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="scc" value="// doc: https://shibh308.github.io/library/library/lib/functions/scc.cpp.html&#10;vector&lt;int&gt; scc(vector&lt;vector&lt;int&gt;&gt;&amp; edges){&#10;    int n = edges.size();&#10;    vector&lt;vector&lt;int&gt;&gt; rev(n);&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        for(auto&amp; x : edges[i])&#10;            rev[x].emplace_back(i);&#10;&#10;    vector&lt;i64&gt; dfs_num(n, -1);&#10;    vector&lt;i64&gt; flag(n, 0);&#10;    int num = 0;&#10;    function&lt;void(int)&gt; dfs = [&amp;](int pos){&#10;        flag[pos] = 1;&#10;        for(auto&amp; xx : edges[pos])&#10;            if(!flag[xx]){&#10;                dfs(xx);&#10;        }&#10;        dfs_num[pos] = num++;&#10;    };&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        if(!flag[i])&#10;            dfs(i);&#10;&#10;    vector&lt;int&gt; dfs_inv(n);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        dfs_inv[n - 1 - dfs_num[i]] = i;&#10;&#10;    num = 0;&#10;&#10;    vector&lt;int&gt; scc_vec(n, -1);&#10;&#10;    function&lt;void(int)&gt; rdfs = [&amp;](int pos){&#10;        scc_vec[pos] = num;&#10;        for(auto t : rev[pos])&#10;            if(scc_vec[t] == -1)&#10;                rdfs(t);&#10;    };&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        if(scc_vec[dfs_inv[i]] == -1){&#10;            rdfs(dfs_inv[i]);&#10;            ++num;&#10;        }&#10;&#10;    return scc_vec;&#10;}&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="scc_dag" value="// doc: https://shibh308.github.io/library/library/lib/functions/scc_dag.cpp.html&#10;struct Result{&#10;    int dag_size;&#10;    vector&lt;vector&lt;int&gt;&gt; dag_graph;&#10;    // 元のグラフでi番目の頂点が何番目の強連結成分に含まれるか&#10;    vector&lt;int&gt; elements;&#10;    // i番目の強連結成分に含まれる頂点のリスト&#10;    vector&lt;vector&lt;int&gt;&gt; tps_list;&#10;    // トポソしてi番目にくる頂点のindex&#10;    vector&lt;int&gt; tps_order;&#10;    // DAGのi番目の頂点をトポソした時の番号&#10;    vector&lt;int&gt; tps_index;&#10;};&#10;&#10;Result scc_dag(vector&lt;vector&lt;int&gt;&gt;&amp; edges){&#10;    int n = edges.size();&#10;    vector&lt;int&gt; scc_vec = scc(edges);&#10;    int m = *max_element(scc_vec.begin(), scc_vec.end()) + 1;&#10;    vector&lt;vector&lt;int&gt;&gt; dag_graph(m);&#10;&#10;    queue&lt;int&gt; tps_que;&#10;    vector&lt;int&gt; in_count(m, 0);&#10;    vector&lt;int&gt; tps(m, -1);&#10;    vector&lt;int&gt; tps_idx(m);&#10;    for(int i = 0; i &lt; n; ++i){&#10;        for(auto j : edges[i]){&#10;            if(scc_vec[i] == scc_vec[j])&#10;                continue;&#10;            dag_graph[scc_vec[i]].push_back(scc_vec[j]);&#10;            ++in_count[scc_vec[j]];&#10;        }&#10;    }&#10;    for(int i = 0; i &lt; m; ++i)&#10;        if(in_count[i] == 0)&#10;            tps_que.push(i);&#10;    int cnt = 0;&#10;    while(!tps_que.empty()){&#10;        int x = tps_que.front();&#10;        tps_idx[x] = cnt;&#10;        tps[cnt++] = x;&#10;        tps_que.pop();&#10;        for(auto y : dag_graph[x])&#10;            if(--in_count[y] == 0)&#10;                tps_que.push(y);&#10;    }&#10;    assert(cnt == m);&#10;&#10;    vector&lt;vector&lt;int&gt;&gt; tps_list(m);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        tps_list[scc_vec[i]].push_back(i);&#10;&#10;    Result res;&#10;    res.dag_size = m;&#10;    res.elements = move(scc_vec);&#10;    res.tps_index = move(tps_idx);&#10;    res.tps_order = move(tps);&#10;    res.tps_list = move(tps_list);&#10;    res.dag_graph = move(dag_graph);&#10;    return res;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="simple_graph" value="// doc: https://shibh308.github.io/library/library/lib/functions/simple_graph.cpp.html&#10;template &lt;typename T = pair&lt;int,int&gt;&gt;&#10;vector&lt;vector&lt;int&gt;&gt; simple_graph(vector&lt;vector&lt;T&gt;&gt;&amp; edges, function&lt;int(T)&gt; f = [](auto x){return x.first;}){&#10;    vector&lt;vector&lt;int&gt;&gt; simple_edges(edges.size());&#10;    for(int i = 0; i &lt; edges.size(); ++i)&#10;        for(auto&amp; x : edges[i])&#10;            simple_edges[i].push_back(f(x));&#10;    return simple_edges;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="twoedgeconnectedcomponents_tree" value="// doc: https://shibh308.github.io/library/library/lib/functions/twoedgeconnectedcomponents_tree.cpp.html&#10;struct Result{&#10;    int group_cnt;&#10;    vector&lt;int&gt; group;&#10;    vector&lt;vector&lt;int&gt;&gt; group_elm_list;&#10;    // 同じ二重辺連結成分の辺をグループごとに列挙する, 片方向のみ(辺数倍化しない)&#10;    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; same_group_edges;&#10;    // 橋, 片方向のみ&#10;    vector&lt;pair&lt;int,int&gt;&gt; bridges;&#10;    // 関節点&#10;    vector&lt;int&gt; arts;&#10;    vector&lt;vector&lt;int&gt;&gt; tree_graph;&#10;    vector&lt;int&gt; par;&#10;    vector&lt;vector&lt;int&gt;&gt; childs;&#10;};&#10;&#10;Result two_edge_connected_components_tree(vector&lt;vector&lt;int&gt;&gt;&amp; edges){&#10;    int n = edges.size();&#10;    LowLink ll(edges);&#10;    vector&lt;vector&lt;int&gt;&gt; not_bridge_graph(n);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        for(auto j : edges[i]){&#10;            pair&lt;int,int&gt; min_max = minmax(i, j);&#10;            auto iter = lower_bound(ll.bridge.begin(), ll.bridge.end(), min_max);&#10;            if(iter == ll.bridge.end() || *iter != min_max)&#10;                not_bridge_graph[i].push_back(j);&#10;        }&#10;&#10;    vector&lt;int&gt; group(n, -1);&#10;    function&lt;void(int)&gt; group_dfs = [&amp;](int x){&#10;        for(auto y : not_bridge_graph[x])&#10;            if(group[y] == -1){&#10;                group[y] = group[x];&#10;                group_dfs(y);&#10;            }&#10;    };&#10;    int group_cnt = 0;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        if(group[i] == -1){&#10;            group[i] = group_cnt++;&#10;            group_dfs(i);&#10;        }&#10;    vector&lt;vector&lt;int&gt;&gt; group_elm_list(group_cnt);&#10;    for(int i = 0; i &lt; n; ++i)&#10;        group_elm_list[group[i]].push_back(i);&#10;&#10;    vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; same_group_edges(group_cnt);&#10;    vector&lt;vector&lt;int&gt;&gt; tree_edges(group_cnt);&#10;    vector&lt;int&gt; par(group_cnt, -1);&#10;    vector&lt;vector&lt;int&gt;&gt; childs(group_cnt);&#10;&#10;    for(int i = 0; i &lt; n; ++i)&#10;        for(auto j : edges[i])&#10;            if(group[i] == group[j] &amp;&amp; i &lt; j)&#10;                same_group_edges[group[i]].emplace_back(i, j);&#10;&#10;    for(auto&amp; p : ll.bridge){&#10;        tree_edges[group[p.first]].push_back(group[p.second]);&#10;        tree_edges[group[p.second]].push_back(group[p.first]);&#10;    }&#10;    vector&lt;bool&gt; flag(n, false);&#10;    function&lt;void(int)&gt; tree_dfs = [&amp;](int x){&#10;        for(auto y : tree_edges[x])&#10;            if(!flag[y]){&#10;                flag[y] = true;&#10;                par[y] = x;&#10;                childs[x].push_back(y);&#10;                tree_dfs(y);&#10;            }&#10;    };&#10;    flag[0] = true;&#10;    tree_dfs(0);&#10;&#10;    Result res;&#10;    res.group_cnt = group_cnt;&#10;    res.group_elm_list = move(group_elm_list);&#10;    res.same_group_edges = move(same_group_edges);&#10;    res.bridges = move(ll.bridge);&#10;    res.arts = move(ll.art);&#10;    res.group = move(group);&#10;    res.tree_graph = move(tree_edges);&#10;    res.par = move(par);&#10;    res.childs = move(childs);&#10;    return res;&#10;}&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="avl" value="// doc: https://shibh308.github.io/library/library/lib/classes/avl.cpp.html&#10;template &lt;typename T&gt;&#10;struct AVL{&#10;    template &lt;typename U&gt;&#10;    struct Node{&#10;        int size, height;&#10;        U val, sum;&#10;        Node(U val, Node&lt;U&gt;* nil) : val(val), sum(val), size(1), height(1){c[0] = nil; c[1] = nil;}&#10;        Node&lt;U&gt;* c[2];&#10;    };&#10;&#10;    using NodePtr = Node&lt;T&gt;*;&#10;    function&lt;T(T, T)&gt; f = [](auto x, auto y){return x + y;};&#10;    T op;&#10;    NodePtr nil;&#10;&#10;    AVL(function&lt;T(T, T)&gt; f, T op) : f(f), op(op){&#10;        nil = new Node&lt;T&gt;(op, nullptr);&#10;        nil-&gt;size = 0;&#10;        nil-&gt;height = 0;&#10;        nil-&gt;c[0] = nil;&#10;        nil-&gt;c[1] = nil;&#10;    }&#10;&#10;    template &lt;bool inv&gt;&#10;    int balance_factor(NodePtr x){return (x-&gt;c[0]-&gt;height - x-&gt;c[1]-&gt;height) * (inv ? -1 : 1);}&#10;    void _update(NodePtr x){&#10;        if(x == nil)&#10;            return;&#10;        x-&gt;size = x-&gt;c[0]-&gt;size + x-&gt;c[1]-&gt;size + 1;&#10;        x-&gt;height = max(x-&gt;c[0]-&gt;height, x-&gt;c[1]-&gt;height) + 1;&#10;        x-&gt;sum = f(f(x-&gt;c[0]-&gt;sum, x-&gt;val), x-&gt;c[1]-&gt;sum);&#10;    }&#10;    template &lt;bool is_right&gt;&#10;    NodePtr rotate(NodePtr x){&#10;        NodePtr new_root = x-&gt;c[1 ^ is_right];&#10;        x-&gt;c[1 ^ is_right] = new_root-&gt;c[0 ^ is_right];&#10;        new_root-&gt;c[0 ^ is_right] = x;&#10;        _update(x);&#10;        _update(new_root);&#10;        return new_root;&#10;    }&#10;    template &lt;bool inv&gt;&#10;    NodePtr _balance(NodePtr x){&#10;        if(balance_factor&lt;inv&gt;(x) == 2){&#10;            if(balance_factor&lt;inv&gt;(x-&gt;c[0 ^ inv]) &lt; 0)&#10;                x-&gt;c[0 ^ inv] = rotate&lt;inv&gt;(x-&gt;c[0 ^ inv]);&#10;            x = rotate&lt;1 ^ inv&gt;(x);&#10;        }&#10;        return x;&#10;    }&#10;    NodePtr balance(NodePtr x){&#10;        x = _balance&lt;false&gt;(x);&#10;        x = _balance&lt;true&gt;(x);&#10;        _update(x);&#10;        return x;&#10;    }&#10;    NodePtr insert(NodePtr x, int idx, T val){&#10;        if(x == nil)&#10;            return new Node&lt;T&gt;(val, nil);&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt;= left_size)&#10;            x-&gt;c[0] = insert(x-&gt;c[0], idx, val);&#10;        else&#10;            x-&gt;c[1] = insert(x-&gt;c[1], idx - left_size - 1, val);&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;&#10;    // 子が片方しかない時にノードを削除する&#10;    NodePtr _erase_top(NodePtr x, bool del){&#10;        for(int i = 0; i &lt; 2; ++i){&#10;            if(x-&gt;c[i] == nil){&#10;                NodePtr new_node = x-&gt;c[i ^ 1];&#10;                if(del)&#10;                    delete(x);&#10;                return new_node;&#10;            }&#10;        }&#10;    }&#10;    // 最小の要素をdstにコピーしてから削除する&#10;    NodePtr _copy_erase(NodePtr x, NodePtr dst, bool del){&#10;        if(x-&gt;c[0] == nil){&#10;            dst-&gt;val = x-&gt;val;&#10;            return _erase_top(x, del);&#10;        }&#10;        x-&gt;c[0] = _copy_erase(x-&gt;c[0], dst, del);&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;    NodePtr erase(NodePtr x, int idx, bool del = true){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            x-&gt;c[0] = erase(x-&gt;c[0], idx, del);&#10;        else if(left_size &lt; idx)&#10;            x-&gt;c[1] = erase(x-&gt;c[1], idx - left_size - 1, del);&#10;        else{&#10;            if(x-&gt;c[0] == nil || x-&gt;c[1] == nil)&#10;                return _erase_top(x, del);&#10;            x-&gt;c[1] = _copy_erase(x-&gt;c[1], x, del);&#10;        }&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;    NodePtr getNode(NodePtr x, int idx){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            return getNode(x-&gt;c[0], idx);&#10;        else if(left_size &lt; idx)&#10;            return getNode(x-&gt;c[1], idx - left_size - 1);&#10;        else&#10;            return x;&#10;    }&#10;    T get(NodePtr x, int l, int r){&#10;        if(l &lt;= 0 &amp;&amp; x-&gt;size &lt;= r)&#10;            return x-&gt;sum;&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        T res = op;&#10;        if(l &lt;= left_size &amp;&amp; left_size &lt; r)&#10;            res = x-&gt;val;&#10;        if(l &lt; left_size)&#10;            res = f(get(x-&gt;c[0], l, r), res);&#10;        if(left_size + 1 &lt; r)&#10;            res = f(res, get(x-&gt;c[1], l - left_size - 1, r - left_size - 1));&#10;        return res;&#10;    }&#10;    NodePtr update(NodePtr x, int idx, T val, function&lt;T(T, T)&gt; g = [](auto x, auto y){return x + y;}){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            x-&gt;c[0] = update(x-&gt;c[0], idx, val, g);&#10;        else if(left_size &lt; idx)&#10;            x-&gt;c[1] = update(x-&gt;c[1], idx - left_size - 1, val, g);&#10;        else&#10;            x-&gt;val = g(x-&gt;val, val);&#10;        _update(x);&#10;&#10;        return x;&#10;    }&#10;    NodePtr set(NodePtr x, int idx, T val){&#10;        int left_size = x-&gt;c[0]-&gt;size;&#10;        if(idx &lt; left_size)&#10;            x-&gt;c[0] = set(x-&gt;c[0], idx, val);&#10;        else if(left_size &lt; idx)&#10;            x-&gt;c[1] = set(x-&gt;c[1], idx - left_size - 1, val);&#10;        else&#10;            x-&gt;val = val;&#10;        _update(x);&#10;        return x;&#10;    }&#10;&#10;    void print(NodePtr x, int p = 0){&#10;        if(x == nil)return;&#10;        if(p == 0)&#10;            cout &lt;&lt; &quot;----print----&quot; &lt;&lt; endl;&#10;        print(x-&gt;c[0], p + 12);&#10;        for(int i = 0; i &lt; p; ++i)&#10;            cout &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;val:&quot; &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;sum:&quot; &lt;&lt; x-&gt;sum &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;size:&quot; &lt;&lt; x-&gt;size &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;height:&quot; &lt;&lt; x-&gt;height &lt;&lt; endl;&#10;        print(x-&gt;c[1], p + 12);&#10;        if(p == 0)&#10;            cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="avl_map" value="// doc: https://shibh308.github.io/library/library/lib/classes/avl_map.cpp.html&#10;template &lt;typename T, typename U&gt;&#10;struct AVL_map{&#10;    struct Node{&#10;        int height;&#10;        T key;&#10;        U val;&#10;        Node(T key, U val) : key(key), val(val), height(1){c[0] = 0; c[1] = 0;}&#10;        int c[2];&#10;    };&#10;    vector&lt;Node&gt; nodes;&#10;    stack&lt;int&gt; st;&#10;    AVL_map(){&#10;        nodes.emplace_back(T(), U());&#10;        nodes[0].height = 0;&#10;    }&#10;    template &lt;bool inv&gt;&#10;    int balance_factor(int x){return (nodes[nodes[x].c[0]].height - nodes[nodes[x].c[1]].height) * (inv ? -1 : 1);}&#10;    void _update(int x){&#10;        if(x == 0)&#10;            return;&#10;        nodes[x].height = max(nodes[nodes[x].c[0]].height, nodes[nodes[x].c[1]].height) + 1;&#10;    }&#10;    template &lt;bool is_right&gt;&#10;    int rotate(int x){&#10;        int y = nodes[x].c[1 ^ is_right];&#10;        nodes[x].c[1 ^ is_right] = nodes[y].c[0 ^ is_right];&#10;        nodes[y].c[0 ^ is_right] = x;&#10;        _update(x);&#10;        _update(y);&#10;        return y;&#10;    }&#10;    template &lt;bool inv&gt;&#10;    int _balance(int x){&#10;        if(balance_factor&lt;inv&gt;(x) == 2){&#10;            if(balance_factor&lt;inv&gt;(nodes[x].c[0 ^ inv]) &lt; 0)&#10;                nodes[x].c[0 ^ inv] = rotate&lt;inv&gt;(nodes[x].c[0 ^ inv]);&#10;            x = rotate&lt;1 ^ inv&gt;(x);&#10;        }&#10;        return x;&#10;    }&#10;    int balance(int x){&#10;        x = _balance&lt;false&gt;(x);&#10;        x = _balance&lt;true&gt;(x);&#10;        _update(x);&#10;        return x;&#10;    }&#10;    int add(int x, T key, U val){&#10;        if(x == 0){&#10;            if(st.empty()){&#10;                nodes.emplace_back(key, val);&#10;                return nodes.size() - 1;&#10;            }&#10;            else{&#10;                int y = st.top();&#10;                st.pop();&#10;                nodes[y] = Node(key, val);&#10;                return y;&#10;            }&#10;        }&#10;        else if(key == nodes[x].key)&#10;            nodes[x].val = val;&#10;        else if(key &lt; nodes[x].key)&#10;            nodes[x].c[0] = add(nodes[x].c[0], key, val);&#10;        else&#10;            nodes[x].c[1] = add(nodes[x].c[1], key, val);&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;    // 子が片方しかない時にノードを削除する&#10;    int _erase_top(int x, bool del){&#10;        for(int i = 0; i &lt; 2; ++i){&#10;            if(nodes[x].c[i] == 0){&#10;                int y = nodes[x].c[i ^ 1];&#10;                if(del)&#10;                    st.push(x);&#10;                return y;&#10;            }&#10;        }&#10;        return 0;&#10;    }&#10;    // 最小の要素をdstにコピーしてから削除する&#10;    int _copy_erase(int x, int dst, bool del){&#10;        if(nodes[x].c[0] == 0){&#10;            nodes[dst].val = nodes[x].val;&#10;            return _erase_top(x, del);&#10;        }&#10;        nodes[x].c[0] = _copy_erase(nodes[x].c[0], dst, del);&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;    int erase(int x, T key, bool del = true){&#10;        if(key &lt; nodes[x].key)&#10;            nodes[x].c[0] = erase(nodes[x].c[0], key, del);&#10;        else if(nodes[x].key &lt; key)&#10;            nodes[x].c[1] = erase(nodes[x].c[1], key, del);&#10;        else{&#10;            if(nodes[x].c[0] == 0 || nodes[x].c[1] == 0)&#10;                return _erase_top(x, del);&#10;            nodes[x].c[1] = _copy_erase(nodes[x].c[1], x, del);&#10;        }&#10;        x = balance(x);&#10;        return x;&#10;    }&#10;    pair&lt;U, bool&gt; get(int x, T key){&#10;        if(x == 0)&#10;            return {U(), false};&#10;        else if(key == nodes[x].key)&#10;            return {nodes[x].val, true};&#10;        else if(key &lt; nodes[x].key)&#10;            return get(nodes[x].c[0], key);&#10;        else&#10;            return get(nodes[x].c[1], key);&#10;    }&#10;    vector&lt;pair&lt;T, U&gt;&gt; list(int x){&#10;        vector&lt;pair&lt;T, U&gt;&gt; v;&#10;        stack&lt;pair&lt;int,bool&gt;&gt; sta;&#10;        sta.emplace(x, false);&#10;        bool add;&#10;        while(!sta.empty()){&#10;            tie(x, add) = sta.top();&#10;            sta.pop();&#10;            if(x == 0)&#10;                continue;&#10;            if(add)&#10;                v.emplace_back(nodes[x].key, nodes[x].val);&#10;            else{&#10;                if(nodes[x].c[1])&#10;                    sta.emplace(nodes[x].c[1], false);&#10;                sta.emplace(x, true);&#10;                if(nodes[x].c[0])&#10;                    sta.emplace(nodes[x].c[0], false);&#10;            }&#10;        }&#10;        return v;&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="binaryindexedtree" value="// doc: https://shibh308.github.io/library/library/lib/classes/binaryindexedtree.cpp.html&#10;template &lt;typename T&gt;&#10;struct BIT{&#10;    vector&lt;T&gt; elm;&#10;    BIT(int n, T init = T()) : elm(n + 1, init){&#10;    }&#10;&#10;    // [0, x)&#10;    T sum(int x){&#10;        T val = 0;&#10;        for(; x &gt; 0; x -= x &amp; -x)&#10;            val += elm[x];&#10;        return val;&#10;    }&#10;&#10;    // [l, r)&#10;    T sum(int l, int r){&#10;        return sum(r) - sum(l);&#10;    }&#10;&#10;    void add(int x, T val){&#10;        for(++x; x &lt; elm.size(); x += x &amp; -x)&#10;            elm[x] += val;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="binarylifting" value="// doc: https://shibh308.github.io/library/library/lib/classes/binarylifting.cpp.html&#10;struct BinaryLifting{&#10;    int n;&#10;    vector&lt;vector&lt;int&gt;&gt; next;&#10;    vector&lt;int&gt; par;&#10;    vector&lt;vector&lt;int&gt;&gt; childs;&#10;    vector&lt;int&gt; depth;&#10;&#10;    BinaryLifting(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int root = 0) : n(edges.size()), depth(n, -1), par(n, -1), childs(n){&#10;        function&lt;void(int)&gt; dfs = [&amp;](int x){&#10;            for(auto y : edges[x])&#10;                if(depth[y] == -1){&#10;                    depth[y] = depth[x] + 1;&#10;                    par[y] = x;&#10;                    childs[x].push_back(y);&#10;                    dfs(y);&#10;                }&#10;        };&#10;        depth[root] = 0;&#10;        dfs(root);&#10;&#10;        next.push_back(par);&#10;        for(int k = 0;; ++k){&#10;            bool fl = false;&#10;            next.emplace_back(n, -1);&#10;            for(int i = 0; i &lt; n; ++i){&#10;                next[k + 1][i] = (next[k][i] == -1 ? -1 : next[k][next[k][i]]);&#10;                if(next[k + 1][i] != -1)&#10;                    fl = true;&#10;            }&#10;            if(!fl)&#10;                break;&#10;        }&#10;    }&#10;    // kth_next(x, 0) =&gt; x&#10;    int kth_next(int x, int k){&#10;        for(int i = 0; i &lt; next.size() &amp;&amp; k; ++i){&#10;            if(k &amp; (1 &lt;&lt; i)){&#10;                x = next[i][x];&#10;                if(x == -1)&#10;                    break;&#10;            }&#10;        }&#10;        return x;&#10;    }&#10;&#10;    int lca(int x, int y){&#10;        int min_depth = min(depth[x], depth[y]);&#10;        x = kth_next(x, depth[x] - min_depth);&#10;        y = kth_next(y, depth[y] - min_depth);&#10;        if(x == y)&#10;            return x;&#10;        for(int i = next.size() - 1; i &gt;= 0; --i)&#10;            if(next[i][x] != next[i][y]){&#10;                x = next[i][x];&#10;                y = next[i][y];&#10;            }&#10;        return next[0][x];&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="bitvector" value="// doc: https://shibh308.github.io/library/library/lib/classes/bitvector.cpp.html&#10;struct BitVector{&#10;    vector&lt;uint64_t&gt; v;&#10;    vector&lt;int&gt; r;&#10;    BitVector(){}&#10;    void build(){&#10;        r.assign(v.size() + 1, 0);&#10;        for(int i = 0; i &lt; v.size(); ++i)&#10;            r[i + 1] = r[i] + __builtin_popcountll(v[i]);&#10;    }&#10;    bool access(int x){&#10;        return (v[x &gt;&gt; 6] &gt;&gt; (x &amp; 63)) &amp; 1;&#10;    }&#10;    // [0, x)の1の出現回数&#10;    int rank(int x){&#10;        return r[x &gt;&gt; 6] + __builtin_popcountll(v[x &gt;&gt; 6] &amp; ((1uLL &lt;&lt; (x &amp; 63)) - 1));&#10;    }&#10;    int rank(int x, bool fl){&#10;        return fl ? rank(x) : x - rank(x);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="compression" value="// doc: https://shibh308.github.io/library/library/lib/classes/compression.cpp.html&#10;template&lt;typename T&gt;&#10;struct Compression{&#10;    vector&lt;T&gt; compvec;&#10;    Compression(vector&lt;T&gt;&amp; inp){//圧縮する&#10;        compvec = inp;&#10;        sort(compvec.begin(), compvec.end());&#10;        compvec.erase(unique(compvec.begin(), compvec.end()), compvec.end());&#10;    }&#10;    int Index(T val){//圧縮を元に対応するインデックスを返す&#10;        auto it = lower_bound(compvec.begin(), compvec.end(), val);&#10;        return distance(compvec.begin(), it);&#10;    }&#10;    vector&lt;T&gt;&amp; operator*(){&#10;        return compvec;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="convexhulltrick" value="// doc: https://shibh308.github.io/library/library/lib/classes/convexhulltrick.cpp.html&#10;template &lt;typename T, typename U&gt;&#10;struct ConvexHullTrick{&#10;    // 任意の2関数で共有点が高々1個ならElmの中身を適切に変えれば通る&#10;&#10;    struct Elm{&#10;        T a, b;&#10;        U operator()(T x){&#10;            return a * x + b;&#10;        }&#10;    };&#10;&#10;    struct Node{&#10;        Elm f;&#10;        Node* l;&#10;        Node* r;&#10;        Node(Elm elm) : f(elm), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    U _min, _max, _inf;&#10;    Node* root;&#10;&#10;    ConvexHullTrick(U _min, U _max, U _inf) :&#10;        _min(_min),&#10;        _max(_max),&#10;        _inf(_inf),&#10;        root(nullptr)&#10;    {&#10;    }&#10;&#10;    Node* _insert(Node* p, T st, T en, Elm f){&#10;        if(!p)&#10;            return new Node(f);&#10;        if(p-&gt;f(st) &lt;= f(st) &amp;&amp; p-&gt;f(en) &lt;= f(en))&#10;            return p;&#10;        if(p-&gt;f(st) &gt;= f(st) &amp;&amp; p-&gt;f(en) &gt;= f(en)){&#10;            p-&gt;f = f;&#10;            return p;&#10;        }&#10;        T mid = (st + en) / 2;&#10;        if(p-&gt;f(mid) &gt; f(mid))&#10;            swap(p-&gt;f, f);&#10;        if(p-&gt;f(st) &gt;= f(st))&#10;            p-&gt;l = _insert(p-&gt;l, st, mid, f);&#10;        else&#10;            p-&gt;r = _insert(p-&gt;r, mid, en, f);&#10;        return p;&#10;    }&#10;&#10;    U _query(Node* p, T st, T en, T x){&#10;        if(!p)&#10;            return _inf;&#10;        if(st == en)&#10;            return p-&gt;f(x);&#10;        T mid = (st + en) / 2;&#10;        if(x &lt;= mid)&#10;            return min(p-&gt;f(x), _query(p-&gt;l, st, mid, x));&#10;        else&#10;            return min(p-&gt;f(x), _query(p-&gt;r, mid, en, x));&#10;    }&#10;&#10;    void insert(Elm f){&#10;        root = _insert(root, _min, _max, f);&#10;    }&#10;&#10;    U query(T x){&#10;        return _query(root, _min, _max, x);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dinic" value="// doc: https://shibh308.github.io/library/library/lib/classes/dinic.cpp.html&#10;template &lt;typename T&gt;&#10;struct Dinic{&#10;    struct Edge{&#10;        int to, rev;&#10;        T cap;&#10;        Edge(int to, T cap, int rev) : to(to), rev(rev), cap(cap){}&#10;    };&#10;&#10;    vector&lt;vector&lt;Edge&gt;&gt; edges;&#10;    T _inf;&#10;    vector&lt;T&gt; min_cost;&#10;    vector&lt;int&gt; cnt;&#10;&#10;    Dinic(int n) : edges(n), _inf(numeric_limits&lt;T&gt;::max()){}&#10;&#10;    void add(int from, int to, T cap){&#10;        edges[from].emplace_back(to, cap, static_cast&lt;int&gt;(edges[to].size()));&#10;        edges[to].emplace_back(from, 0, static_cast&lt;int&gt;(edges[from].size()) - 1);&#10;    }&#10;&#10;    bool bfs(int s, int t){&#10;        min_cost.assign(edges.size(), -1);&#10;        queue&lt;int&gt; que;&#10;        min_cost[s] = 0;&#10;        que.emplace(s);&#10;        while(!que.empty() &amp;&amp; min_cost[t] == -1){&#10;            int x = que.front();&#10;            que.pop();&#10;            for(auto&amp; ed : edges[x])&#10;                if(ed.cap &gt; 0 &amp;&amp; min_cost[ed.to] == -1){&#10;                    min_cost[ed.to] = min_cost[x] + 1;&#10;                    que.emplace(ed.to);&#10;                }&#10;        }&#10;        return min_cost[t] != -1;&#10;    }&#10;&#10;    T dfs(int idx, int t, T flow){&#10;        if(idx == t)&#10;            return flow;&#10;        T ret = 0;&#10;        while(cnt[idx] &lt; edges[idx].size()){&#10;            auto&amp; ed = edges[idx][cnt[idx]];&#10;            if(ed.cap &gt; 0 &amp;&amp; min_cost[idx] &lt; min_cost[ed.to]){&#10;                T d = dfs(ed.to, t, min(flow, ed.cap));&#10;                ed.cap -= d;&#10;                edges[ed.to][ed.rev].cap += d;&#10;                ret += d;&#10;                flow -= d;&#10;                if(flow == 0)&#10;                    break;&#10;            }&#10;            ++cnt[idx];&#10;        }&#10;        return ret;&#10;    }&#10;&#10;    T solve(int s, int t){&#10;        T flow = 0;&#10;        while(bfs(s, t)){&#10;            cnt.assign(edges.size(), 0);&#10;            T f = 0;&#10;            while((f = dfs(s, t, _inf)) &gt; 0)&#10;                flow += f;&#10;        }&#10;        return flow;&#10;    }&#10;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="disjointsparsetable" value="// doc: https://shibh308.github.io/library/library/lib/classes/disjointsparsetable.cpp.html&#10;template &lt;typename T&gt;&#10;struct DisjointSparseTable{&#10;    function&lt;T(T, T)&gt; f;&#10;    vector&lt;vector&lt;T&gt;&gt; v;&#10;&#10;    DisjointSparseTable(vector&lt;T&gt;&amp; inp, function&lt;T(T, T)&gt; f) : f(f){&#10;        int n = inp.size();&#10;        int b;&#10;        for(b = 0; (1 &lt;&lt; b) &lt;= inp.size(); ++b);&#10;        v.assign(b, vector&lt;T&gt;(n));&#10;        for(int i = 0; i &lt; n; ++i)&#10;            v[0][i] = inp[i];&#10;        for(int i = 1; i &lt; b; ++i){&#10;            int siz = 1 &lt;&lt; i;&#10;            for(int j = 0; j &lt; n; j += siz &lt;&lt; 1){&#10;                int t = min(j + siz, n);&#10;                v[i][t - 1] = inp[t - 1];&#10;                for(int k = t - 2; k &gt;= j; --k)&#10;                    v[i][k] = f(inp[k], v[i][k + 1]);&#10;                if(t &gt;= n)&#10;                    break;&#10;                v[i][t] = inp[t];&#10;                int r = min(t + siz, n);&#10;                for(int k = t + 1; k &lt; r; ++k)&#10;                    v[i][k] = f(v[i][k - 1], inp[k]);&#10;            }&#10;        }&#10;    }&#10;&#10;    T get(int l, int r){&#10;        if(l &gt;= --r)&#10;            return v[0][l];&#10;        int p = 31 - __builtin_clz(l ^ r);&#10;        return f(v[p][l], v[p][r]);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dualsegtree" value="// doc: https://shibh308.github.io/library/library/lib/classes/dualsegtree.cpp.html&#10;template&lt;typename T&gt;&#10;struct Segtree{&#10;    int n;&#10;    T op;&#10;    vector&lt;T&gt; elm;&#10;    function&lt;T(T, T)&gt; f;&#10;&#10;    Segtree(int n, T init, function&lt;T(T, T)&gt; f, T op = T()) :&#10;        n(n),&#10;        op(op),&#10;        elm(2 * n, op),&#10;        f(f)&#10;    {&#10;        for(int i = 0; i &lt; n; ++i)&#10;            elm[i + n] = init;&#10;    }&#10;&#10;    Segtree(int n, vector&lt;T&gt; init, function&lt;T(T, T)&gt; f, T op = T()) :&#10;        n(n),&#10;        op(op),&#10;        elm(2 * n, op),&#10;        f(f)&#10;    {&#10;        for(int i = 0; i &lt; n; ++i)&#10;            elm[i + n] = init[i];&#10;    }&#10;&#10;    void update(int x, int y, T val){&#10;        for(x += n, y += n - 1; x &lt;= y; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            if(x &amp; 1){&#10;                elm[x] = f(elm[x], val);&#10;                x++;&#10;            }&#10;            if(!(y &amp; 1)){&#10;                elm[y] = f(elm[y], val);&#10;                y--;&#10;            }&#10;        }&#10;    }&#10;&#10;    void update(int x, T val){&#10;        x += n;&#10;        elm[x + n] = f(elm[x + n], val);&#10;    }&#10;&#10;    T get(int x){&#10;        x += n;&#10;        T val = elm[x];&#10;        while(x &gt;&gt;= 1)&#10;            val = f(val, elm[x]);&#10;        return val;&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dynamicbitvector" value="// doc: https://shibh308.github.io/library/library/lib/classes/dynamicbitvector.cpp.html&#10;struct DynamicBitVector{&#10;    struct Node;&#10;    using Index = MemoryPool&lt;Node&gt;::Index;&#10;    MemoryPool&lt;Node&gt; pool;&#10;    struct Node{&#10;        int siz, cnt, height;&#10;        short len;&#10;        uint64_t val;&#10;        MemoryPool&lt;Node&gt;::Index l, r;&#10;        Node(){}&#10;        Node(int siz, int cnt, int height, short len, uint64_t val, MemoryPool&lt;Node&gt;::Index nil) :&#10;                siz(siz), cnt(cnt), height(height), len(len), val(val), l(nil), r(nil){}&#10;    };&#10;    Index root, nil;&#10;&#10;    int rank_val;&#10;    bool erase_fl;&#10;&#10;    DynamicBitVector(){&#10;        nil = pool.alloc();&#10;        auto&amp; p = get(nil);&#10;        p.cnt = p.val = p.siz = p.height = p.len = 0;&#10;        p.l = p.r = nil;&#10;    }&#10;&#10;    Index build(int n, vector&lt;uint64_t&gt;&amp; a, int l, int r){&#10;        assert(n &gt;= 0);&#10;        int mid = (l + r) / 2;&#10;        Index l_idx = l == mid ? nil : build(n, a, l, mid);&#10;        Index r_idx = mid + 1 == r ? nil : build(n, a, mid + 1, r);&#10;        Index idx = pool.alloc();&#10;        pool[idx] = Node(0, 0, 0, mid + 1 == a.size() ? n - (a.size() - 1) * 32 : 32, a[mid], nil);&#10;        pool[idx].l = l_idx;&#10;        pool[idx].r = r_idx;&#10;        update(idx);&#10;&#10;        return idx;&#10;    }&#10;&#10;    void update(Index pi){&#10;        if(pi == nil)&#10;            return;&#10;        auto&amp; p = get(pi);&#10;        auto&amp; l = get(p.l);&#10;        auto&amp; r = get(p.r);&#10;        p.siz = l.siz + r.siz + p.len;&#10;        p.height = max(l.height, r.height) + 1;&#10;        p.cnt = l.cnt + r.cnt + __builtin_popcountll(p.val);&#10;    }&#10;&#10;    int balance_factor(Index pi){return get(get(pi).l).height - get(get(pi).r).height;}&#10;&#10;    Index rotl(Index pi){&#10;        assert(pi != nil);&#10;        auto&amp; p = get(pi);&#10;        Index qi = p.r;&#10;        assert(qi != nil);&#10;        auto&amp; q = get(qi);&#10;        p.r = q.l;&#10;        q.l = pi;&#10;        update(pi);&#10;        update(qi);&#10;        return qi;&#10;    }&#10;&#10;    Index rotr(Index pi){&#10;        assert(pi != nil);&#10;        auto&amp; p = get(pi);&#10;        Index qi = p.l;&#10;        assert(qi != nil);&#10;        auto&amp; q = get(qi);&#10;        p.l = q.r;&#10;        q.r = pi;&#10;        update(pi);&#10;        update(qi);&#10;        return qi;&#10;    }&#10;&#10;    Index balance(Index pi){&#10;        if(balance_factor(pi) == 2){&#10;            auto&amp; p = get(pi);&#10;            if(balance_factor(p.l) &lt; 0)&#10;                p.l = rotl(p.l);&#10;            return rotr(pi);&#10;        }&#10;        if(balance_factor(pi) == -2){&#10;            auto&amp; p = get(pi);&#10;            if(balance_factor(p.r) &gt; 0)&#10;                p.r = rotr(p.r);&#10;            return rotl(pi);&#10;        }&#10;        update(pi);&#10;        return pi;&#10;    }&#10;&#10;    Index _insert(Index pi, Index new_idx){&#10;        if(pi == nil)&#10;            return new_idx;&#10;        auto&amp; p = get(pi);&#10;        p.l = _insert(p.l, new_idx);&#10;        return balance(pi);&#10;    }&#10;&#10;    Index insert(Index pi, int k, bool fl){&#10;        if(pi == nil){&#10;            Index idx = pool.alloc();&#10;            pool[idx] = Node(1, fl, 1, 1, fl, nil);&#10;            return idx;&#10;        }&#10;        auto&amp; p = get(pi);&#10;        auto&amp; l = get(p.l);&#10;        auto&amp; r = get(p.r);&#10;        if(k &lt;= l.siz &amp;&amp; p.l != nil){&#10;            p.l = insert(p.l, k, fl);&#10;        }&#10;        else if(k &lt;= l.siz + p.len){&#10;            k -= l.siz;&#10;            rank_val += get(p.l).cnt + __builtin_popcountll(p.val &amp; ((1uLL &lt;&lt; k) - 1));&#10;            p.val = (p.val &amp; ((1uLL &lt;&lt; k) - 1)) | ((p.val &amp; ~((1uLL &lt;&lt; k) - 1)) &lt;&lt; 1) | (uint64_t(fl) &lt;&lt; k);&#10;            if(++p.len == 64){&#10;                uint64_t vl = p.val &amp; ((1uLL &lt;&lt; 32) - 1);&#10;                uint64_t vr = p.val &gt;&gt; 32;&#10;                p.val = vl;&#10;                p.len = 32;&#10;                Index r_idx = pool.alloc();&#10;                pool[r_idx] = Node(32, __builtin_popcountll(vr), 1, 32, vr, nil);&#10;                p.r = _insert(p.r, r_idx);&#10;            }&#10;        }&#10;        else{&#10;            rank_val += get(p.l).cnt + __builtin_popcountll(p.val);&#10;            p.r = insert(p.r, k - p.len - l.siz, fl);&#10;        }&#10;        return balance(pi);&#10;    }&#10;&#10;    Index _erase_left(Index pi, Index root_idx){&#10;        auto&amp; p = get(pi);&#10;        if(p.l == nil){&#10;            if(!merge(root_idx, pi, true)){&#10;                Index qi = p.r;&#10;                pool.free(pi);&#10;                return qi;&#10;            }&#10;        }&#10;        else&#10;            p.l = _erase_left(p.l, root_idx);&#10;        return balance(pi);&#10;    }&#10;&#10;    Index _erase_right(Index pi, Index root_idx){&#10;        auto&amp; p = get(pi);&#10;        if(p.r == nil){&#10;            if(!merge(root_idx, pi, false)){&#10;                Index qi = p.l;&#10;                pool.free(pi);&#10;                return qi;&#10;            }&#10;        }&#10;        else{&#10;            p.r = _erase_right(p.r, root_idx);&#10;        }&#10;        return balance(pi);&#10;    }&#10;&#10;    // aiとbiをマージして, もし1つにできるならaiを残す&#10;    bool merge(Index ai, Index bi, bool a_left){&#10;        auto&amp; a = get(ai);&#10;        auto&amp; b = get(bi);&#10;        if(!a_left){&#10;            swap(a.val, b.val);&#10;            swap(a.len, b.len);&#10;        }&#10;        short len_sum = a.len + b.len;&#10;        if(len_sum &lt;= 64){&#10;            a.val = a.val | (b.val &lt;&lt; a.len);&#10;            a.len = len_sum;&#10;            update(ai);&#10;            return false;&#10;        }&#10;        else{&#10;            uint32_t mid = (a.len + b.len) &gt;&gt; 1;&#10;            uint64_t av, bv;&#10;            if(a.len &gt;= mid){&#10;                av = a.val &amp; ((1uLL &lt;&lt; mid) - 1);&#10;                bv = (a.val &gt;&gt; mid) | (b.val &lt;&lt; (a.len - mid));&#10;            }&#10;            else{&#10;                av = (a.val | (b.val &lt;&lt; a.len)) &amp; ((1uLL &lt;&lt; mid) - 1);&#10;                bv = b.val &gt;&gt; (mid - a.len);&#10;            }&#10;&#10;            a.val = av;&#10;            b.val = bv;&#10;            a.len = mid;&#10;            b.len = len_sum - mid;&#10;            if(!a_left){&#10;                swap(a.val, b.val);&#10;                swap(a.len, b.len);&#10;            }&#10;            return true;&#10;        }&#10;    }&#10;&#10;    Index erase(Index pi, int k, Index par = {-1}){&#10;        if(par.idx == -1)&#10;            par = nil;&#10;        if(pi == nil)&#10;            return nil;&#10;        auto&amp; p = get(pi);&#10;        auto&amp; l = get(p.l);&#10;        auto&amp; r = get(p.r);&#10;        if(k &lt; l.siz)&#10;            p.l = erase(p.l, k);&#10;        else if(k &lt; l.siz + p.len){&#10;            k -= l.siz;&#10;            --p.len;&#10;            rank_val += get(p.l).cnt + __builtin_popcountll(p.val &amp; ((1uLL &lt;&lt; k) - 1));&#10;            erase_fl = (p.val &gt;&gt; k) &amp; 1;&#10;            p.val = (p.val &amp; ((1uLL &lt;&lt; k) - 1)) | ((p.val &amp; ~((1uLL &lt;&lt; (k + 1)) - 1)) &gt;&gt; 1);&#10;&#10;            if(p.len &lt;= 16){&#10;                if(p.l != nil){&#10;                    p.l = _erase_right(p.l, pi);&#10;                }&#10;                else if(p.r != nil){&#10;                    p.r = _erase_left(p.r, pi);&#10;                }&#10;                else{&#10;                    if(par == nil){&#10;                        if(p.len == 0){&#10;                            pool.free(pi);&#10;                            return nil;&#10;                        }&#10;                        update(pi);&#10;                        return pi;&#10;                    }&#10;                    else{&#10;                        auto&amp; parent = get(par);&#10;                        if(parent.l == pi){&#10;                            if(!merge(par, pi, false)){&#10;                                pool.free(pi);&#10;                                return nil;&#10;                            }&#10;                        }&#10;                        else{&#10;                            assert(parent.r == pi);&#10;                            if(!merge(par, pi, true)){&#10;                                pool.free(pi);&#10;                                return nil;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        else{&#10;            rank_val += get(p.l).cnt + __builtin_popcountll(p.val);&#10;            p.r = erase(p.r, k - p.len - l.siz);&#10;        }&#10;        return balance(pi);&#10;    }&#10;&#10;    int rank(Index pi, int k){&#10;        if(pi == nil)&#10;            return 0;&#10;        auto&amp; p = get(pi);&#10;        auto&amp; l = get(p.l);&#10;        if(k &lt; l.siz)&#10;            return rank(p.l, k);&#10;        else if(k &lt; l.siz + p.len)&#10;            return l.cnt + __builtin_popcountll(p.val &amp; ((1uLL &lt;&lt; (k - l.siz)) - 1));&#10;        else&#10;            return l.cnt + __builtin_popcountll(p.val) + rank(p.r, k - l.siz - p.len);&#10;    }&#10;&#10;    bool access(Index pi, int k){&#10;        assert(pi != nil);&#10;        auto&amp; p = get(pi);&#10;        assert(0 &lt;= k &amp;&amp; k &lt; p.siz);&#10;        auto&amp; l = get(p.l);&#10;        assert(p.siz == p.len + l.siz + get(p.r).siz);&#10;        if(k &lt; l.siz)&#10;            return access(p.l, k);&#10;        else if(k &lt; l.siz + p.len)&#10;            return (p.val &gt;&gt; (k - l.siz)) &amp; 1;&#10;        else&#10;            return access(p.r, k - l.siz - p.len);&#10;    }&#10;&#10;    Node&amp; get(Index k){return pool[k];}&#10;    Node&amp; operator[](Index k){return pool[k];}&#10;&#10;    void build(int n, vector&lt;uint64_t&gt;&amp; a){&#10;        root = build(n, a, 0, a.size());&#10;        assert(get(root).siz == n);&#10;    }&#10;&#10;    void insert(int k, bool fl){&#10;        rank_val = 0;&#10;        root = insert(root, k, fl);&#10;    }&#10;&#10;    void erase(int k){&#10;        rank_val = 0;&#10;        root = erase(root, k);&#10;    }&#10;&#10;    int rank(int k, bool fl = true){&#10;        return fl ? rank(root, k) : k - rank(root, k);&#10;    }&#10;&#10;    bool access(int k){&#10;        return access(root, k);&#10;    }&#10;&#10;    int zero_cnt(){&#10;        return get(root).siz - get(root).cnt;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dynamiclazysegmenttree" value="// doc: https://shibh308.github.io/library/library/lib/classes/dynamiclazysegmenttree.cpp.html&#10;template&lt;typename T, typename U&gt;&#10;struct Segtree{&#10;&#10;    struct SegNode{&#10;        T val;&#10;        U lazy;&#10;&#10;        SegNode* l;&#10;        SegNode* r;&#10;        SegNode(T val, U lazy) : val(val), lazy(lazy), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    i64 n;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;    T op_t;&#10;    U op_u;&#10;&#10;    SegNode* root;&#10;&#10;    Segtree(int n_, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t, U op_u) : f(f), g(g), h(h), op_t(op_t), op_u(op_u){&#10;        for(n = 1; n &lt; n_; n &lt;&lt;= 1);&#10;        root = new SegNode(op_t, op_u);&#10;    }&#10;&#10;    SegNode* getl(SegNode* node){&#10;        return node-&gt;l ? node-&gt;l : node-&gt;l = new SegNode(op_t, op_u);&#10;    }&#10;&#10;    SegNode* getr(SegNode* node){&#10;        return node-&gt;r ? node-&gt;r : node-&gt;r = new SegNode(op_t, op_u);&#10;    }&#10;&#10;    void eval(SegNode* node, i64 len){&#10;        node-&gt;val = g(node-&gt;val, node-&gt;lazy, len);&#10;        getl(node);&#10;        node-&gt;l-&gt;lazy = h(node-&gt;l-&gt;lazy, node-&gt;lazy);&#10;        getr(node);&#10;        node-&gt;r-&gt;lazy = h(node-&gt;r-&gt;lazy, node-&gt;lazy);&#10;        node-&gt;lazy = op_u;&#10;    }&#10;&#10;    void update(i64 x, i64 y, U val, SegNode* node = nullptr, i64 l = 0, i64 r = 0){&#10;        if(node == nullptr){&#10;            node = root;&#10;            r = n;&#10;        }&#10;        eval(node, r - l);&#10;        if(r &lt;= x || y &lt;= l)&#10;            return ;&#10;        if(x &lt;= l &amp;&amp; r &lt;= y){&#10;            node-&gt;lazy = h(node-&gt;lazy, val);&#10;            eval(node, r - l);&#10;        }else{&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;            update(x, y, val, getl(node), l, mid);&#10;            update(x, y, val, getr(node), mid, r);&#10;            node-&gt;val = f(node-&gt;l-&gt;val, node-&gt;r-&gt;val);&#10;        }&#10;    }&#10;&#10;    T get(i64 x, i64 y, SegNode* node = nullptr, i64 l = 0, i64 r = 0){&#10;        if(node	== nullptr){&#10;            node = root;&#10;            r = n;&#10;        }&#10;&#10;        if(r &lt;= x || y &lt;= l)&#10;            return op_t;&#10;        eval(node, r - l);&#10;        if(x &lt;= l &amp;&amp; r &lt;= y)&#10;            return node-&gt;val;&#10;&#10;        i64 val_l = op_t, val_r = op_t;&#10;        i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;        if(node-&gt;l)&#10;            val_l = get(x, y, node-&gt;l, l, mid);&#10;        if(node-&gt;r)&#10;            val_r = get(x, y, node-&gt;r, mid, r);&#10;        return f(val_l, val_r);&#10;    }&#10;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dynamicsegmenttree" value="// doc: https://shibh308.github.io/library/library/lib/classes/dynamicsegmenttree.cpp.html&#10;template &lt;typename T&gt;&#10;struct Segtree{&#10;&#10;    struct SegNode;&#10;&#10;    struct SegNode{&#10;        T val;&#10;        SegNode* l;&#10;        SegNode* r;&#10;&#10;        SegNode(T val) : val(val), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    i64 n;&#10;    function&lt;T(T, T)&gt; f;&#10;    T op;&#10;    SegNode* root;&#10;&#10;    Segtree(int n_, function&lt;T(T, T)&gt; f, T op) : f(f), op(op){&#10;        for(n = 1; n &lt; n_; n &lt;&lt;= 1);&#10;        root = new SegNode(op);&#10;    }&#10;&#10;    SegNode* getl(SegNode* node, T val){&#10;        return node-&gt;l == nullptr ? node-&gt;l = new SegNode(val) : node-&gt;l;&#10;    }&#10;&#10;    SegNode* getr(SegNode* node, T val){&#10;        return node-&gt;r == nullptr ? node-&gt;r = new SegNode(val) : node-&gt;r;&#10;    }&#10;&#10;    void eval(SegNode* node){&#10;        node-&gt;val = f(node-&gt;l == nullptr ? op : node-&gt;l-&gt;val, node-&gt;r == nullptr ? op : node-&gt;r-&gt;val);&#10;    }&#10;&#10;    void set(i64 x, T val){&#10;        assert(0 &lt;= x &amp;&amp; x &lt; n);&#10;&#10;        SegNode* node = root;&#10;        stack&lt;SegNode*&gt; nodes;&#10;        i64 l = 0, r = n;&#10;&#10;        while(r - l &gt; 1){&#10;            nodes.push(node);&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;            if(x &lt; mid){&#10;                node = getl(node, x);&#10;                r = mid;&#10;            }else{&#10;                node = getr(node, x);&#10;                l = mid;&#10;            }&#10;        }&#10;&#10;        node-&gt;val = val;&#10;        while(!nodes.empty()){&#10;            eval(nodes.top());&#10;            nodes.pop();&#10;        }&#10;    }&#10;&#10;    void update(i64 x, T val){&#10;        assert(0 &lt;= x &amp;&amp; x &lt; n);&#10;&#10;        SegNode* node = root;&#10;        stack&lt;SegNode*&gt; nodes;&#10;        i64 l = 0, r = n;&#10;&#10;        while(r - l &gt; 1){&#10;            nodes.push(node);&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;            if(x &lt; mid){&#10;                node = getl(node, x);&#10;                r = mid;&#10;            }else{&#10;                node = getr(node, x);&#10;                l = mid;&#10;            }&#10;        }&#10;&#10;        node-&gt;val = f(node-&gt;val, val);&#10;        while(!nodes.empty()){&#10;            eval(nodes.top());&#10;            nodes.pop();&#10;        }&#10;    }&#10;&#10;    T get(i64 x, i64 y, SegNode* node = nullptr, i64 l = 0,  i64 r = 0){&#10;&#10;        if(node == nullptr){&#10;            node = root;&#10;            r = n;&#10;        }&#10;&#10;        if(x &lt;= l &amp;&amp; r &lt;= y)&#10;            return node-&gt;val;&#10;&#10;        if(r &lt;= x || y &lt;= l)&#10;            return op;&#10;&#10;        T val_l = op, val_r = op;&#10;        i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;        if(node-&gt;l != nullptr)&#10;            val_l = f(val_l, get(x, y, node-&gt;l, l, mid));&#10;        if(node-&gt;r != nullptr)&#10;            val_r = f(get(x, y, node-&gt;r, mid, r), val_r);&#10;&#10;        return f(val_l, val_r);&#10;    }&#10;&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dynamicwaveletmatrix" value="// doc: https://shibh308.github.io/library/library/lib/classes/dynamicwaveletmatrix.cpp.html&#10;template &lt;typename T, int W&gt;&#10;struct WaveletMatrix{&#10;&#10;    array&lt;DynamicBitVector, W&gt; bv;&#10;&#10;    WaveletMatrix(vector&lt;T&gt;&amp; a){&#10;        int n = a.size();&#10;        vector&lt;T&gt; v(a);&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            vector&lt;uint64_t&gt; b((n + 31) &gt;&gt; 5, 0);&#10;            vector&lt;int&gt; length(b.size(), 0);&#10;            vector&lt;T&gt; v1, v2;&#10;            for(int j = 0; j &lt; n; ++j){&#10;                bool fl = ((v[j] &gt;&gt; i) &amp; 1);&#10;                (fl ? v2 : v1).push_back(v[j]);&#10;                b[j &gt;&gt; 5] |= uint64_t(fl) &lt;&lt; (j &amp; 31);&#10;                ++length[j &gt;&gt; 5];&#10;            }&#10;            for(int j = 0; j &lt; v.size(); ++j)&#10;                v[j] = (j &lt; v1.size() ? v1[j] : v2[j - v1.size()]);&#10;&#10;            if(b.size() &gt;= 2 &amp;&amp; !(n &amp; 31)){&#10;                b[b.size() - 2] |= b[b.size() - 1] &lt;&lt; 32;&#10;                b.pop_back();&#10;            }&#10;            bv[i].build(n, b);&#10;        }&#10;    }&#10;&#10;    void insert(int k, T x){&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (x &gt;&gt; i) &amp; 1;&#10;            bv[i].insert(k, fl);&#10;            k = (fl ? bv[i].rank_val : k - bv[i].rank_val) + (fl ? bv[i].zero_cnt() : 0);&#10;        }&#10;    }&#10;&#10;    void erase(int k){&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            int zero_cnt = bv[i].zero_cnt();&#10;            bv[i].erase(k);&#10;            bool fl = bv[i].erase_fl;&#10;            int rank = (fl ? bv[i].rank_val : k - bv[i].rank_val);&#10;            k = rank + (fl ? zero_cnt : 0);&#10;        }&#10;    }&#10;&#10;    // [l, r)内のxの数&#10;    int count(int l, int r, T x){&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (x &gt;&gt; i) &amp; 1;&#10;            int st = bv[i].rank(l, fl);&#10;            int en = bv[i].rank(r, fl);&#10;            l = (fl ? bv[i].zero_cnt() : 0) + st;&#10;            r = (fl ? bv[i].zero_cnt() : 0) + en;&#10;        }&#10;        return r - l;&#10;    }&#10;&#10;    // [l, r)内で[0, x)を満たす値の数&#10;    int count_lower(int l, int r, T x){&#10;        int cnt = 0;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (x &gt;&gt; i) &amp; 1;&#10;            int st = bv[i].rank(l, fl);&#10;            int en = bv[i].rank(r, fl);&#10;            if(fl){&#10;                st += bv[i].zero_cnt();&#10;                en += bv[i].zero_cnt();&#10;                cnt += (bv[i].rank(r, 0) - bv[i].rank(l, 0));&#10;            }&#10;            l = st, r = en;&#10;        }&#10;        return cnt;&#10;    }&#10;&#10;    // [l, r)内で[x, y)を満たす値の数&#10;    int count_range(int l, int r, T x, T y){&#10;        return count_lower(l, r, y) - count_lower(l, r, x);&#10;    }&#10;&#10;    // 0-indexedでk番目に小さいものを返す&#10;    T kth_min(int l, int r, int k){&#10;        T ans = 0;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            int st = bv[i].rank(l, 0);&#10;            int en = bv[i].rank(r, 0);&#10;            if(en - st &lt;= k){&#10;                k -= en - st;&#10;                l = bv[i].zero_cnt() + (l - st);&#10;                r = bv[i].zero_cnt() + (r - en);&#10;                ans |= (1uLL &lt;&lt; i);&#10;            }&#10;            else{&#10;                l = st, r = en;&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    // [l, r)でのx以上最小値&#10;    pair&lt;T, bool&gt; predecessor(int l, int r, T x){&#10;        int idx = count_lower(l, r, x);&#10;        if(idx == r - l){&#10;            return make_pair((1uLL &lt;&lt; W) - 1, false);&#10;        }&#10;        return make_pair(kth_min(l, r, idx), true);&#10;    }&#10;&#10;    // [l, r)でのx以下最大値&#10;    pair&lt;T, bool&gt; successor(int l, int r, T x){&#10;        int idx = count_lower(l, r, x + 1);&#10;        if(idx == 0)&#10;            return make_pair(0, false);&#10;        return make_pair(kth_min(l, r, idx - 1), true);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="eertree" value="// doc: https://shibh308.github.io/library/library/lib/classes/eertree.cpp.html&#10;// verify: https://yukicoder.me/submissions/518134&#10;struct EerTree{&#10;    struct Node{&#10;        Node(int len) : len(len), sdep(0), slink(nullptr){}&#10;        int len, sdep;&#10;        map&lt;char, Node*&gt; ch;&#10;        Node* slink;&#10;    };&#10;    pair&lt;Node*, Node*&gt; root;&#10;    Node* active_point;&#10;    string s;&#10;    EerTree(){&#10;        root.second = new Node(0);&#10;        root.second-&gt;slink = root.first = active_point = new Node(-1);&#10;        root.first-&gt;slink = root.first;&#10;    }&#10;    EerTree(string inp) : EerTree(){&#10;        for(auto c : inp)&#10;            add(c);&#10;    }&#10;    Node* make(Node* par, char c){&#10;        if(par-&gt;ch.find(c) == par-&gt;ch.end()){&#10;            par-&gt;ch[c] = new Node(par-&gt;len + 2);&#10;            Node* sl = par-&gt;slink;&#10;            if(par-&gt;len == -1)&#10;                sl = root.second;&#10;            else{&#10;                while(1){&#10;                    if(s[s.size() - sl-&gt;len - 2] == c){&#10;                        sl = sl-&gt;ch[c];&#10;                        break;&#10;                    }else if(sl-&gt;len &lt; 0){&#10;                        sl = root.second;&#10;                        break;&#10;                    }else&#10;                        sl = sl-&gt;slink;&#10;                }&#10;            }&#10;            par-&gt;ch[c]-&gt;slink = sl;&#10;            par-&gt;ch[c]-&gt;sdep = sl-&gt;sdep + 1;&#10;        }&#10;        return par-&gt;ch[c];&#10;    }&#10;    void add(char c){&#10;        for(s += c; int(s.size()) - active_point-&gt;len - 2 &lt; 0 || s[s.size() - active_point-&gt;len - 2] != c; active_point = active_point-&gt;slink);&#10;        active_point = make(active_point, c);&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="eulertour" value="// doc: https://shibh308.github.io/library/library/lib/classes/eulertour.cpp.html&#10;struct EulerTour{&#10;    int n;&#10;    vector&lt;int&gt; in, out;&#10;    EulerTour(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int par = 0) : n(edges.size()), in(n, -1), out(n, -1){&#10;        int cnt = 0;&#10;        function&lt;void(int)&gt; f = [&amp;](int x){&#10;            in[x] = cnt++;&#10;            for(auto y : edges[x]){&#10;                if(in[y] == -1)&#10;                    f(y);&#10;            }&#10;            out[x] = cnt;&#10;        };&#10;        f(par);&#10;    }&#10;    int get_pos(int x){&#10;        return in[x];&#10;    }&#10;    // 自身を含みたくない場合は(in[x] + 1, out[x])&#10;    pair&lt;int,int&gt; get_subtree(int x){&#10;        return make_pair(in[x], out[x]);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="hashmap" value="// doc: https://shibh308.github.io/library/library/lib/classes/hashmap.cpp.html&#10;template &lt;typename T, typename U, T del = numeric_limits&lt;T&gt;::max(), T null = numeric_limits&lt;T&gt;::max() - 1&gt;&#10;struct HashMap{&#10;    static constexpr __int128_t z = 0xf332ac987401cba5;&#10;    uint64_t n, q, d;&#10;&#10;    vector&lt;pair&lt;T, U&gt;&gt; v;&#10;&#10;    HashMap() : n(0), q(0), d(1),  v(2, make_pair(null, U())){&#10;    }&#10;&#10;    inline uint64_t hash(T key){return uint64_t((z * __int128_t(key)) &gt;&gt; (64 - d)) &amp; ((1LL &lt;&lt; d) - 1);}&#10;&#10;    pair&lt;U, bool&gt; find(T x){&#10;        for(uint64_t i = hash(x); v[i].first != null; i = (i + 1) &amp; ((1 &lt;&lt; d) - 1))&#10;            if(v[i].first == x)&#10;                return make_pair(v[i].second, true);&#10;        return make_pair(U(), false);&#10;    }&#10;&#10;    bool add(T x, U val){&#10;        if(find(x).second)&#10;            return false;&#10;        if(((q + 1) &lt;&lt; 1) &gt; (1 &lt;&lt; d) || (1 &lt;&lt; d) &lt; 3 * n)&#10;            resize();&#10;        uint64_t i = hash(x);&#10;        for(; v[i].first != null &amp;&amp; v[i].first != del; i = (i + 1) &amp; ((1 &lt;&lt; d) - 1));&#10;        q += (v[i].first == null);&#10;        ++n;&#10;        v[i] = make_pair(x, val);&#10;        return true;&#10;    }&#10;&#10;    bool erase(T x){&#10;        uint64_t i = hash(x);&#10;        for(; v[i].first != null &amp;&amp; v[i].first != x; i = (i + 1) &amp; ((1 &lt;&lt; d) - 1));&#10;        if(v[i].first == null)&#10;            return false;&#10;        --n;&#10;        v[i] = make_pair(del, U());&#10;        return true;&#10;    }&#10;&#10;    void resize(){&#10;        ++d;&#10;        vector&lt;pair&lt;T, U&gt;&gt; old_table;&#10;        q = n;&#10;        swap(old_table, v);&#10;        v.assign(1 &lt;&lt; d, make_pair(null, U()));&#10;        n = 0;&#10;        for(int i = 0; i &lt; old_table.size(); ++i)&#10;            if(old_table[i].first != null &amp;&amp; old_table[i].first != del)&#10;                add(old_table[i].first, old_table[i].second);&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="hashpatriciatree" value="// doc: https://shibh308.github.io/library/library/lib/classes/hashpatriciatree.cpp.html&#10;struct HashPatriciaTree{&#10;    struct Node{&#10;        bool is_elm = false;&#10;        int ch = 0;&#10;        int len = 0;&#10;        int par = -1;&#10;        int data_idx = -1;&#10;        Hash hash;&#10;    };&#10;&#10;    static int fat(int l, int r){&#10;        return r &amp; (-1 &lt;&lt; (31 - __builtin_clz(l ^ r)));&#10;    };&#10;&#10;    AVL_map&lt;int,int&gt; avl;&#10;    vector&lt;function&lt;Hash(int)&gt;&gt; hash_func;&#10;    vector&lt;function&lt;int(int)&gt;&gt; access_func;&#10;    vector&lt;Node&gt; nodes;&#10;    HashMap&lt;uint64_t, int&gt; hmap;&#10;    vector&lt;int&gt; idxes;&#10;&#10;    HashPatriciaTree() : nodes(1){&#10;    }&#10;&#10;    void make_fat(int x){&#10;        int st = nodes[nodes[x].par].len;&#10;        int en = nodes[x].len;&#10;        int fa = fat(st, en);&#10;        auto ha = hash_func[nodes[x].data_idx](fa);&#10;        nodes[x].hash = ha;&#10;        hmap.add(ha.concat(ha.l).h, x);&#10;    }&#10;&#10;    void make(int idx, int target, int len, int label){&#10;        nodes.emplace_back();&#10;        nodes.back().len = len;&#10;        nodes.back().data_idx = idx;&#10;        nodes.back().par = target;&#10;        nodes[target].ch = avl.add(nodes[target].ch, label, nodes.size() - 1);&#10;        make_fat(nodes.size() - 1);&#10;    }&#10;&#10;    void split(int idx, int target, int len, int match_len, int new_label, int root_label, int branch_label){&#10;        int par = nodes[target].par;&#10;        nodes.emplace_back();&#10;        nodes.back().len = match_len;&#10;        nodes.back().data_idx = idx;&#10;        nodes.back().par = par;&#10;&#10;        Hash ha = nodes[target].hash;&#10;        hmap.erase(ha.concat(ha.l).h);&#10;&#10;        nodes[par].ch = avl.add(nodes[par].ch, root_label, nodes.size() - 1);&#10;        nodes.back().ch = avl.add(nodes.back().ch, branch_label, target);&#10;        nodes[target].par = nodes.size() - 1;&#10;        int target_siz = nodes.size() - 1;&#10;        if(nodes.back().len != len)&#10;            make(idx, nodes.size() - 1, len, new_label);&#10;        make_fat(target);&#10;        make_fat(target_siz);&#10;    }&#10;&#10;    // f(x): 長さxのprefixのハッシュを返す&#10;    // g(x): x文字目を返す&#10;    void insert(int m, function&lt;Hash(int)&gt; f, function&lt;int(int)&gt; g){&#10;        hash_func.emplace_back(f);&#10;        access_func.emplace_back(g);&#10;        int len, x;&#10;        tie(len, x) = match(m, f, g);&#10;        assert(!(len || x) || (nodes[nodes[x].par].len &lt; len &amp;&amp; len &lt;= nodes[x].len));&#10;        if(len == nodes[x].len){&#10;            if(len == m){&#10;                idxes.emplace_back(x);&#10;                nodes[x].data_idx = idxes.size() - 1;&#10;                nodes[x].is_elm = true;&#10;                return;&#10;            }&#10;            else&#10;                make(idxes.size(), x, m, g(len));&#10;        }&#10;        else{&#10;            split(idxes.size(), x, m, len, g(len), access_func[nodes[x].data_idx](nodes[nodes[x].par].len), access_func[nodes[x].data_idx](len));&#10;        }&#10;        idxes.emplace_back(nodes.size() - 1);&#10;        nodes.back().is_elm = true;&#10;    }&#10;&#10;    int lcp(int ok, int ng, function&lt;Hash(int)&gt; f, function&lt;Hash(int)&gt; g){&#10;        while(ng - ok &gt; 1){&#10;            int mid = (ok + ng) &gt;&gt; 1;&#10;            (f(mid) == g(mid) ? ok : ng) = mid;&#10;        }&#10;        return ok;&#10;    }&#10;&#10;    // (マッチ長, ノード)&#10;    pair&lt;int,int&gt; match(int m, function&lt;Hash(int)&gt; f, function&lt;int(int)&gt; g){&#10;        int ok = 0, ng = m + 1;&#10;        int x = 0;&#10;        int ok_len = 0;&#10;        while(ng - ok &gt; 1){&#10;            int mid = fat(ok + 1, ng - 1);&#10;            Hash h = f(mid);&#10;            int idx;&#10;            bool fl;&#10;            tie(idx, fl) = hmap.find(h.concat(h.l).h);&#10;            if(fl){&#10;                x = idx;&#10;                ok_len = ok;&#10;                ok = nodes[x].len;&#10;            }&#10;            else{&#10;                ng = mid;&#10;            }&#10;        }&#10;        int match_len;&#10;        if(ok == 0){&#10;            match_len = 0;&#10;        }&#10;        else{&#10;            match_len = lcp(ok_len, min(m, nodes[x].len) + 1, f, hash_func[nodes[x].data_idx]);&#10;            if(match_len &lt; nodes[x].len){&#10;                return {match_len, x};&#10;            }&#10;        }&#10;        int label = g(ok);&#10;        int ch;&#10;        bool fl;&#10;        tie(ch, fl) = avl.get(nodes[x].ch, label);&#10;        if(!fl){&#10;            assert(match_len &lt;= m);&#10;            return {match_len, x};&#10;        }&#10;        match_len = lcp(match_len, min(m, nodes[ch].len) + 1, f, hash_func[nodes[ch].data_idx]);&#10;        assert(match_len &lt;= m);&#10;        return {match_len, ch};&#10;    }&#10;    template&lt;typename T&gt;&#10;    static pair&lt;function&lt;Hash(int)&gt;, function&lt;int(int)&gt;&gt; build(T&amp; s, vector&lt;Hash&gt;&amp; v){&#10;        auto f = [&amp;v](int i){&#10;            return v[i];&#10;        };&#10;        auto g = [&amp;s](int i){&#10;            return s[i];&#10;        };&#10;        return {f, g};&#10;    }&#10;    template&lt;typename T&gt;&#10;    static pair&lt;vector&lt;function&lt;Hash(int)&gt;&gt;, vector&lt;function&lt;int(int)&gt;&gt;&gt; build_suffix(T&amp; s, vector&lt;Hash&gt;&amp; v){&#10;        vector&lt;function&lt;Hash(int)&gt;&gt; fv;&#10;        vector&lt;function&lt;int(int)&gt;&gt; gv;&#10;        for(int j = 0; j &lt; s.size(); ++j){&#10;            auto f = [j, &amp;v](int i){&#10;                return v[i + j].sub(v[j]);&#10;            };&#10;            auto g = [j, &amp;s](int i){&#10;                return s[i + j];&#10;            };&#10;            fv.emplace_back(f);&#10;            gv.emplace_back(g);&#10;        }&#10;        return {fv, gv};&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="heavylightdecomposition" value="// doc: https://shibh308.github.io/library/library/lib/classes/heavylightdecomposition.cpp.html&#10;struct HeavyLightDecomposition{&#10;    int n;&#10;    vector&lt;int&gt; size, par, in, in_rev, heavy_root, depth, heavy_depth, out;&#10;    vector&lt;vector&lt;int&gt;&gt; childs;&#10;    HeavyLightDecomposition(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int root = 0) : n(edges.size()), size(n, 1), par(n, -2), depth(n, 0), childs(n), in(n), in_rev(n), heavy_root(n), heavy_depth(n, 0), out(n){&#10;        function&lt;void(int)&gt; swap_dfs = [&amp;](int x){&#10;            int size_max = 0;&#10;            int max_idx = 0;&#10;            for(int i = 0; i &lt; edges[x].size(); ++i){&#10;                int y = edges[x][i];&#10;                if(par[y] == -2){&#10;                    par[y] = x;&#10;                    depth[y] = depth[x] + 1;&#10;                    childs[x].push_back(y);&#10;                    swap_dfs(y);&#10;                    size[x] += size[y];&#10;                    if(chmax(size_max, size[y])){&#10;                        max_idx = childs[x].size() - 1;&#10;                    }&#10;                }&#10;            }&#10;            if(max_idx){&#10;                swap(childs[x][0], childs[x][max_idx]);&#10;            }&#10;        };&#10;        par[root] = -1;&#10;        swap_dfs(root);&#10;&#10;        int cnt = 0;&#10;        function&lt;void(int,int)&gt; dfs = [&amp;](int x, int segment_root){&#10;            heavy_root[x] = segment_root;&#10;            in_rev[cnt] = x;&#10;            in[x] = cnt++;&#10;            for(int i = 0; i &lt; childs[x].size(); ++i){&#10;                int y = childs[x][i];&#10;                if(i == 0){&#10;                    dfs(y, segment_root);&#10;                }&#10;                else{&#10;                    heavy_depth[y] = heavy_depth[segment_root] + 1;&#10;                    dfs(y, y);&#10;                }&#10;            }&#10;            out[x] = cnt;&#10;        };&#10;        dfs(root, root);&#10;    }&#10;    int lca(int x, int y){&#10;        while(heavy_root[x] != heavy_root[y]){&#10;            if(heavy_depth[heavy_root[x]] &gt; heavy_depth[heavy_root[y]])&#10;                swap(x, y);&#10;            y = par[heavy_root[y]];&#10;        }&#10;        return depth[x] &lt; depth[y] ? x : y;&#10;    }&#10;    // x以下の部分木を返す&#10;    pair&lt;int,int&gt; subtree(int x){&#10;        return make_pair(in[x], out[x]);&#10;    }&#10;    // x-zのパスとy-zのパスを返す(両方とも根側に進むので注意)&#10;    // それぞれのHeavy-Pathは根側の方がindexが小さいので注意(可換クエリ処理で気をつける)&#10;    pair&lt;vector&lt;pair&lt;int,int&gt;&gt;, vector&lt;pair&lt;int,int&gt;&gt;&gt; two_point_path(int x, int y){&#10;        vector&lt;pair&lt;int,int&gt;&gt; xz, yz;&#10;        int z = lca(x, y);&#10;        while(heavy_root[x] != heavy_root[z]){&#10;            xz.emplace_back(in[heavy_root[x]], in[x] + 1);&#10;            x = par[heavy_root[x]];&#10;        }&#10;        while(heavy_root[y] != heavy_root[z]){&#10;            yz.emplace_back(in[heavy_root[y]], in[y] + 1);&#10;            y = par[heavy_root[y]];&#10;        }&#10;        // 辺属性にしたい場合はここをin[z] + 1, in[x] + 1にする&#10;        xz.emplace_back(in[z], in[x] + 1);&#10;        yz.emplace_back(in[z] + 1, in[y] + 1);&#10;        return make_pair(xz, yz);&#10;    }&#10;    // 頂点xがEuler-Tour上で何番目に位置するかを返す&#10;    // in[元の頂点index] = 内部でのindex&#10;    // in_rev[内部でのindex] = 元の頂点index&#10;    int get_idx(int x){&#10;        return in[x];&#10;    }&#10;    // xが属するHeavy-Pathの深さを返す&#10;    int get_heavy_depth(int x){&#10;        return heavy_depth[heavy_root[x]];&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lazysegtree" value="// doc: https://shibh308.github.io/library/library/lib/classes/lazysegtree.cpp.html&#10;template&lt;typename T, typename U&gt;&#10;struct Segtree{&#10;    int n;&#10;    T op_t;&#10;    U op_u;&#10;    vector&lt;T&gt; elm;&#10;    vector&lt;U&gt; lazy;&#10;    vector&lt;int&gt; length;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;&#10;    Segtree(int n, T init, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t = T(), U op_u = U()) :&#10;        n(n),&#10;        op_t(op_t),&#10;        op_u(op_u),&#10;        elm(2 * n, init),&#10;        lazy(2 * n, op_u),&#10;        length(2 * n, 0),&#10;        f(f),&#10;        g(g),&#10;        h(h)&#10;    {&#10;        for(int i = n - 1; i &gt; 0; --i){&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;            length[i] = length[2 * i] + 1;&#10;        }&#10;    }&#10;&#10;    Segtree(int n, vector&lt;T&gt; init, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t = T(), U op_u = U()) :&#10;        n(n),&#10;        op_t(op_t),&#10;        op_u(op_u),&#10;        elm(2 * n),&#10;        lazy(2 * n, op_u),&#10;        length(2 * n, 0),&#10;        f(f),&#10;        g(g),&#10;        h(h)&#10;    {&#10;        for(int i = 0; i &lt; n; ++i)&#10;            elm[i + n] = init[i];&#10;&#10;        for(int i = n - 1; i &gt; 0; --i){&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;            length[i] = length[2 * i] + 1;&#10;        }&#10;    }&#10;&#10;    vector&lt;int&gt; get_list(int x, int y){&#10;&#10;        vector&lt;int&gt; ret_list;&#10;        for(x += n, y += n - 1; x; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            ret_list.emplace_back(x);&#10;            if(x != y)&#10;                ret_list.emplace_back(y);&#10;        }&#10;&#10;        return ret_list;&#10;    }&#10;&#10;    void eval(int x){&#10;&#10;        elm[x] = g(elm[x], lazy[x], 1 &lt;&lt; length[x]);&#10;        if(x &lt; n){&#10;            lazy[2 * x] = h(lazy[2 * x], lazy[x]);&#10;            lazy[2 * x + 1] = h(lazy[2 * x + 1], lazy[x]);&#10;        }&#10;        lazy[x] = op_u;&#10;    }&#10;&#10;    void update(int x, int y, U val){&#10;&#10;        if(x == y)&#10;            return;&#10;        vector&lt;int&gt; index_list = get_list(x, y);&#10;        for(int i = index_list.size() - 1; i &gt;= 0; --i)&#10;            eval(index_list[i]);&#10;&#10;        for(x += n, y += n - 1; x &lt;= y; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            if(x &amp; 1){&#10;                lazy[x] = h(lazy[x], val);&#10;                eval(x++);&#10;            }&#10;            if(!(y &amp; 1)){&#10;                lazy[y] = h(lazy[y], val);&#10;                eval(y--);&#10;            }&#10;        }&#10;&#10;        for(auto index : index_list){&#10;            if(index &lt; n){&#10;                eval(2 * index);&#10;                eval(2 * index + 1);&#10;                elm[index] = f(elm[2 * index], elm[2 * index + 1]);&#10;            }&#10;        }&#10;    }&#10;&#10;    T get(int x, int y){&#10;&#10;        vector&lt;int&gt; index_list = get_list(x, y);&#10;        for(int i = index_list.size() - 1; i &gt;= 0; --i)&#10;            eval(index_list[i]);&#10;&#10;        T l = op_t, r = op_t;&#10;        for(x += n, y += n - 1; x &lt;= y; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            if(x &amp; 1){&#10;                eval(x);&#10;                l = f(l, elm[x++]);&#10;            }&#10;            if(!(y &amp; 1)){&#10;                eval(y);&#10;                r = f(elm[y--], r);&#10;            }&#10;        }&#10;        return f(l, r);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lazyskiplist" value="// doc: https://shibh308.github.io/library/library/lib/classes/lazyskiplist.cpp.html&#10;template &lt;typename T, typename U&gt;&#10;struct SkipList{&#10;&#10;    static uint32_t rnd(){&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = 0; // time(0);&#10;        uint32_t t = x ^ (x &lt;&lt; 11);&#10;        x = y, y = z, z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return w;&#10;    }&#10;&#10;    struct Node{&#10;        int height;&#10;        vector&lt;Node*&gt; next, prev;&#10;        vector&lt;T&gt; sum;&#10;        vector&lt;U&gt; lazy;&#10;        vector&lt;int&gt; size;&#10;        Node(T val, int height, U op_u) : height(height), next(height, nullptr), prev(height, nullptr), sum(height, val), lazy(height, op_u), size(height, 1){}&#10;    };&#10;&#10;    using NodePtr = Node*;&#10;    int max_height;&#10;    NodePtr front, back;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;    T op_t;&#10;    U op_u;&#10;&#10;    SkipList(function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t, U op_u) : max_height(0), f(f), g(g), h(h), op_t(op_t), op_u(op_u){&#10;        front = new Node(op_t, 21, op_u);&#10;        back = new Node(op_t, 21, op_u);&#10;        front-&gt;next[0] = back;&#10;        back-&gt;prev[0] = front;&#10;    }&#10;&#10;    int size(){&#10;        return front-&gt;size[max_height] - 1;&#10;    }&#10;&#10;    T get_val(NodePtr ptr, int height){&#10;        return ptr-&gt;lazy[height] == op_u ? ptr-&gt;sum[height] : g(ptr-&gt;sum[height], ptr-&gt;lazy[height], ptr-&gt;size[height]);&#10;    }&#10;&#10;    NodePtr insert_next(NodePtr pre, T key){&#10;        uint32_t r = max(rnd(), uint32_t(1));&#10;        int height = min(__builtin_ffs(r), 20);&#10;        while(max_height &lt; height){&#10;            ++max_height;&#10;            front-&gt;size[max_height] = front-&gt;size[max_height - 1];&#10;            front-&gt;next[max_height] = back;&#10;            back-&gt;prev[max_height] = front;&#10;            front-&gt;sum[max_height] = front-&gt;sum[max_height - 1];&#10;            front-&gt;lazy[max_height] = front-&gt;lazy[max_height - 1];&#10;            front-&gt;lazy[max_height - 1] = op_u;&#10;        }&#10;        NodePtr node = new Node(key, height, op_u);&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; node_list = get_list(pre);&#10;        for(int i = node_list.size() - 1; i &gt;= 0; --i)&#10;            eval(node_list[i].first, node_list[i].second);&#10;        int pre_size = 1;&#10;        T pre_sum = pre-&gt;sum[0];&#10;        T nex_sum = key;&#10;        NodePtr nex = pre-&gt;next[0];&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            ++pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = node;&#10;                node-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = node;&#10;                node-&gt;prev[i] = pre;&#10;                int range_size = pre-&gt;size[i];&#10;                pre-&gt;size[i] = pre_size;&#10;                pre-&gt;sum[i] = pre_sum;&#10;                node-&gt;size[i] = range_size - pre_size;&#10;                node-&gt;sum[i] = nex_sum;&#10;            }&#10;            else{&#10;                pre-&gt;sum[i] = f(pre_sum, nex_sum);&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i]){&#10;                pre_sum = f(get_val(pre-&gt;prev[i], i), pre_sum);&#10;                pre_size += pre-&gt;prev[i]-&gt;size[i];&#10;            }&#10;            for(; nex-&gt;height == i + 1 &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i]){&#10;                nex_sum = f(nex_sum, get_val(nex, i));&#10;            }&#10;        }&#10;		return node;&#10;    }&#10;&#10;    // idx番目(idx=0なら先頭)に挿入する&#10;    NodePtr insert_index(int idx, T key){&#10;        NodePtr pre = access(idx - 1);&#10;        return insert_next(pre, key);&#10;    }&#10;&#10;    NodePtr insert_key(T key){&#10;        NodePtr pre = lower_bound(key)-&gt;prev[0];&#10;        return insert_next(pre, key);&#10;    }&#10;&#10;    NodePtr erase(NodePtr target){&#10;        // メモリ解放はしない(してもいいけど)&#10;        int height = target-&gt;height;&#10;        NodePtr pre = target-&gt;prev[0];&#10;        NodePtr nex = target-&gt;next[0];&#10;		NodePtr ret = nex;&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; node_list = get_list(pre, target);&#10;        for(int i = node_list.size() - 1; i &gt;= 0; --i)&#10;            eval(node_list[i].first, node_list[i].second);&#10;        T sum = pre-&gt;sum[0];&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            pre-&gt;sum[i] = sum;&#10;            --pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = pre;&#10;                pre-&gt;size[i] += target-&gt;size[i];&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i])&#10;                sum = f(get_val(pre-&gt;prev[i], i), sum);&#10;            for(; nex-&gt;height == i + 1 &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i])&#10;                sum = f(sum, get_val(nex, i));&#10;        }&#10;		return ret;&#10;    }&#10;&#10;    NodePtr erase_index(int idx){&#10;        NodePtr target = access(idx);&#10;        return erase(target);&#10;    }&#10;&#10;    NodePtr erase_key(T key){&#10;        NodePtr target = lower_bound(key);&#10;        if(target == back || target-&gt;sum[0] != key)&#10;            return target;&#10;        return erase(target);&#10;    }&#10;&#10;    NodePtr lower_bound(T key){&#10;        NodePtr pre = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; pre-&gt;next.size() &amp;&amp; pre-&gt;next[i] != back &amp;&amp; pre-&gt;next[i]-&gt;sum[0] &lt; key; pre = pre-&gt;next[i]);&#10;        return pre-&gt;next[0];&#10;    }&#10;&#10;    NodePtr upper_bound(T key){&#10;        NodePtr pre = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; pre-&gt;next.size() &amp;&amp; pre-&gt;next[i] != back &amp;&amp; pre-&gt;next[i]-&gt;sum[0] &lt;= key; pre = pre-&gt;next[i]);&#10;        return pre-&gt;next[0];&#10;    }&#10;&#10;    bool contains(T key){&#10;        NodePtr ptr = lower_bound(key);&#10;        return ptr != back &amp;&amp; ptr-&gt;key == key;&#10;    }&#10;&#10;    // (k個先のノード, [ptr, ptr + k)を覆う区間のリスト)を返す&#10;    pair&lt;NodePtr, vector&lt;pair&lt;NodePtr, int&gt;&gt;&gt; kth_next(NodePtr ptr, int k){&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; node_list;&#10;        for(; ptr-&gt;size[ptr-&gt;height - 1] &lt;= k; ptr = ptr-&gt;next[ptr-&gt;height - 1]){&#10;            k -= ptr-&gt;size[ptr-&gt;height - 1];&#10;            node_list.emplace_back(ptr, ptr-&gt;height - 1);&#10;        }&#10;        for(int i = ptr-&gt;height - 2; k; --i)&#10;            for(; ptr-&gt;size[i] &lt;= k; ptr = ptr-&gt;next[i]){&#10;                k -= ptr-&gt;size[i];&#10;                node_list.emplace_back(ptr, i);&#10;            }&#10;        return make_pair(ptr, node_list);&#10;    }&#10;&#10;    // 0-indexedでアクセスする&#10;    NodePtr access(int idx){&#10;        ++idx;&#10;        assert(0 &lt;= idx &amp;&amp; idx &lt;= size());&#10;        NodePtr ptr = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; ptr-&gt;next.size() &amp;&amp; ptr-&gt;next[i] != back &amp;&amp; ptr-&gt;size[i] &lt;= idx; idx -= ptr-&gt;size[i], ptr = ptr-&gt;next[i]);&#10;        return ptr;&#10;    }&#10;&#10;    vector&lt;pair&lt;NodePtr, int&gt;&gt; get_list(NodePtr ptr){&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; node_list;&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            node_list.emplace_back(ptr, i);&#10;            for(; ptr-&gt;height == i + 1 &amp;&amp; ptr-&gt;prev[i] != nullptr; ptr = ptr-&gt;prev[i]);&#10;        }&#10;        return node_list;&#10;    }&#10;&#10;    vector&lt;pair&lt;NodePtr, int&gt;&gt; get_list(NodePtr l_ptr, NodePtr r_ptr){&#10;        NodePtr ptr = l_ptr;&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; ptr_list;&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            ptr_list.emplace_back(l_ptr, i);&#10;            if(l_ptr != r_ptr)&#10;                ptr_list.emplace_back(r_ptr, i);&#10;            for(; l_ptr-&gt;height == i + 1 &amp;&amp; l_ptr-&gt;prev[i] != nullptr; l_ptr = l_ptr-&gt;prev[i]);&#10;            for(; r_ptr-&gt;height == i + 1 &amp;&amp; r_ptr-&gt;prev[i] != nullptr; r_ptr = r_ptr-&gt;prev[i]);&#10;        }&#10;        return ptr_list;&#10;    }&#10;&#10;    vector&lt;NodePtr&gt; get_child(NodePtr ptr, int height){&#10;        vector&lt;NodePtr&gt; node_vec;&#10;        if(height == 0)&#10;            return node_vec;&#10;        int diff = ptr-&gt;size[height];&#10;        for(; diff; ptr = ptr-&gt;next[height - 1]){&#10;            diff -= ptr-&gt;size[height - 1];&#10;            node_vec.emplace_back(ptr);&#10;        }&#10;        return node_vec;&#10;    }&#10;&#10;    void eval(NodePtr ptr, int height){&#10;        U lazy = ptr-&gt;lazy[height];&#10;        if(lazy == op_u)&#10;            return;&#10;        ptr-&gt;sum[height] = get_val(ptr, height);&#10;        vector&lt;NodePtr&gt; child_list = get_child(ptr, height);&#10;        for(auto child : child_list)&#10;            child-&gt;lazy[height - 1] = h(child-&gt;lazy[height - 1], lazy);&#10;        ptr-&gt;lazy[height] = op_u;&#10;    }&#10;&#10;    T get(int idx){&#10;        NodePtr ptr = access(idx);&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; node_list = get_list(ptr);&#10;        T sum = node_list[0].first-&gt;sum[0];&#10;        for(int i = node_list.size() - 1; i &gt;= 0; --i){&#10;            NodePtr node = node_list[i].first;&#10;            int height = node_list[i].second;&#10;            sum = g(sum, node-&gt;lazy[height], node-&gt;size[height]);&#10;        }&#10;        return sum;&#10;    }&#10;&#10;    T get(int l, int r){&#10;        NodePtr l_ptr = access(l);&#10;        NodePtr r_ptr;&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; segment_list;&#10;        tie(r_ptr, segment_list) = kth_next(l_ptr, r - l);&#10;        r_ptr = r_ptr-&gt;prev[0];&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; ptr_list = get_list(l_ptr, r_ptr);&#10;        for(int i = ptr_list.size() - 1; i &gt;= 0; --i)&#10;            eval(ptr_list[i].first, ptr_list[i].second);&#10;        T sum = op_t;&#10;        for(auto p : segment_list){&#10;            NodePtr ptr = p.first;&#10;            int height = p.second;&#10;            sum = f(sum, get_val(ptr, height));&#10;        }&#10;        return sum;&#10;    }&#10;&#10;    void update(int l, int r, U val){&#10;        NodePtr l_ptr = access(l);&#10;        NodePtr r_ptr;&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; segment_list;&#10;        tie(r_ptr, segment_list) = kth_next(l_ptr, r - l);&#10;        r_ptr = r_ptr-&gt;prev[0];&#10;        vector&lt;pair&lt;NodePtr, int&gt;&gt; ptr_list = get_list(l_ptr, r_ptr);&#10;        for(int i = ptr_list.size() - 1; i &gt;= 0; --i)&#10;            eval(ptr_list[i].first, ptr_list[i].second);&#10;        for(auto p : segment_list){&#10;            int height = p.second;&#10;            NodePtr ptr = p.first;&#10;            ptr-&gt;lazy[height] = h(ptr-&gt;lazy[height], val);&#10;        }&#10;        for(auto p : ptr_list){&#10;            NodePtr node = p.first;&#10;            int height = p.second;&#10;            if(!height)&#10;                continue;&#10;            vector&lt;NodePtr&gt; child_list = get_child(node, height);&#10;            T sum = op_t;&#10;            for(auto child : child_list)&#10;                sum = f(sum, get_val(child, height - 1));&#10;            node-&gt;sum[height] = sum;&#10;        }&#10;    }&#10;&#10;    void print(bool eval_flag = false){&#10;        int idx = -1;&#10;        for(NodePtr node = front; node != nullptr; node = node-&gt;next[0], ++idx){&#10;            if(node == front || node == back)&#10;                printf(&quot;  null: &quot;);&#10;            else&#10;                printf(&quot;%6d: &quot;, eval_flag ? get(idx) : node-&gt;sum[0]);&#10;            for(int i = 0; i &lt; node-&gt;height; ++i)&#10;                printf(&quot;%2d: &quot;, eval_flag ? get_val(node, i) : node-&gt;sum[i]);&#10;                // cout &lt;&lt; node-&gt;size[i] &lt;&lt; &quot; &quot;;&#10;            cout &lt;&lt; endl;&#10;        }&#10;        cout &lt;&lt; endl;&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lineartimesparsetable" value="// doc: https://shibh308.github.io/library/library/lib/classes/lineartimesparsetable.cpp.html&#10;template&lt;typename T&gt;&#10;struct LinearTimeSparseTable{&#10;    int n, m;&#10;    vector&lt;T&gt; a;&#10;    SparseTable&lt;T&gt; b;&#10;    vector&lt;vector&lt;uint32_t&gt;&gt; c;&#10;    static constexpr uint32_t block = 32;&#10;    LinearTimeSparseTable(vector&lt;T&gt;&amp; v) : n(v.size()), a(v), m((n + block - 1) / block){&#10;        n = m * block;&#10;        v.resize(n, 0);&#10;        vector&lt;T&gt; big_table(m);&#10;        for(int i = 0; i &lt; n; ++i)&#10;            big_table[i / block] = (i &amp; (block - 1) ? min(big_table[i / block], v[i]) : v[i]);&#10;        b = SparseTable&lt;T&gt;(big_table, [](auto x, auto y){return min(x, y);});&#10;        c.assign(m, vector&lt;uint32_t&gt;(block, 0));&#10;        for(int i = 0; i &lt; m; ++i){&#10;            stack&lt;pair&lt;T, int&gt;&gt; st;&#10;            vector&lt;int&gt; g(block, -1);&#10;            for(int j = 0; j &lt; block; ++j){&#10;                T x = v[i * block + j];&#10;                while(!st.empty() &amp;&amp; x &lt;= st.top().first)st.pop();&#10;                if(!st.empty())&#10;                    g[j] = st.top().second;&#10;                st.emplace(x, j);&#10;            }&#10;            for(int j = 0; j &lt; block; ++j){&#10;                c[i][j] = (g[j] == -1 ? 0 : c[i][g[j]] | (1u &lt;&lt; g[j]));&#10;            }&#10;        }&#10;    }&#10;    T get_small(int i, int j, int k){&#10;        uint32_t w = c[k][j] &amp; ~((1u &lt;&lt; i) - 1);&#10;        if(w == 0)&#10;            return a[k * block + j];&#10;        return a[k * block + (__builtin_ffs(w) - 1)];&#10;    }&#10;    T get(int l, int r){&#10;        --r;&#10;        int lb = l / block;&#10;        int rb = r / block;&#10;        int lc = l &amp; (block - 1);&#10;        int rc = r &amp; (block - 1);&#10;        if(lb == rb)&#10;            return get_small(lc, rc, lb);&#10;        T l_res = get_small(lc, block - 1, lb);&#10;        T r_res = get_small(0, rc, rb);&#10;        if(rb - lb == 1)&#10;            return min(l_res, r_res);&#10;        return min({l_res, r_res, b.get(lb + 1, rb)});&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lowlink" value="// doc: https://shibh308.github.io/library/library/lib/classes/lowlink.cpp.html&#10;struct LowLink{&#10;    vector&lt;vector&lt;int&gt;&gt;&amp; edges;&#10;    // 関節点&#10;    vector&lt;int&gt; art;&#10;    vector&lt;pair&lt;int,int&gt;&gt; bridge;&#10;&#10;    vector&lt;int&gt; used, ord, low;&#10;    int k;&#10;&#10;    void dfs(int idx, int par){&#10;        ord[idx] = k++;&#10;        low[idx] = ord[idx];&#10;        bool is_art = false;&#10;        int cnt = 0;&#10;        for(auto&amp; to : edges[idx]){&#10;            if(ord[to] == -1){&#10;                ++cnt;&#10;                dfs(to, idx);&#10;                low[idx] = min(low[idx], low[to]);&#10;                is_art |= par != -1 &amp;&amp; low[to] &gt;= ord[idx];&#10;                if(ord[idx] &lt; low[to])&#10;                    bridge.emplace_back(idx, to);&#10;            }else if(to != par)&#10;                low[idx] = min(low[idx], ord[to]);&#10;        }&#10;        is_art |= (par == -1 &amp;&amp; cnt &gt; 1);&#10;        if(is_art)&#10;            art.emplace_back(idx);&#10;    }&#10;&#10;    LowLink(vector&lt;vector&lt;int&gt;&gt;&amp; edges) :&#10;        edges(edges),&#10;        ord(edges.size(), -1),&#10;        low(edges.size(), 0),&#10;        k(0)&#10;    {&#10;        for(int i = 0; i &lt; edges.size(); ++i)&#10;            if(ord[i] == -1)&#10;                dfs(i, -1);&#10;        for(auto&amp; b : bridge)&#10;            b = make_pair(min(b.first, b.second), max(b.first, b.second));&#10;        sort(art.begin(), art.end());&#10;        sort(bridge.begin(), bridge.end());&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="matrix" value="// doc: https://shibh308.github.io/library/library/lib/classes/matrix.cpp.html&#10;template &lt;typename T&gt;&#10;struct Matrix{&#10;    int h, w;&#10;    vector&lt;T&gt; v;&#10;&#10;    Matrix() : h(1), w(1), v(1, 1){}&#10;    Matrix(int n){*this = makeUnit(n);}&#10;    Matrix(int h, int w) : h(h), w(w), v(h * w, 0){}&#10;&#10;    Matrix(vector&lt;vector&lt;T&gt;&gt; v_) : h(v_.size()), w(v_[0].size()), v(h * w){&#10;        for(int i = 0; i &lt; h; ++i)&#10;            for(int j = 0; j &lt; w; ++j)&#10;                v[i * w + j] = v_[i][j];&#10;    }&#10;&#10;    static Matrix makeUnit(int n){&#10;        Matrix mat(n, n);&#10;        for(int i = 0; i &lt; n; ++i)&#10;            mat.at(i, i) = 1;&#10;        return mat;&#10;    }&#10;&#10;    T&amp; at(int i, int j){&#10;        assert(0 &lt;= i &amp;&amp; i &lt;= h &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; w);&#10;        return v[i * w + j];&#10;    };&#10;&#10;    Matrix pow(i64 x){&#10;        assert(h == w);&#10;        auto mat = x &amp; 1 ? *this : makeUnit(h);&#10;        auto u = *this;&#10;        while(u = u * u, x &gt;&gt;= 1)&#10;            if(x &amp; 1)&#10;                mat *= u;&#10;        return mat;&#10;    }&#10;&#10;    Matrix&amp; operator+=(const Matrix&amp; mat){&#10;        assert(h == mat.h &amp;&amp; w == mat.w);&#10;        for(int i = 0; i &lt; h * w; ++i)&#10;            v[i] += mat.v[i];&#10;        return *this;&#10;    }&#10;&#10;    Matrix&amp; operator-=(const Matrix&amp; mat){&#10;        assert(h == mat.h &amp;&amp; w == mat.w);&#10;        for(int i = 0; i &lt; h * w; ++i)&#10;            v[i] -= mat.v[i];&#10;        return *this;&#10;    }&#10;&#10;    Matrix&amp; operator%=(const T mod){&#10;        for(int i = 0; i &lt; h * w; ++i)&#10;            v[i] %= mod;&#10;        return *this;&#10;    }&#10;&#10;    Matrix operator*(const Matrix&amp; mat){&#10;        assert(w == mat.h);&#10;        Matrix ret(h, mat.w);&#10;        for(int i = 0; i &lt; h; ++i)&#10;            for(int k = 0; k &lt; w; ++k)&#10;                for(int j = 0; j &lt; mat.w; ++j)&#10;                    ret.v[i * mat.w + j] += v[i * w + k] * mat.v[k * mat.w + j];&#10;        return ret;&#10;    }&#10;&#10;    Matrix operator+(const Matrix&amp; mat){return Matrix(*this) += mat;}&#10;    Matrix operator-(const Matrix&amp; mat){return Matrix(*this) -= mat;}&#10;    Matrix operator%(const T mod){return Matrix(*this) %= mod;}&#10;    Matrix&amp; operator*=(const Matrix&amp; mat){return *this = *this * mat;}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="memorypool" value="// doc: https://shibh308.github.io/library/library/lib/classes/memorypool.cpp.html&#10;template &lt;typename T&gt;&#10;struct MemoryPool{&#10;    int siz, idx;&#10;    stack&lt;int&gt; st;&#10;    vector&lt;T*&gt; pool;&#10;    struct Index{&#10;        int idx;&#10;        friend bool operator==(const Index&amp; a, const Index&amp; b){return a.idx == b.idx;}&#10;        friend bool operator!=(const Index&amp; a, const Index&amp; b){return a.idx != b.idx;}&#10;    };&#10;    MemoryPool() : siz(1), idx(0){}&#10;    void resize(){&#10;        pool.emplace_back(new T[siz]);&#10;        siz &lt;&lt;= 1;&#10;    }&#10;    Index alloc(){&#10;        if(!st.empty()){&#10;            int res = st.top();&#10;            st.pop();&#10;            return {res};&#10;        }&#10;        if(++idx == siz)&#10;            resize();&#10;        return {idx};&#10;    }&#10;    void free(Index x){st.push(x.idx);}&#10;    int used(){return idx - st.size();}&#10;&#10;    T&amp; operator[](Index x){return pool[31 - __builtin_clz(x.idx)][x.idx &amp; ~(1 &lt;&lt; (31 - __builtin_clz(x.idx)))];}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="memorypool_fixed" value="// doc: https://shibh308.github.io/library/library/lib/classes/memorypool_fixed.cpp.html&#10;template &lt;typename T, int SIZE = 1000000&gt;&#10;struct MemoryPool{&#10;    int idx;&#10;    stack&lt;int&gt; st;&#10;    T pool[SIZE];&#10;    struct Index{&#10;        int idx;&#10;        friend bool operator==(const Index&amp; a, const Index&amp; b){return a.idx == b.idx;}&#10;        friend bool operator!=(const Index&amp; a, const Index&amp; b){return a.idx != b.idx;}&#10;    };&#10;    MemoryPool() : idx(0){}&#10;    Index alloc(){&#10;        if(!st.empty()){&#10;            int res = st.top();&#10;            st.pop();&#10;            return {res};&#10;        }&#10;        assert(++idx != SIZE);&#10;        return {idx};&#10;    }&#10;    void free(Index x){st.push(x.idx);}&#10;    int used(){return idx - st.size();}&#10;&#10;    T&amp; operator[](Index x){return pool[x.idx];}&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="mo" value="// doc: https://shibh308.github.io/library/library/lib/classes/mo.cpp.html&#10;struct Mo{&#10;    int l, r;&#10;    function&lt;void(int)&gt; left_add, left_erase, right_add, right_erase;&#10;    Mo(function&lt;void(int)&gt; left_add, function&lt;void(int)&gt; left_erase,&#10;       function&lt;void(int)&gt; right_add, function&lt;void(int)&gt; right_erase,&#10;       int sl = 0, int sr = 0) :&#10;       l(sl), r(sr), left_add(left_add), left_erase(left_erase), right_add(right_add), right_erase(right_erase){}&#10;    void move(int next_l, int next_r){&#10;        for(int i = l; i &lt; next_l; ++i)&#10;            left_erase(i);&#10;        for(int i = l - 1; i &gt;= next_l; --i)&#10;            left_add(i);&#10;        for(int i = r; i &lt; next_r; ++i)&#10;            right_add(i);&#10;        for(int i = r - 1; i &gt;= next_r; --i)&#10;            right_erase(i);&#10;        l = next_l, r = next_r;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="modint" value="// doc: https://shibh308.github.io/library/library/lib/classes/modint.cpp.html&#10;template &lt;i64 mod = MOD&gt;&#10;struct ModInt{&#10;    i64 p;&#10;&#10;    ModInt() : p(0){}&#10;    ModInt(i64 x){p = x &gt;= 0 ? x % mod : x + (-x + mod - 1) / mod * mod;}&#10;&#10;    ModInt&amp; operator+=(const ModInt&amp; y){p = p + *y - ((p + *y) &gt;= mod ? mod : 0); return *this;}&#10;    ModInt&amp; operator-=(const ModInt&amp; y){p = p - *y + (p - *y &lt; 0 ? mod : 0); return *this;}&#10;    ModInt&amp; operator*=(const ModInt&amp; y){p = (p * *y) % mod; return *this;}&#10;    ModInt&amp; operator%=(const ModInt&amp; y){if(y)p %= *y; return *this;}&#10;&#10;    ModInt operator+(const ModInt&amp; y) const{ModInt x = *this; return x += y;}&#10;    ModInt operator-(const ModInt&amp; y) const{ModInt x = *this; return x -= y;}&#10;    ModInt operator*(const ModInt&amp; y) const{ModInt x = *this; return x *= y;}&#10;    ModInt operator%(const ModInt&amp; y) const{ModInt x = *this; return x %= y;}&#10;&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; stream, const ModInt&lt;mod&gt;&amp; x){&#10;        stream &lt;&lt; *x;&#10;        return stream;&#10;    }&#10;&#10;    friend ostream&amp; operator&gt;&gt;(ostream&amp; stream, const ModInt&lt;mod&gt;&amp; x){&#10;        stream &gt;&gt; *x;&#10;        return stream;&#10;    }&#10;&#10;    ModInt&amp; operator++(){p = (p + 1) % mod; return *this;}&#10;    ModInt&amp; operator--(){p = (p - 1 + mod) % mod; return *this;}&#10;&#10;    bool operator==(const ModInt&amp; y) const{return p == *y;}&#10;    bool operator!=(const ModInt&amp; y) const{return p != *y;}&#10;&#10;    const i64&amp; operator*() const{return p;}&#10;    i64&amp; operator*(){return p;}&#10;&#10;};&#10;&#10;using mint = ModInt&lt;&gt;;&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="persistentdynamiclazysegmenttree" value="// doc: https://shibh308.github.io/library/library/lib/classes/persistentdynamiclazysegmenttree.cpp.html&#10;template&lt;typename T, typename U&gt;&#10;struct Segtree{&#10;&#10;    struct SegNode{&#10;        T val;&#10;        U lazy;&#10;&#10;        shared_ptr&lt;SegNode&gt; l;&#10;        shared_ptr&lt;SegNode&gt; r;&#10;        SegNode(T val, U lazy) : val(val), lazy(lazy), l(nullptr), r(nullptr){}&#10;    };&#10;&#10;    i64 n;&#10;    shared_ptr&lt;SegNode&gt; nil;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;    T op_t;&#10;    U op_u;&#10;&#10;    shared_ptr&lt;SegNode&gt; root;&#10;&#10;    Segtree(int n_, function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t, U op_u) : f(f), g(g), h(h), op_t(op_t), op_u(op_u){&#10;        for(n = 1; n &lt; n_; n &lt;&lt;= 1);&#10;        root = make_shared&lt;SegNode&gt;(op_t, op_u);&#10;    }&#10;&#10;    void eval(shared_ptr&lt;SegNode&gt; node, i64 len, bool make = true){&#10;        node-&gt;val = g(node-&gt;val, node-&gt;lazy, len);&#10;        if(make){&#10;            node-&gt;l = node-&gt;l ? make_shared&lt;SegNode&gt;(*node-&gt;l) : make_shared&lt;SegNode&gt;(op_t, op_u);&#10;            node-&gt;r = node-&gt;r ? make_shared&lt;SegNode&gt;(*node-&gt;r) : make_shared&lt;SegNode&gt;(op_t, op_u);&#10;        }&#10;        node-&gt;l-&gt;lazy = h(node-&gt;l-&gt;lazy, node-&gt;lazy);&#10;        node-&gt;r-&gt;lazy = h(node-&gt;r-&gt;lazy, node-&gt;lazy);&#10;        node-&gt;lazy = op_u;&#10;    }&#10;&#10;    // if root -&gt; make new node      -&gt; eval(make child)&#10;    void update(i64 x, i64 y, U val, shared_ptr&lt;SegNode&gt; node = nullptr, i64 l = -1, i64 r = -1){&#10;        bool root_flag = (node == nullptr);&#10;        if(root_flag){&#10;            root = make_shared&lt;SegNode&gt;(*root);&#10;            node = root;&#10;        }&#10;        if(l == -1){&#10;            l = 0;&#10;            r = n;&#10;        }&#10;        eval(node, r - l);&#10;        if(r &lt;= x || y &lt;= l)&#10;            return ;&#10;        if(x &lt;= l &amp;&amp; r &lt;= y){&#10;            node-&gt;lazy = h(node-&gt;lazy, val);&#10;            eval(node, r - l, false);&#10;        }else{&#10;            eval(node, r - l);&#10;            i64 mid = (l + r) &gt;&gt; 1;&#10;            update(x, y, val, node-&gt;l, l, mid);&#10;            update(x, y, val, node-&gt;r, mid, r);&#10;            node-&gt;val = f(node-&gt;l-&gt;val, node-&gt;r-&gt;val);&#10;        }&#10;        return ;&#10;    }&#10;&#10;    T get(i64 x, i64 y, shared_ptr&lt;SegNode&gt; node = nullptr, i64 l = -1, i64 r = -1){&#10;        bool root_flag = (node == nullptr);&#10;        if(root_flag){&#10;            root = make_shared&lt;SegNode&gt;(*root);&#10;            node = root;&#10;        }&#10;        if(l == -1){&#10;            l = 0;&#10;            r = n;&#10;        }&#10;&#10;        if(r &lt;= x || y &lt;= l)&#10;            return op_t;&#10;        eval(node, r - l);&#10;        if(x &lt;= l &amp;&amp; r &lt;= y)&#10;            return node-&gt;val;&#10;&#10;        i64 val_l = op_t, val_r = op_t;&#10;        i64 mid = (l + r) &gt;&gt; 1;&#10;&#10;        if(node-&gt;l)&#10;            val_l = get(x, y, node-&gt;l, l, mid);&#10;        if(node-&gt;r)&#10;            val_r = get(x, y, node-&gt;r, mid, r);&#10;&#10;        return f(val_l, val_r);&#10;    }&#10;&#10;};&#10;&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="persistentskewbinarylist" value="// doc: https://shibh308.github.io/library/library/lib/classes/persistentskewbinarylist.cpp.html&#10;template&lt;typename T&gt;&#10;struct PersistentSkewBinaryList{&#10;    using ListPtr = const PersistentSkewBinaryList&lt;T&gt;*;&#10;&#10;    struct Node{&#10;        Node *l, *r;&#10;        T x;&#10;        int dep;&#10;        Node(T x) : l(nullptr), r(nullptr), x(x), dep(1){}&#10;        Node(T x, Node *l, Node *r) : l(l), r(r), x(x), dep(l-&gt;dep + 1){}&#10;    };&#10;&#10;    long long siz;&#10;    ListPtr nex;&#10;    Node* node;&#10;    PersistentSkewBinaryList() : nex(nullptr), siz(0), node(nullptr){}&#10;    PersistentSkewBinaryList(Node* node, ListPtr nex) : nex(nex), siz((1LL &lt;&lt; node-&gt;dep) - 1 + (nex == nullptr ? 0 : nex-&gt;siz)), node(node){}&#10;    PersistentSkewBinaryList(T val, ListPtr nex = nullptr) : nex(nex), siz(1 + (nex == nullptr ? 0 : nex-&gt;siz)), node(new Node(val)){}&#10;    ListPtr push_front(T val) const{&#10;        if(siz == 0){&#10;            return new PersistentSkewBinaryList&lt;T&gt;(val, nullptr);&#10;        }&#10;        else if(nex != nullptr &amp;&amp; node-&gt;dep == nex-&gt;node-&gt;dep){&#10;            Node* new_node = new Node(val, node, nex-&gt;node);&#10;            return new PersistentSkewBinaryList&lt;T&gt;(new_node, nex-&gt;nex);&#10;        }&#10;        else{&#10;            return new PersistentSkewBinaryList&lt;T&gt;(val, this);&#10;        }&#10;    }&#10;    T access(Node* x, long long k) const{&#10;        long long ch_siz = (1LL &lt;&lt; (x-&gt;dep - 1)) - 1;&#10;        if(k == 0)&#10;            return x-&gt;x;&#10;        else if(k - 1 &lt; ch_siz)&#10;            return access(x-&gt;l, k - 1);&#10;        else&#10;            return access(x-&gt;r, k - 1 - ch_siz);&#10;    }&#10;    T access(long long k) const{&#10;        long long node_siz = (1LL &lt;&lt; node-&gt;dep) - 1;&#10;        if(k &lt; node_siz)&#10;            return access(node, k);&#10;        else&#10;            return nex-&gt;access(k - node_siz);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="persistentunionfind" value="// doc: https://shibh308.github.io/library/library/lib/classes/persistentunionfind.cpp.html&#10;struct UnionFind{&#10;    vector&lt;int&gt; par, time;&#10;    int count;&#10;    UnionFind(int n) : par(n, -1), time(n, MOD), count(0){}&#10;    // [0, t]の間に併合されたかどうか&#10;    int Find(int x, int t){return par[x] &lt; 0 || time[x] &gt; t ? x : Find(par[x], t);}&#10;    int Size(int x){return par[x] &lt; 0 ? -par[x] : Size(par[x]);}&#10;    // 現在のcount+1のタイミングで併合された事にする&#10;    // Unite失敗時もcountが増えるので注意&#10;    int Unite(int x, int y){&#10;        x = Find(x, MOD + 1);&#10;        y = Find(y, MOD + 1);&#10;        ++count;&#10;        if(x == y)&#10;            return 0;&#10;        if(par[x] &gt; par[y])&#10;            swap(x, y);&#10;        par[x] += par[y];&#10;        par[y] = x;&#10;        time[y] = count;&#10;        return count;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="primaldual" value="// doc: https://shibh308.github.io/library/library/lib/classes/primaldual.cpp.html&#10;template &lt;typename T, typename U&gt;&#10;struct PrimalDual{&#10;    struct Edge{&#10;        int to, rev;&#10;        U cap;&#10;        T cost;&#10;        Edge(int to, U cap, T cost, int rev) :&#10;            to(to), rev(rev), cap(cap), cost(cost){}&#10;    };&#10;    vector&lt;vector&lt;Edge&gt;&gt; edges;&#10;    T _inf;&#10;    vector&lt;T&gt; potential, min_cost;&#10;    vector&lt;int&gt; prev_v, prev_e;&#10;&#10;    PrimalDual(int n) : edges(n), _inf(numeric_limits&lt;T&gt;::max()){}&#10;&#10;    void add(int from, int to, U cap, T cost){&#10;        edges[from].emplace_back(to, cap, cost, static_cast&lt;int&gt;(edges[to].size()));&#10;        edges[to].emplace_back(from, 0, -cost, static_cast&lt;int&gt;(edges[from].size()) - 1);&#10;    }&#10;&#10;    T solve(int s, int t, U flow){&#10;        int n = edges.size();&#10;        T ret = 0;&#10;        priority_queue&lt;pair&lt;T,int&gt;, vector&lt;pair&lt;T,int&gt;&gt;, greater&lt;pair&lt;T,int&gt;&gt;&gt; que;&#10;        potential.assign(n, 0);&#10;        prev_v.assign(n, -1);&#10;        prev_e.assign(n, -1);&#10;        while(flow &gt; 0){&#10;            min_cost.assign(n, _inf);&#10;            que.emplace(0, s);&#10;            min_cost[s] = 0;&#10;            while(!que.empty()){&#10;                T fl;&#10;                int pos;&#10;                tie(fl, pos) = que.top();&#10;                que.pop();&#10;                if(min_cost[pos] != fl)&#10;                    continue;&#10;                for(int i = 0; i &lt; edges[pos].size(); ++i){&#10;                    auto&amp; ed = edges[pos][i];&#10;                    T nex = fl + ed.cost + potential[pos] - potential[ed.to];&#10;                    if(ed.cap &gt; 0 &amp;&amp; min_cost[ed.to] &gt; nex){&#10;                        min_cost[ed.to] = nex;&#10;                        prev_v[ed.to] = pos;&#10;                        prev_e[ed.to] = i;&#10;                        que.emplace(min_cost[ed.to], ed.to);&#10;                    }&#10;                }&#10;            }&#10;            if(min_cost[t] == _inf)&#10;                return -1;&#10;            for(int i = 0; i &lt; n; ++i)&#10;                potential[i] += min_cost[i];&#10;            T add_flow = flow;&#10;            for(int x = t; x != s; x = prev_v[x])&#10;                add_flow = min(add_flow, edges[prev_v[x]][prev_e[x]].cap);&#10;            flow -= add_flow;&#10;            ret += add_flow * potential[t];&#10;            for(int x = t; x != s; x = prev_v[x]){&#10;                auto&amp; ed = edges[prev_v[x]][prev_e[x]];&#10;                ed.cap -= add_flow;&#10;                edges[x][ed.rev].cap += add_flow;&#10;            }&#10;        }&#10;        return ret;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rectanglesum" value="// doc: https://shibh308.github.io/library/library/lib/classes/rectanglesum.cpp.html&#10;struct RectangleSum{//O(HW)で初期化してO(1)で長方形の和を出す(半開区間)&#10;    vector&lt;vector&lt;i64&gt;&gt; sum;&#10;    int h, w;&#10;    RectangleSum(vector&lt;vector&lt;i64&gt;&gt;&amp; v) :&#10;        h(v.size()),&#10;        w(v[0].size()),&#10;        sum(v)&#10;    {}&#10;&#10;    // 半開区間で設定する事に注意する&#10;    void set(int sx, int sy, int ex, int ey, i64 val){&#10;        sum[sx][sy] += val;&#10;        sum[sx][ey] -= val;&#10;        sum[ex][sy] -= val;&#10;        sum[ex][ey] += val;&#10;    }&#10;&#10;    void run(){&#10;&#10;        for(int i = 0; i &lt; h; ++i)&#10;            for(int j = 0; j &lt; w + 1; ++j)&#10;                sum[i + 1][j] += sum[i][j];&#10;&#10;        for(int i = 0; i &lt; h + 1; ++i)&#10;            for(int j = 0; j &lt; w; ++j)&#10;                sum[i][j + 1] += sum[i][j];&#10;    }&#10;&#10;    i64 getSum(int sx, int sy, int ex, int ey){&#10;        return sum[ex][ey] + sum[sx][sy] - sum[sx][ey] - sum[ex][sy];&#10;    }&#10;};&#10;&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="redblacktree" value="// doc: https://shibh308.github.io/library/library/lib/classes/redblacktree.cpp.html&#10;// merge/split ベースの赤黒木(葉木)&#10;template &lt;typename T&gt;&#10;struct RedBlackTree{&#10;&#10;    struct Node;&#10;    using Index = typename MemoryPool&lt;Node&gt;::Index;&#10;&#10;    struct Node{&#10;        int siz, level;&#10;        T sum;&#10;        bool red;&#10;        typename MemoryPool&lt;Node&gt;::Index l, r;&#10;        Node(){}&#10;        Node(T val, bool red, bool leaf, int li = -1, int ri = -1) : sum(val), siz(leaf), level(0), red(red){&#10;            l = {li};&#10;            r = {ri};&#10;        }&#10;    };&#10;&#10;    MemoryPool&lt;Node&gt; pool;&#10;    Index nil;&#10;    function&lt;T(T, T)&gt; f;&#10;    T op;&#10;    RedBlackTree(function&lt;T(T, T)&gt; f = [](auto x, auto y){return x + y;}, T op = T()) : f(f), op(op){&#10;        nil = pool.alloc();&#10;        pool[nil] = Node(op, false, false);&#10;        pool[nil].l = pool[nil].r = nil;&#10;    }&#10;&#10;    Index build(vector&lt;T&gt;&amp; a){&#10;        nil = pool.alloc();&#10;        pool[nil] = Node(op, false, false);&#10;        pool[nil].l = pool[nil].r = nil;&#10;        int siz = a.size();&#10;        vector&lt;Index&gt; v(siz);&#10;        for(int i = 0; i &lt; siz; ++i)&#10;            v[i] = make(a[i]);&#10;        while(siz != 1){&#10;            int nex_siz = (siz + 1) &gt;&gt; 1;&#10;            vector&lt;Index&gt; nex(nex_siz);&#10;            for(int i = 0; i &lt; (siz &gt;&gt; 1); ++i)&#10;                nex[i] = merge(v[2 * i], v[2 * i + 1]);&#10;            if(siz &amp; 1)&#10;                nex.back() = v.back();&#10;            siz = nex_siz;&#10;            v = move(nex);&#10;        }&#10;        return v[0];&#10;    }&#10;&#10;    void clear(){&#10;        while(!pool.st.empty())&#10;            pool.st.pop();&#10;        for(int i = 1; i &lt;= pool.idx; ++i)&#10;            pool.st.push(i);&#10;    }&#10;&#10;    Index index(int x){return {x};}&#10;&#10;&#10;    T get_val(Index pi, int k){&#10;        pi = access(pi, k);&#10;		return get(pi).sum;&#10;    }&#10;&#10;    void update(Index pi){&#10;        if(pi == nil)&#10;            return;&#10;        auto&amp; p = get(pi);&#10;        auto&amp; l = get(p.l);&#10;        auto&amp; r = get(p.r);&#10;        p.siz = l.siz + r.siz;&#10;        if(p.l != nil || p.r != nil)&#10;            p.sum = f(l.sum, r.sum);&#10;        p.level = l.level + !l.red;&#10;        assert(p.level == r.level + !r.red);&#10;    }&#10;&#10;    Index make(T val){&#10;        Index idx = pool.alloc();&#10;        pool[idx] = Node(val, false, true, nil.idx, nil.idx);&#10;        pool[idx].level = 1;&#10;        return idx;&#10;    }&#10;&#10;    Index mergeSub(Index ai, Index bi){&#10;        auto&amp; a = get(ai);&#10;        auto&amp; b = get(bi);&#10;        assert(ai != nil &amp;&amp; bi != nil);&#10;        if(a.level &lt; b.level){&#10;            Index ci = mergeSub(ai, b.l);&#10;            auto&amp; c = get(ci);&#10;            if(!b.red &amp;&amp; c.red &amp;&amp; get(c.l).red){&#10;                if(!get(b.r).red){&#10;                    b.l = c.l;&#10;                    c.l = c.r;&#10;                    c.r = b.r;&#10;                    b.r = ci;&#10;                    update(ci);&#10;                    update(bi);&#10;                    return bi;&#10;                }&#10;                else{&#10;                    b.l = ci;&#10;                    b.red ^= 1;&#10;                    get(b.l).red ^= 1;&#10;                    get(b.r).red ^= 1;&#10;                    update(bi);&#10;                    return bi;&#10;                }&#10;            }&#10;            b.l = ci;&#10;            update(bi);&#10;            return bi;&#10;        }&#10;        else if(a.level &gt; b.level){&#10;            Index ci = mergeSub(a.r, bi);&#10;            auto&amp; c = get(ci);&#10;            if(!a.red &amp;&amp; c.red &amp;&amp; get(c.r).red){&#10;                if(!get(a.l).red){&#10;                    a.r = c.r;&#10;                    c.r = c.l;&#10;                    c.l = a.l;&#10;                    a.l = ci;&#10;                    update(ci);&#10;                    update(ai);&#10;                    return ai;&#10;                }&#10;                else{&#10;                    a.r = ci;&#10;                    a.red ^= 1;&#10;                    get(a.l).red ^= 1;&#10;                    get(a.r).red ^= 1;&#10;                    update(ai);&#10;                    return ai;&#10;                }&#10;            }&#10;            a.r = ci;&#10;            update(ai);&#10;            return ai;&#10;        }&#10;        else{&#10;            a.red = false;&#10;            b.red = false;&#10;            Index d = pool.alloc();&#10;            get(d) = Node(op, true, false, ai.idx, bi.idx);&#10;            update(d);&#10;            return d;&#10;        }&#10;    }&#10;&#10;    Index merge(Index ai, Index bi){&#10;        if(ai == nil)&#10;            return bi;&#10;        if(bi == nil)&#10;            return ai;&#10;        Index ci = mergeSub(ai, bi);&#10;        get(ci).red = false;&#10;        return ci;&#10;    }&#10;&#10;    pair&lt;Index, Index&gt; split(Index ai, int k){&#10;        if(ai == nil)&#10;            return make_pair(nil, nil);&#10;        auto&amp; a = get(ai);&#10;        if(k == 0)&#10;            return make_pair(nil, ai);&#10;        if(k == a.siz)&#10;            return make_pair(ai, nil);&#10;        Index li = a.l;&#10;        Index ri = a.r;&#10;        auto&amp; l = get(li);&#10;        pool.free(ai);&#10;        if(k &lt; l.siz){&#10;            auto res = split(li, k);&#10;            return make_pair(res.first, merge(res.second, ri));&#10;        }&#10;        else if(k &gt; get(a.l).siz){&#10;            auto res = split(ri, k - l.siz);&#10;            return make_pair(merge(li, res.first), res.second);&#10;        }&#10;        else{&#10;            return make_pair(li, ri);&#10;        }&#10;    }&#10;&#10;    pair&lt;T, Index&gt; range_get(Index pi, int l, int r){&#10;        auto res = split(pi, r);&#10;        auto res2 = split(res.first, l);&#10;        T val = get(res2.second).sum;&#10;        return make_pair(val, merge(merge(res2.first, res2.second), res.second));&#10;    }&#10;&#10;    Index insert(Index pi, int k, T val){&#10;        auto res = split(pi, k);&#10;        return merge(res.first, merge(make(val), res.second));&#10;    }&#10;&#10;    Index erase(Index pi, int k){&#10;        auto res = split(pi, k + 1);&#10;        auto res2 = split(res.first, k);&#10;        pool.free(res2.second);&#10;        return merge(res2.first, res.second);&#10;    }&#10;&#10;    Index access(Index pi, int k){&#10;        while(get(pi).l != nil || get(pi).r != nil){&#10;            auto&amp; p = get(pi);&#10;            assert(p.l != nil &amp;&amp; p.r != nil);&#10;            if(get(p.l).siz &lt;= k){&#10;                k -= get(p.l).siz;&#10;                pi = p.r;&#10;            }&#10;            else{&#10;                pi = p.l;&#10;            }&#10;        }&#10;        return pi;&#10;    }&#10;&#10;    void set(Index pi, int k, T val, function&lt;T(T, T)&gt; g = [](T x, T y){return y;}){&#10;        stack&lt;Index&gt; st;&#10;        while(get(pi).l != nil || get(pi).r != nil){&#10;            auto&amp; p = get(pi);&#10;            st.push(pi);&#10;            assert(p.l != nil &amp;&amp; p.r != nil);&#10;            if(get(p.l).siz &lt;= k){&#10;                k -= get(p.l).siz;&#10;                pi = p.r;&#10;            }&#10;            else{&#10;                pi = p.l;&#10;            }&#10;        }&#10;        auto&amp; p = get(pi);&#10;        p.sum = g(p.sum, val);&#10;        while(!st.empty()){&#10;            update(st.top());&#10;            st.pop();&#10;        }&#10;    }&#10;&#10;    Node&amp; get(Index k){return pool[k];}&#10;    Node&amp; operator[](Index k){return pool[k];}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="redblacktree_lazy" value="// doc: https://shibh308.github.io/library/library/lib/classes/redblacktree_lazy.cpp.html&#10;template &lt;typename T, typename U&gt;&#10;struct RedBlackTree{&#10;&#10;    struct Node;&#10;    using Index = typename MemoryPool&lt;Node&gt;::Index;&#10;&#10;    struct Node{&#10;        int siz, level;&#10;        T sum;&#10;        U lazy;&#10;        bool red;&#10;        typename MemoryPool&lt;Node&gt;::Index l, r;&#10;        Node(){}&#10;        Node(T val, U lazy, bool red, bool leaf, int li = -1, int ri = -1) : sum(val), lazy(lazy), siz(leaf), level(0), red(red){&#10;            l = {li};&#10;            r = {ri};&#10;        }&#10;    };&#10;&#10;    MemoryPool&lt;Node&gt; pool;&#10;    Index nil;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;T(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;    T op_t;&#10;    U op_u;&#10;    RedBlackTree(function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t, U op_u) : f(f), g(g), h(h), op_t(op_t), op_u(op_u){&#10;        nil = pool.alloc();&#10;        pool[nil] = Node(op_t, op_u, false, false);&#10;        pool[nil].l = pool[nil].r = nil;&#10;    }&#10;&#10;    Index build(vector&lt;T&gt;&amp; a){&#10;        nil = pool.alloc();&#10;        pool[nil] = Node(op_t, op_u, false, false);&#10;        pool[nil].l = pool[nil].r = nil;&#10;        int siz = a.size();&#10;        vector&lt;Index&gt; v(siz);&#10;        for(int i = 0; i &lt; siz; ++i)&#10;            v[i] = make(a[i]);&#10;        while(siz != 1){&#10;            int nex_siz = (siz + 1) &gt;&gt; 1;&#10;            vector&lt;Index&gt; nex(nex_siz);&#10;            for(int i = 0; i &lt; (siz &gt;&gt; 1); ++i)&#10;                nex[i] = merge(v[2 * i], v[2 * i + 1]);&#10;            if(siz &amp; 1)&#10;                nex.back() = v.back();&#10;            siz = nex_siz;&#10;            v = move(nex);&#10;        }&#10;        return v[0];&#10;    }&#10;&#10;    void clear(){&#10;        while(!pool.st.empty())&#10;            pool.st.pop();&#10;        for(int i = 1; i &lt;= pool.idx; ++i)&#10;            pool.st.push(i);&#10;    }&#10;&#10;&#10;    Index index(int x){return {x};}&#10;&#10;    T get_val(Index pi){&#10;        auto&amp; p = get(pi);&#10;        return g(p.sum, p.lazy, p.siz);&#10;    }&#10;&#10;    T get_val(Index pi, int k){&#10;        pi = access(pi, k);&#10;        auto&amp; p = get(pi);&#10;        return g(p.sum, p.lazy, p.siz);&#10;    }&#10;&#10;    void eval(Index pi){&#10;        if(pi == nil)&#10;            return;&#10;        auto&amp; p = get(pi);&#10;        if(p.lazy == op_u)&#10;            return;&#10;        if(p.l != nil){&#10;            auto&amp; l = get(p.l);&#10;            l.lazy = h(l.lazy, p.lazy);&#10;            auto&amp; r = get(p.r);&#10;            r.lazy = h(r.lazy, p.lazy);&#10;        }&#10;        p.sum = get_val(pi);&#10;        p.lazy = op_u;&#10;    }&#10;&#10;    void update(Index pi){&#10;        if(pi == nil)&#10;            return;&#10;        auto&amp; p = get(pi);&#10;        auto&amp; l = get(p.l);&#10;        auto&amp; r = get(p.r);&#10;        p.siz = l.siz + r.siz;&#10;        if(p.l != nil || p.r != nil)&#10;            p.sum = f(get_val(p.l), get_val(p.r));&#10;        p.level = l.level + !l.red;&#10;        assert(p.level == r.level + !r.red);&#10;    }&#10;&#10;    Index make(T val){&#10;        Index idx = pool.alloc();&#10;        pool[idx] = Node(val, op_u, false, true, nil.idx, nil.idx);&#10;        pool[idx].level = 1;&#10;        return idx;&#10;    }&#10;&#10;    Index mergeSub(Index ai, Index bi){&#10;        eval(ai);&#10;        eval(bi);&#10;        auto&amp; a = get(ai);&#10;        auto&amp; b = get(bi);&#10;        assert(ai != nil &amp;&amp; bi != nil);&#10;        if(a.level &lt; b.level){&#10;            Index ci = mergeSub(ai, b.l);&#10;            auto&amp; c = get(ci);&#10;            if(!b.red &amp;&amp; c.red &amp;&amp; get(c.l).red){&#10;                if(!get(b.r).red){&#10;                    b.l = c.l;&#10;                    c.l = c.r;&#10;                    c.r = b.r;&#10;                    b.r = ci;&#10;                    update(ci);&#10;                    update(bi);&#10;                    return bi;&#10;                }&#10;                else{&#10;                    b.l = ci;&#10;                    b.red ^= 1;&#10;                    get(b.l).red ^= 1;&#10;                    get(b.r).red ^= 1;&#10;                    update(bi);&#10;                    return bi;&#10;                }&#10;            }&#10;            b.l = ci;&#10;            update(bi);&#10;            return bi;&#10;        }&#10;        else if(a.level &gt; b.level){&#10;            Index ci = mergeSub(a.r, bi);&#10;            auto&amp; c = get(ci);&#10;            if(!a.red &amp;&amp; c.red &amp;&amp; get(c.r).red){&#10;                if(!get(a.l).red){&#10;                    a.r = c.r;&#10;                    c.r = c.l;&#10;                    c.l = a.l;&#10;                    a.l = ci;&#10;                    update(ci);&#10;                    update(ai);&#10;                    return ai;&#10;                }&#10;                else{&#10;                    a.r = ci;&#10;                    a.red ^= 1;&#10;                    get(a.l).red ^= 1;&#10;                    get(a.r).red ^= 1;&#10;                    update(ai);&#10;                    return ai;&#10;                }&#10;            }&#10;            a.r = ci;&#10;            update(ai);&#10;            return ai;&#10;        }&#10;        else{&#10;            a.red = false;&#10;            b.red = false;&#10;            Index d = pool.alloc();&#10;            get(d) = Node(op_t, op_u, true, false, ai.idx, bi.idx);&#10;            update(d);&#10;            return d;&#10;        }&#10;    }&#10;&#10;    Index merge(Index ai, Index bi){&#10;        if(ai == nil)&#10;            return bi;&#10;        if(bi == nil)&#10;            return ai;&#10;        Index ci = mergeSub(ai, bi);&#10;        get(ci).red = false;&#10;        return ci;&#10;    }&#10;&#10;    pair&lt;Index, Index&gt; split(Index ai, int k){&#10;        if(ai == nil)&#10;            return make_pair(nil, nil);&#10;        eval(ai);&#10;        auto&amp; a = get(ai);&#10;        if(k == 0)&#10;            return make_pair(nil, ai);&#10;        if(k == a.siz)&#10;            return make_pair(ai, nil);&#10;        Index li = a.l;&#10;        Index ri = a.r;&#10;        auto&amp; l = get(li);&#10;        pool.free(ai);&#10;        if(k &lt; l.siz){&#10;            auto res = split(li, k);&#10;            return make_pair(res.first, merge(res.second, ri));&#10;        }&#10;        else if(k &gt; get(a.l).siz){&#10;            auto res = split(ri, k - l.siz);&#10;            return make_pair(merge(li, res.first), res.second);&#10;        }&#10;        else{&#10;            return make_pair(li, ri);&#10;        }&#10;    }&#10;&#10;    pair&lt;T, Index&gt; range_get(Index pi, int l, int r){&#10;        auto res = split(pi, r);&#10;        auto res2 = split(res.first, l);&#10;        T val = get_val(res2.second);&#10;        return make_pair(val, merge(merge(res2.first, res2.second), res.second));&#10;    }&#10;&#10;    Index range_update(Index pi, int l, int r, U val){&#10;        if(l == r)&#10;            return pi;&#10;        auto res = split(pi, r);&#10;        auto res2 = split(res.first, l);&#10;        auto&amp; mid = get(res2.second);&#10;        mid.lazy = h(mid.lazy, val);&#10;        eval(res2.second);&#10;        return merge(merge(res2.first, res2.second), res.second);&#10;    }&#10;&#10;    Index insert(Index pi, int k, T val){&#10;        auto res = split(pi, k);&#10;        return merge(res.first, merge(make(val), res.second));&#10;    }&#10;&#10;    Index erase(Index pi, int k){&#10;        auto res = split(pi, k + 1);&#10;        auto res2 = split(res.first, k);&#10;        pool.free(res2.second);&#10;        return merge(res2.first, res.second);&#10;    }&#10;&#10;    Index access(Index pi, int k){&#10;        while(get(pi).l != nil || get(pi).r != nil){&#10;            eval(pi);&#10;            auto&amp; p = get(pi);&#10;            assert(p.l != nil &amp;&amp; p.r != nil);&#10;            if(get(p.l).siz &lt;= k){&#10;                k -= get(p.l).siz;&#10;                pi = p.r;&#10;            }&#10;            else{&#10;                pi = p.l;&#10;            }&#10;        }&#10;        return pi;&#10;    }&#10;&#10;    void set(Index pi, int k, T val, function&lt;T(T, T)&gt; af = [](T x, T y){return y;}){&#10;        stack&lt;Index&gt; st;&#10;        while(get(pi).l != nil || get(pi).r != nil){&#10;            eval(pi);&#10;            auto&amp; p = get(pi);&#10;            st.push(pi);&#10;            assert(p.l != nil &amp;&amp; p.r != nil);&#10;            if(get(p.l).siz &lt;= k){&#10;                k -= get(p.l).siz;&#10;                pi = p.r;&#10;            }&#10;            else{&#10;                pi = p.l;&#10;            }&#10;        }&#10;        auto&amp; p = get(pi);&#10;        eval(pi);&#10;        p.sum = af(p.sum, val);&#10;        while(!st.empty()){&#10;            update(st.top());&#10;            st.pop();&#10;        }&#10;    }&#10;&#10;    Node&amp; get(Index k){return pool[k];}&#10;    Node&amp; operator[](Index k){return pool[k];}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="redblacktree_persistent" value="// doc: https://shibh308.github.io/library/library/lib/classes/redblacktree_persistent.cpp.html&#10;// verify: https://atcoder.jp/contests/joisc2012/submissions/12202620/&#10;template &lt;typename T&gt;&#10;struct RedBlackTree{&#10;&#10;    struct Node;&#10;    using Index = typename MemoryPool&lt;Node&gt;::Index;&#10;&#10;    struct Node{&#10;        int siz, level;&#10;        T sum;&#10;        bool red;&#10;        typename MemoryPool&lt;Node&gt;::Index l, r;&#10;        Node(){}&#10;        Node(T val, bool red, bool leaf, int li = -1, int ri = -1) : sum(val), siz(leaf), level(0), red(red){&#10;            l = {li};&#10;            r = {ri};&#10;        }&#10;        Node(T val, bool red, bool leaf, Index l, Index r) : sum(val), siz(leaf), level(0), red(red), l(l), r(r){}&#10;    };&#10;&#10;    MemoryPool&lt;Node&gt; pool;&#10;    Index nil;&#10;    function&lt;T(T, T)&gt; f;&#10;    T op;&#10;    RedBlackTree(function&lt;T(T, T)&gt; f = [](auto x, auto y){return x + y;}, T op = T()) : f(f), op(op){&#10;        nil = pool.alloc();&#10;        pool[nil] = Node(op, false, false);&#10;        pool[nil].l = pool[nil].r = nil;&#10;    }&#10;&#10;    Index build(vector&lt;T&gt;&amp; a){&#10;        nil = pool.alloc();&#10;        pool[nil] = Node(op, false, false);&#10;        pool[nil].l = pool[nil].r = nil;&#10;        int siz = a.size();&#10;        vector&lt;Index&gt; v(siz);&#10;        for(int i = 0; i &lt; siz; ++i)&#10;            v[i] = make(a[i]);&#10;        while(siz != 1){&#10;            int nex_siz = (siz + 1) &gt;&gt; 1;&#10;            vector&lt;Index&gt; nex(nex_siz);&#10;            for(int i = 0; i &lt; (siz &gt;&gt; 1); ++i)&#10;                nex[i] = merge(v[2 * i], v[2 * i + 1]);&#10;            if(siz &amp; 1)&#10;                nex.back() = v.back();&#10;            siz = nex_siz;&#10;            v = move(nex);&#10;        }&#10;        return v[0];&#10;    }&#10;&#10;    void clear(){&#10;        while(!pool.st.empty())&#10;            pool.st.pop();&#10;        for(int i = 1; i &lt;= pool.idx; ++i)&#10;            pool.st.push(i);&#10;    }&#10;&#10;    Index index(int x){return {x};}&#10;&#10;    T get_val(Index pi, int k){&#10;        pi = access(pi, k);&#10;        return get(pi).sum;&#10;    }&#10;&#10;    Index make(T val){&#10;        Index idx = pool.alloc();&#10;        pool[idx] = Node(val, false, true, nil.idx, nil.idx);&#10;        pool[idx].level = 1;&#10;        return idx;&#10;    }&#10;&#10;    Index makeInternal(Index l, Index r, bool red){&#10;        auto idx = pool.alloc();&#10;        pool[idx] = Node(op, red, false, l, r);&#10;        pool[idx].sum = f(pool[l].sum, pool[r].sum);&#10;        pool[idx].siz = pool[l].siz + pool[r].siz;&#10;        pool[idx].level = pool[l].level + !pool[l].red;&#10;        return idx;&#10;    }&#10;&#10;    Index makeLeaf(T val, bool red){&#10;        auto idx = pool.alloc();&#10;        pool[idx] = Node(val, red, true);&#10;        pool[idx].l = pool[idx].r = nil;&#10;        pool[idx].level = 1;&#10;        return idx;&#10;    }&#10;&#10;    Index mergeSub(Index ai, Index bi){&#10;        auto&amp; a = get(ai);&#10;        auto&amp; b = get(bi);&#10;        assert(ai != nil &amp;&amp; bi != nil);&#10;        if(a.level &lt; b.level){&#10;            Index ci = mergeSub(ai, b.l);&#10;            auto&amp; c = get(ci);&#10;            if(!b.red &amp;&amp; c.red &amp;&amp; get(c.l).red){&#10;                if(!get(b.r).red)&#10;                    return makeInternal(c.l, makeInternal(c.r, b.r, true), false);&#10;                else&#10;                    return makeInternal(makeInternal(c.l, c.r, false), makeInternal(get(b.r).l, get(b.r).r, false), true);&#10;            }&#10;            return makeInternal(ci, b.r, b.red);&#10;        }&#10;        else if(a.level &gt; b.level){&#10;            Index ci = mergeSub(a.r, bi);&#10;            auto&amp; c = get(ci);&#10;            if(!a.red &amp;&amp; c.red &amp;&amp; get(c.r).red){&#10;                if(!get(a.l).red)&#10;                    return makeInternal(makeInternal(a.l, c.l, true), c.r, false);&#10;                else&#10;                    return makeInternal(makeInternal(get(a.l).l, get(a.l).r, false), makeInternal(c.l, c.r, false), true);&#10;            }&#10;            return makeInternal(a.l, ci, a.red);&#10;        }&#10;        else{&#10;            if(a.red)&#10;                ai = makeInternal(a.l, a.r, false);&#10;            if(b.red)&#10;                bi = makeInternal(b.l, b.r, false);&#10;            return makeInternal(ai, bi, true);&#10;        }&#10;    }&#10;&#10;    Index merge(Index ai, Index bi){&#10;        if(ai == nil)&#10;            return bi;&#10;        if(bi == nil)&#10;            return ai;&#10;        Index ci = mergeSub(ai, bi);&#10;        auto&amp; c = get(ci);&#10;        if(c.red){&#10;            pool.free(ci);&#10;            return makeInternal(c.l, c.r, false);&#10;        }&#10;        return ci;&#10;    }&#10;&#10;    pair&lt;Index, Index&gt; split(Index ai, int k){&#10;        if(ai == nil)&#10;            return make_pair(nil, nil);&#10;        auto&amp; a = get(ai);&#10;        if(k == 0)&#10;            return make_pair(nil, ai);&#10;        if(k == a.siz)&#10;            return make_pair(ai, nil);&#10;        Index li = a.l;&#10;        Index ri = a.r;&#10;        auto&amp; l = get(li);&#10;        if(k &lt; l.siz){&#10;            auto res = split(li, k);&#10;            return make_pair(res.first, merge(res.second, ri));&#10;        }&#10;        else if(k &gt; get(a.l).siz){&#10;            auto res = split(ri, k - l.siz);&#10;            return make_pair(merge(li, res.first), res.second);&#10;        }&#10;        else{&#10;            return make_pair(li, ri);&#10;        }&#10;    }&#10;&#10;    pair&lt;T, Index&gt; range_get(Index pi, int l, int r){&#10;        auto res = split(pi, r);&#10;        auto res2 = split(res.first, l);&#10;        T val = get(res2.second).sum;&#10;        return make_pair(val, merge(merge(res2.first, res2.second), res.second));&#10;    }&#10;&#10;    Index insert(Index pi, int k, T val){&#10;        auto res = split(pi, k);&#10;        return merge(res.first, merge(make(val), res.second));&#10;    }&#10;&#10;    Index erase(Index pi, int k){&#10;        auto res = split(pi, k + 1);&#10;        auto res2 = split(res.first, k);&#10;        return merge(res2.first, res.second);&#10;    }&#10;&#10;    Index access(Index pi, int k){&#10;        while(get(pi).l != nil || get(pi).r != nil){&#10;            auto&amp; p = get(pi);&#10;            assert(p.l != nil &amp;&amp; p.r != nil);&#10;            if(get(p.l).siz &lt;= k){&#10;                k -= get(p.l).siz;&#10;                pi = p.r;&#10;            }&#10;            else{&#10;                pi = p.l;&#10;            }&#10;        }&#10;        return pi;&#10;    }&#10;&#10;    Index set(Index pi, int k, T val, function&lt;T(T, T)&gt; g = [](T x, T y){return y;}){&#10;        stack&lt;pair&lt;Index, bool&gt;&gt; st;&#10;        while(get(pi).l != nil || get(pi).r != nil){&#10;            auto&amp; p = get(pi);&#10;            assert(p.l != nil &amp;&amp; p.r != nil);&#10;            if(get(p.l).siz &lt;= k){&#10;                k -= get(p.l).siz;&#10;                st.emplace(pi, true);&#10;                pi = p.r;&#10;            }&#10;            else{&#10;                st.emplace(pi, false);&#10;                pi = p.l;&#10;            }&#10;        }&#10;        Index new_idx = makeLeaf(g(get(pi).sum, val), get(pi).red);&#10;        while(!st.empty()){&#10;            Index idx;&#10;            bool is_right;&#10;            tie(idx, is_right) = st.top();&#10;            auto&amp; p = get(idx);&#10;            if(is_right)&#10;                new_idx = makeInternal(p.l, new_idx, p.red);&#10;            else&#10;                new_idx = makeInternal(new_idx, p.r, p.red);&#10;            st.pop();&#10;        }&#10;        return new_idx;&#10;    }&#10;&#10;    void dump(Index pi, vector&lt;T&gt;&amp; v){&#10;        auto&amp; p = get(pi);&#10;        if(p.l != nil)&#10;            dump(p.l, v);&#10;        v.emplace_back(get_val(pi));&#10;        if(p.r != nil)&#10;            dump(p.r, v);&#10;    }&#10;&#10;    vector&lt;T&gt; dump(Index pi){&#10;        vector&lt;T&gt; v;&#10;        dump(pi, v);&#10;        return v;&#10;    }&#10;&#10;    Index rebuild(Index pi){&#10;        auto v = dump(pi);&#10;        clear();&#10;        return build(v);&#10;    }&#10;&#10;    Node&amp; get(Index k){return pool[k];}&#10;    Node&amp; operator[](Index k){return pool[k];}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="redblacktree_persistent_lazy" value="// doc: https://shibh308.github.io/library/library/lib/classes/redblacktree_persistent_lazy.cpp.html&#10;// verify: https://atcoder.jp/contests/arc030/submissions/12211957/&#10;template &lt;typename T, typename U&gt;&#10;struct RedBlackTree{&#10;&#10;    struct Node;&#10;    using Index = typename MemoryPool&lt;Node&gt;::Index;&#10;&#10;    struct Node{&#10;        int siz, level;&#10;        T sum;&#10;        U lazy;&#10;        bool red;&#10;        typename MemoryPool&lt;Node&gt;::Index l, r;&#10;        Node(){}&#10;        Node(T val, U lazy, bool red, bool leaf, int li = -1, int ri = -1) : sum(val), lazy(lazy), siz(leaf), level(0), red(red){&#10;            l = {li};&#10;            r = {ri};&#10;        }&#10;        Node(T val, U lazy, bool red, bool leaf, Index l, Index r) : sum(val), lazy(lazy), siz(leaf), level(0), red(red), l(l), r(r){}&#10;    };&#10;&#10;    MemoryPool&lt;Node&gt; pool;&#10;    Index nil;&#10;    function&lt;T(T, T)&gt; f;&#10;    function&lt;U(T, U, int)&gt; g;&#10;    function&lt;U(U, U)&gt; h;&#10;    T op_t;&#10;    U op_u;&#10;    RedBlackTree(function&lt;T(T, T)&gt; f, function&lt;T(T, U, int)&gt; g, function&lt;U(U, U)&gt; h, T op_t, U op_u) : f(f), g(g), h(h), op_t(op_t), op_u(op_u){&#10;        nil = pool.alloc();&#10;        pool[nil] = Node(op_t, op_u, false, false);&#10;        pool[nil].l = pool[nil].r = nil;&#10;    }&#10;&#10;    Index build(vector&lt;T&gt;&amp; a){&#10;        nil = pool.alloc();&#10;        pool[nil] = Node(op_t, op_u, false, false);&#10;        pool[nil].l = pool[nil].r = nil;&#10;        int siz = a.size();&#10;        vector&lt;Index&gt; v(siz);&#10;        for(int i = 0; i &lt; siz; ++i)&#10;            v[i] = make(a[i]);&#10;        while(siz != 1){&#10;            int nex_siz = (siz + 1) &gt;&gt; 1;&#10;            vector&lt;Index&gt; nex(nex_siz);&#10;            for(int i = 0; i &lt; (siz &gt;&gt; 1); ++i)&#10;                nex[i] = merge(v[2 * i], v[2 * i + 1]);&#10;            if(siz &amp; 1)&#10;                nex.back() = v.back();&#10;            siz = nex_siz;&#10;            v = move(nex);&#10;        }&#10;        return v[0];&#10;    }&#10;&#10;    void clear(){&#10;        while(!pool.st.empty())&#10;            pool.st.pop();&#10;        for(int i = 1; i &lt;= pool.idx; ++i)&#10;            pool.st.push(i);&#10;    }&#10;&#10;    Index index(int x){return {x};}&#10;&#10;    T get_val(Index pi){&#10;        auto&amp; p = get(pi);&#10;        return g(p.sum, p.lazy, p.siz);&#10;    }&#10;&#10;    pair&lt;T, Index&gt; get_val(Index pi, int k){&#10;        Index root;&#10;        tie(pi, root) = access(pi, k);&#10;        return make_pair(get_val(pi), root);&#10;    }&#10;&#10;    pair&lt;Index, bool&gt; eval(Index pi){&#10;        if(pi == nil)&#10;            return {pi, false};&#10;        if(get(pi).lazy == op_u)&#10;            return {pi, false};&#10;        pi = clone(pi);&#10;        auto&amp; p = get(pi);&#10;        if(p.l != nil){&#10;            p.l = clone(p.l);&#10;            p.r = clone(p.r);&#10;            auto&amp; l = get(p.l);&#10;            l.lazy = h(l.lazy, p.lazy);&#10;            auto&amp; r = get(p.r);&#10;            r.lazy = h(r.lazy, p.lazy);&#10;        }&#10;        p.sum = get_val(pi);&#10;        p.lazy = op_u;&#10;        return {pi, true};&#10;    }&#10;&#10;    Index make(T val){&#10;        Index idx = pool.alloc();&#10;        pool[idx] = Node(val, op_u, false, true, nil, nil);&#10;        pool[idx].level = 1;&#10;        return idx;&#10;    }&#10;&#10;    Index clone(Index pi){&#10;        if(pi == nil)&#10;            return pi;&#10;        Index qi = pool.alloc();&#10;        auto&amp; p = get(pi);&#10;        pool[qi] = Node(p.sum, p.lazy, p.red, false, p.l, p.r);&#10;        pool[qi].siz = (p.l == nil ? 1 : pool[p.l].siz + pool[p.r].siz);&#10;        pool[qi].level = pool[p.l].level + !pool[p.l].red;&#10;        return qi;&#10;    }&#10;&#10;    Index makeInternal(Index l, Index r, bool red){&#10;        Index idx = pool.alloc();&#10;        pool[idx] = Node(op_t, op_u, red, false, l, r);&#10;        pool[idx].sum = f(get_val(l), get_val(r));&#10;        pool[idx].siz = pool[l].siz + pool[r].siz;&#10;        pool[idx].level = pool[l].level + !pool[l].red;&#10;        return idx;&#10;    }&#10;&#10;    Index mergeSub(Index ai, Index bi){&#10;        ai = eval(ai).first;&#10;        bi = eval(bi).first;&#10;        auto&amp; a = get(ai);&#10;        auto&amp; b = get(bi);&#10;        assert(ai != nil &amp;&amp; bi != nil);&#10;        if(a.level &lt; b.level){&#10;            Index ci = mergeSub(ai, b.l);&#10;            auto&amp; c = get(ci);&#10;            if(!b.red &amp;&amp; c.red &amp;&amp; get(c.l).red){&#10;                if(!get(b.r).red)&#10;                    return makeInternal(c.l, makeInternal(c.r, b.r, true), false);&#10;                else{&#10;                    b.r = eval(b.r).first;&#10;                    return makeInternal(makeInternal(c.l, c.r, false), makeInternal(get(b.r).l, get(b.r).r, false), true);&#10;                }&#10;            }&#10;            return makeInternal(ci, b.r, b.red);&#10;        }&#10;        else if(a.level &gt; b.level){&#10;            Index ci = mergeSub(a.r, bi);&#10;            auto&amp; c = get(ci);&#10;            if(!a.red &amp;&amp; c.red &amp;&amp; get(c.r).red){&#10;                if(!get(a.l).red)&#10;                    return makeInternal(makeInternal(a.l, c.l, true), c.r, false);&#10;                else{&#10;                    a.l = eval(a.l).first;&#10;                    return makeInternal(makeInternal(get(a.l).l, get(a.l).r, false), makeInternal(c.l, c.r, false), true);&#10;                }&#10;            }&#10;            return makeInternal(a.l, ci, a.red);&#10;        }&#10;        else{&#10;            if(a.red)&#10;                ai = makeInternal(a.l, a.r, false);&#10;            if(b.red)&#10;                bi = makeInternal(b.l, b.r, false);&#10;            return makeInternal(ai, bi, true);&#10;        }&#10;    }&#10;&#10;    Index merge(Index ai, Index bi){&#10;        if(ai == nil)&#10;            return bi;&#10;        if(bi == nil)&#10;            return ai;&#10;        Index ci = mergeSub(ai, bi);&#10;        auto&amp; c = get(ci);&#10;        if(c.red){&#10;            pool.free(ci);&#10;            return makeInternal(c.l, c.r, false);&#10;        }&#10;        return ci;&#10;    }&#10;&#10;    pair&lt;Index, Index&gt; split(Index ai, int k){&#10;        if(ai == nil)&#10;            return make_pair(nil, nil);&#10;        bool fl;&#10;        tie(ai, fl) = eval(ai);&#10;        auto&amp; a = get(ai);&#10;        if(k == 0)&#10;            return make_pair(nil, ai);&#10;        if(k == a.siz)&#10;            return make_pair(ai, nil);&#10;        Index li = a.l;&#10;        Index ri = a.r;&#10;        if(fl)&#10;            pool.free(ai);&#10;        auto&amp; l = get(li);&#10;        if(k &lt; l.siz){&#10;            auto res = split(li, k);&#10;            return make_pair(res.first, merge(res.second, ri));&#10;        }&#10;        else if(k &gt; get(a.l).siz){&#10;            auto res = split(ri, k - l.siz);&#10;            return make_pair(merge(li, res.first), res.second);&#10;        }&#10;        else{&#10;            return make_pair(li, ri);&#10;        }&#10;    }&#10;&#10;    pair&lt;T, Index&gt; range_get(Index pi, int l, int r){&#10;        auto res = split(pi, r);&#10;        auto res2 = split(res.first, l);&#10;        T val = get_val(res2.second);&#10;        return make_pair(val, merge(merge(res2.first, res2.second), res.second));&#10;    }&#10;&#10;    Index range_update(Index pi, int l, int r, U val){&#10;        if(l == r)&#10;            return pi;&#10;        auto res = split(pi, r);&#10;        auto res2 = split(res.first, l);&#10;        Index mi = clone(res2.second);&#10;        auto&amp; mid = get(mi);&#10;        mid.lazy = h(mid.lazy, val);&#10;        Index nex_mi;&#10;        bool fl;&#10;        tie(nex_mi, fl) = eval(mi);&#10;        if(fl)&#10;            pool.free(mi);&#10;&#10;        return merge(merge(res2.first, nex_mi), res.second);&#10;    }&#10;&#10;    Index insert(Index pi, int k, T val){&#10;        auto res = split(pi, k);&#10;        return merge(res.first, merge(make(val), res.second));&#10;    }&#10;&#10;    Index erase(Index pi, int k){&#10;        auto res = split(pi, k + 1);&#10;        auto res2 = split(res.first, k);&#10;        return merge(res2.first, res.second);&#10;    }&#10;&#10;    pair&lt;Index, Index&gt; access(Index pi, int k){&#10;        auto res = split(pi, k + 1);&#10;        auto res2 = split(res.first, k);&#10;        return make_pair(res2.second, merge(merge(res2.first, res2.second), res.second));&#10;    }&#10;&#10;    Index set(Index pi, int k, T val, function&lt;T(T, T)&gt; af = [](T x, T y){return y;}){&#10;        auto res = split(pi, k + 1);&#10;        auto res2 = split(res.first, k);&#10;        Index qi = eval(res2.second);&#10;        get(qi).sum = af(get_val(qi), val);&#10;        return make_pair(qi, merge(merge(res2.first, qi), res.second));&#10;    }&#10;&#10;    void dump(Index pi, vector&lt;T&gt;&amp; v){&#10;        Index qi = eval(pi).first;&#10;        auto&amp; q = get(qi);&#10;        if(q.l != nil){&#10;            dump(q.l, v);&#10;            dump(q.r, v);&#10;        }&#10;        else&#10;            v.emplace_back(get_val(pi));&#10;    }&#10;&#10;    vector&lt;T&gt; dump(Index pi){&#10;        vector&lt;T&gt; v;&#10;        dump(pi, v);&#10;        return v;&#10;    }&#10;&#10;    Index rebuild(Index pi){&#10;        auto v = dump(pi);&#10;        clear();&#10;        return build(v);&#10;    }&#10;&#10;    Node&amp; get(Index k){return pool[k];}&#10;    Node&amp; operator[](Index k){return pool[k];}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="redblacktree_sset" value="// doc: https://shibh308.github.io/library/library/lib/classes/redblacktree_sset.cpp.html&#10;template &lt;typename T&gt;&#10;struct RedBlackTree{&#10;&#10;    struct Node;&#10;    using Index = typename MemoryPool&lt;Node&gt;::Index;&#10;&#10;    struct Node{&#10;        int siz, level;&#10;        T key;&#10;        bool red;&#10;        typename MemoryPool&lt;Node&gt;::Index l, r;&#10;        Node(){}&#10;        Node(T val, bool red, bool leaf, int li = -1, int ri = -1) : key(val), siz(leaf), level(0), red(red){&#10;            l = {li};&#10;            r = {ri};&#10;        }&#10;    };&#10;&#10;    MemoryPool&lt;Node&gt; pool;&#10;    Index nil;&#10;    RedBlackTree(){&#10;        nil = pool.alloc();&#10;        pool[nil] = Node(T(), false, false);&#10;        pool[nil].l = pool[nil].r = nil;&#10;    }&#10;&#10;    Index build(vector&lt;T&gt;&amp; a){&#10;        nil = pool.alloc();&#10;        pool[nil] = Node(T(), false, false);&#10;        pool[nil].l = pool[nil].r = nil;&#10;        int siz = a.size();&#10;        vector&lt;Index&gt; v(siz);&#10;        for(int i = 0; i &lt; siz; ++i)&#10;            v[i] = make(a[i]);&#10;        while(siz != 1){&#10;            int nex_siz = (siz + 1) &gt;&gt; 1;&#10;            vector&lt;Index&gt; nex(nex_siz);&#10;            for(int i = 0; i &lt; (siz &gt;&gt; 1); ++i)&#10;                nex[i] = merge(v[2 * i], v[2 * i + 1]);&#10;            if(siz &amp; 1)&#10;                nex.back() = v.back();&#10;            siz = nex_siz;&#10;            v = move(nex);&#10;        }&#10;        return v[0];&#10;    }&#10;&#10;    void clear(){&#10;        while(!pool.st.empty())&#10;            pool.st.pop();&#10;        for(int i = 1; i &lt;= pool.idx; ++i)&#10;            pool.st.push(i);&#10;    }&#10;&#10;	Index index(int x){return {x};}&#10;&#10;    T get_val(Index pi, int k){&#10;        pi = access(pi, k);&#10;        return get(pi).sum;&#10;    }&#10;&#10;    void update(Index pi){&#10;        if(pi == nil)&#10;            return;&#10;        auto&amp; p = get(pi);&#10;        auto&amp; l = get(p.l);&#10;        auto&amp; r = get(p.r);&#10;        p.siz = l.siz + r.siz;&#10;        if(p.l != nil || p.r != nil)&#10;            p.key = l.key;&#10;        p.level = l.level + !l.red;&#10;        assert(p.level == r.level + !r.red);&#10;    }&#10;&#10;    Index make(T val){&#10;        Index idx = pool.alloc();&#10;        pool[idx] = Node(val, false, true, nil.idx, nil.idx);&#10;        pool[idx].level = 1;&#10;        return idx;&#10;    }&#10;&#10;    Index mergeSub(Index ai, Index bi){&#10;        auto&amp; a = get(ai);&#10;        auto&amp; b = get(bi);&#10;        assert(ai != nil &amp;&amp; bi != nil);&#10;        if(a.level &lt; b.level){&#10;            Index ci = mergeSub(ai, b.l);&#10;            auto&amp; c = get(ci);&#10;            if(!b.red &amp;&amp; c.red &amp;&amp; get(c.l).red){&#10;                if(!get(b.r).red){&#10;                    b.l = c.l;&#10;                    c.l = c.r;&#10;                    c.r = b.r;&#10;                    b.r = ci;&#10;                    update(ci);&#10;                    update(bi);&#10;                    return bi;&#10;                }&#10;                else{&#10;                    b.l = ci;&#10;                    b.red ^= 1;&#10;                    get(b.l).red ^= 1;&#10;                    get(b.r).red ^= 1;&#10;                    update(bi);&#10;                    return bi;&#10;                }&#10;            }&#10;            b.l = ci;&#10;            update(bi);&#10;            return bi;&#10;        }&#10;        else if(a.level &gt; b.level){&#10;            Index ci = mergeSub(a.r, bi);&#10;            auto&amp; c = get(ci);&#10;            if(!a.red &amp;&amp; c.red &amp;&amp; get(c.r).red){&#10;                if(!get(a.l).red){&#10;                    a.r = c.r;&#10;                    c.r = c.l;&#10;                    c.l = a.l;&#10;                    a.l = ci;&#10;                    update(ci);&#10;                    update(ai);&#10;                    return ai;&#10;                }&#10;                else{&#10;                    a.r = ci;&#10;                    a.red ^= 1;&#10;                    get(a.l).red ^= 1;&#10;                    get(a.r).red ^= 1;&#10;                    update(ai);&#10;                    return ai;&#10;                }&#10;            }&#10;            a.r = ci;&#10;            update(ai);&#10;            return ai;&#10;        }&#10;        else{&#10;            a.red = false;&#10;            b.red = false;&#10;            Index d = pool.alloc();&#10;            get(d) = Node(T(), true, false, ai.idx, bi.idx);&#10;            update(d);&#10;            return d;&#10;        }&#10;    }&#10;&#10;    Index merge(Index ai, Index bi){&#10;        if(ai == nil)&#10;            return bi;&#10;        if(bi == nil)&#10;            return ai;&#10;        Index ci = mergeSub(ai, bi);&#10;        get(ci).red = false;&#10;        return ci;&#10;    }&#10;&#10;    pair&lt;Index, Index&gt; split(Index ai, int k){&#10;        if(ai == nil)&#10;            return make_pair(nil, nil);&#10;        auto&amp; a = get(ai);&#10;        if(k == 0)&#10;            return make_pair(nil, ai);&#10;        if(k == a.siz)&#10;            return make_pair(ai, nil);&#10;        Index li = a.l;&#10;        Index ri = a.r;&#10;        auto&amp; l = get(li);&#10;        pool.free(ai);&#10;        if(k &lt; l.siz){&#10;            auto res = split(li, k);&#10;            return make_pair(res.first, merge(res.second, ri));&#10;        }&#10;        else if(k &gt; get(a.l).siz){&#10;            auto res = split(ri, k - l.siz);&#10;            return make_pair(merge(li, res.first), res.second);&#10;        }&#10;        else{&#10;            return make_pair(li, ri);&#10;        }&#10;    }&#10;&#10;    int lower_bound(Index pi, T x){&#10;        if(pi == nil)&#10;            return 0;&#10;        int k = 0;&#10;        while(get(pi).l != nil || get(pi).r != nil){&#10;            auto&amp; p = get(pi);&#10;            assert(p.l != nil &amp;&amp; p.r != nil);&#10;            if(x &lt; get(p.r).key){&#10;                pi = p.l;&#10;            }&#10;            else{&#10;                k += get(p.l).siz;&#10;                pi = p.r;&#10;            }&#10;        }&#10;        return k + (get(pi).key &lt; x);&#10;    }&#10;&#10;    Index insert(Index pi, T val){&#10;        int k = lower_bound(pi, val);&#10;        auto res = split(pi, k);&#10;        return merge(res.first, merge(make(val), res.second));&#10;    }&#10;&#10;    Index erase_index(Index pi, int k){&#10;        auto res = split(pi, k + 1);&#10;        auto res2 = split(res.first, k);&#10;        pool.free(res2.second);&#10;        return merge(res2.first, res.second);&#10;    }&#10;&#10;    Index erase_key(Index pi, T x){&#10;        int k = lower_bound(pi, x);&#10;        if(k == get(pi).siz || get(access(pi, k)).key != x)&#10;            return pi;&#10;        return erase_index(pi, k);&#10;    }&#10;&#10;    Index access(Index pi, int k){&#10;        while(get(pi).l != nil || get(pi).r != nil){&#10;            auto&amp; p = get(pi);&#10;            assert(p.l != nil &amp;&amp; p.r != nil);&#10;            if(get(p.l).siz &lt;= k){&#10;                k -= get(p.l).siz;&#10;                pi = p.r;&#10;            }&#10;            else{&#10;                pi = p.l;&#10;            }&#10;        }&#10;        assert(k == 0);&#10;        return pi;&#10;    }&#10;&#10;    Node&amp; get(Index k){return pool[k];}&#10;    Node&amp; operator[](Index k){return pool[k];}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rollinghash" value="// doc: https://shibh308.github.io/library/library/lib/classes/rollinghash.cpp.html&#10;template &lt;i64 mod1 = MOD, i64 mod2 = MOD + 2, i64 base = 10007, typename T = string&gt;&#10;struct RollingHash{&#10;&#10;    using mint1 = ModInt&lt;mod1&gt;;&#10;    using mint2 = ModInt&lt;mod2&gt;;&#10;    using pair_type = pair&lt;mint1, mint2&gt;;&#10;    int len;&#10;    std::vector&lt;pair_type&gt; v;&#10;    static std::vector&lt;pair_type&gt; power, inv;&#10;&#10;    RollingHash(T s) :&#10;    len(s.size())&#10;    {&#10;        v.assign(1, make_pair(mint1(0), mint2(0)));&#10;        for(int i = 0; i &lt; len; ++i){&#10;            auto c = s[i];&#10;            v.emplace_back(v.back().first + power[i].first * c,&#10;                           v.back().second + power[i].second * c);&#10;            if(static_cast&lt;int&gt;(power.size()) == i + 1){&#10;                power.emplace_back(power.back().first * base,&#10;                                   power.back().second * base);&#10;                inv.emplace_back(mpow(power.back().first, mod1 - 2),&#10;                                 mpow(power.back().second, mod2 - 2));&#10;            }&#10;        }&#10;    };&#10;&#10;    pair_type get(int l = 0, int r = -1){&#10;        if(r == -1)&#10;            r = len;&#10;        assert(l &lt;= r);&#10;        assert(r &lt;= len);&#10;        auto l_cut = make_pair(v[r].first - v[l].first,&#10;                               v[r].second - v[l].second);&#10;        return make_pair(l_cut.first * inv[l].first,&#10;                         l_cut.second * inv[l].second);&#10;    }&#10;&#10;    pair_type connect(pair_type l, pair_type r, int l_len){&#10;        return make_pair(l.first + power[l_len].first * r.first,&#10;                         l.second + power[l_len].second * r.second);&#10;    }&#10;};&#10;&#10;using RH = RollingHash&lt;MOD, MOD + 2, 10007&gt;;&#10;template&lt;&gt; vector&lt;pair&lt;ModInt&lt;MOD&gt;, ModInt&lt;MOD + 2&gt;&gt;&gt; RH::power = {make_pair(ModInt&lt;MOD&gt;(1), ModInt&lt;MOD + 2&gt;(1))};&#10;template&lt;&gt; vector&lt;pair&lt;ModInt&lt;MOD&gt;, ModInt&lt;MOD + 2&gt;&gt;&gt; RH::inv = {make_pair(ModInt&lt;MOD&gt;(1), ModInt&lt;MOD + 2&gt;(1))};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rollinghashmonoid" value="// doc: https://shibh308.github.io/library/library/lib/classes/rollinghashmonoid.cpp.html&#10;struct RollingHashMonoid{&#10;    using Hash = RollingHashMonoid;&#10;    using u64 = uint64_t;&#10;    static constexpr u64 mod = (1uLL &lt;&lt; 61) - 1;&#10;    static constexpr u64 m30 = (1uLL &lt;&lt; 30) - 1;&#10;    static constexpr u64 m31 = (1uLL &lt;&lt; 31) - 1;&#10;    static constexpr u64 m61 = mod;&#10;    static constexpr u64 _base = 550390130435464343;&#10;    static constexpr u64 _base_inv = 1803816245541264939;&#10;    static vector&lt;u64&gt; base, base_inv;&#10;&#10;    static inline u64 calc_mod(u64 x){&#10;        u64 xu = x &gt;&gt; 61;&#10;        u64 xd = x &amp; m61;&#10;        u64 res = xu + xd;&#10;        if(res &gt;= mod)&#10;            res -= mod;&#10;        return res;&#10;    }&#10;&#10;    static inline u64 raw_mul(u64 a, u64 b){&#10;        u64 au = a &gt;&gt; 31;&#10;        u64 ad = a &amp; m31;&#10;        u64 bu = b &gt;&gt; 31;&#10;        u64 bd = b &amp; m31;&#10;        u64 mid = ad * bu + au * bd;&#10;        u64 midu = mid &gt;&gt; 30;&#10;        u64 midd = mid &amp; m30;&#10;        return au * bu * 2 + midu + (midd &lt;&lt; 31) + ad * bd;&#10;    }&#10;&#10;    static void remake_table(int len){&#10;        while(base.size() &lt;= len){&#10;            base.emplace_back(calc_mod(raw_mul(base.back(), _base)));&#10;            base_inv.emplace_back(calc_mod(raw_mul(base_inv.back(), _base_inv)));&#10;        }&#10;    }&#10;&#10;    u64 h, l;&#10;&#10;    static inline u64 lshift(u64 a, int len){&#10;        remake_table(len);&#10;        return raw_mul(a, base[len]);&#10;    }&#10;    static inline u64 rshift(u64 a, int len){&#10;        remake_table(len);&#10;        return raw_mul(a, base_inv[len]);&#10;    }&#10;&#10;    Hash concat(const Hash&amp; b) const{&#10;        return RollingHashMonoid(&#10;                calc_mod(h + lshift(b.h, l)),&#10;                l + b.l&#10;        );&#10;    }&#10;    Hash sub(const Hash&amp; b) const{&#10;        return RollingHashMonoid(&#10;                calc_mod(rshift(h + mod - b.h, b.l)),&#10;                l - b.l&#10;        );&#10;    }&#10;&#10;    RollingHashMonoid() : h(0), l(0){}&#10;    RollingHashMonoid(u64 x) : h(x), l(1){}&#10;    RollingHashMonoid(u64 h, u64 l) : h(h), l(l){}&#10;&#10;    friend bool operator==(const Hash&amp; a, const Hash&amp; b){return a.h == b.h &amp;&amp; a.l == b.l;}&#10;&#10;    template &lt;typename T&gt;&#10;    static vector&lt;Hash&gt; make(vector&lt;T&gt;&amp; x){&#10;        vector&lt;Hash&gt; v(x.size() + 1);&#10;        for(int i = 0; i &lt; x.size(); ++i){&#10;            v[i + 1] = v[i].concat(x[i]);&#10;        }&#10;        return v;&#10;    }&#10;    static vector&lt;Hash&gt; make(string&amp; x){&#10;        vector&lt;Hash&gt; v(x.size() + 1);&#10;        for(int i = 0; i &lt; x.size(); ++i){&#10;            v[i + 1] = v[i].concat(x[i]);&#10;        }&#10;        return v;&#10;    }&#10;};&#10;&#10;namespace std{&#10;template&lt;&gt; struct hash&lt;RollingHashMonoid&gt;{&#10;    size_t operator()(const RollingHashMonoid x) const noexcept{&#10;        return x.concat(x.l).h;&#10;    }&#10;};&#10;}&#10;&#10;&#10;using Hash = RollingHashMonoid;&#10;vector&lt;uint64_t&gt; Hash::base = {1};&#10;vector&lt;uint64_t&gt; Hash::base_inv = {1};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="segmentset" value="// doc: https://shibh308.github.io/library/library/lib/classes/segmentset.cpp.html&#10;template &lt;typename T&gt;&#10;struct SegmentSet{&#10;    set&lt;pair&lt;T, T&gt;&gt; s;&#10;    set&lt;pair&lt;T, T&gt;&gt; s_rev;&#10;    SegmentSet(){}&#10;    // [l, r)を追加する&#10;    void insert(T l, T r){&#10;        auto iter = get(l).second;&#10;        if(iter != s.end() &amp;&amp; iter-&gt;first &lt;= l &amp;&amp; r &lt;= iter-&gt;second)&#10;            return;&#10;        vector&lt;pair&lt;T, T&gt;&gt; erase_elm;&#10;        for(auto it = s.lower_bound(make_pair(l, numeric_limits&lt;T&gt;::min())); it != s.end() &amp;&amp; it-&gt;first &lt;= r; ++it)&#10;            erase_elm.emplace_back(*it);&#10;        for(auto it = s_rev.lower_bound(make_pair(l, numeric_limits&lt;T&gt;::min())); it != s_rev.end() &amp;&amp; it-&gt;first &lt;= r; ++it)&#10;            erase_elm.emplace_back(it-&gt;second, it-&gt;first);&#10;        for(auto&amp; p : erase_elm){&#10;            chmin(l, p.first);&#10;            chmax(r, p.second);&#10;            s.erase(p);&#10;            s_rev.erase(make_pair(p.second, p.first));&#10;        }&#10;        s.emplace(l, r);&#10;        s_rev.emplace(r, l);&#10;    }&#10;    // xが含まれるような区間を返す&#10;    pair&lt;bool, typename set&lt;pair&lt;T, T&gt;&gt;::const_iterator&gt; get(T x){&#10;        auto it = s.lower_bound(make_pair(x, numeric_limits&lt;T&gt;::min()));&#10;        if(it != s.begin())&#10;            --it;&#10;        return make_pair(x &lt; it-&gt;second, it);&#10;    }&#10;    set&lt;pair&lt;T, T&gt;&gt;&amp; operator*(){return s;}&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="segtree" value="// doc: https://shibh308.github.io/library/library/lib/classes/segtree.cpp.html&#10;template&lt;typename T&gt;&#10;struct Segtree{&#10;    int n;&#10;    T op;&#10;    vector&lt;T&gt; elm;&#10;    function&lt;T(T, T)&gt; f;&#10;&#10;    Segtree(int n, T init, function&lt;T(T, T)&gt; f, T op = T()) :&#10;        n(n),&#10;        op(op),&#10;        elm(2 * n, init),&#10;        f(f)&#10;    {&#10;        for(int i = n - 1; i &gt;= 1; --i)&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;    }&#10;&#10;    Segtree(int n, vector&lt;T&gt; init, function&lt;T(T, T)&gt; f, T op = T()) :&#10;        n(n),&#10;        op(op),&#10;        elm(2 * n),&#10;        f(f)&#10;    {&#10;        for(int i = 0; i &lt; n; ++i)&#10;            elm[i + n] = init[i];&#10;        for(int i = n - 1; i &gt;= 1; --i)&#10;            elm[i] = f(elm[2 * i], elm[2 * i + 1]);&#10;    }&#10;&#10;    void set(int x, T val){&#10;        x += n;&#10;        elm[x] = val;&#10;        while(x &gt;&gt;= 1)&#10;            elm[x] = f(elm[2 * x], elm[2 * x + 1]);&#10;    }&#10;&#10;    void update(int x, T val){&#10;        x += n;&#10;        elm[x] = f(elm[x], val);&#10;        while(x &gt;&gt;= 1)&#10;            elm[x] = f(elm[2 * x], elm[2 * x + 1]);&#10;    }&#10;&#10;    T get(int x, int y) const{&#10;        T l = op, r = op;&#10;        for(x += n, y += n - 1; x &lt;= y; x &gt;&gt;= 1, y &gt;&gt;= 1){&#10;            if(x &amp; 1)&#10;                l = f(l, elm[x++]);&#10;            if(!(y &amp; 1))&#10;                r = f(elm[y--], r);&#10;        }&#10;        return f(l, r);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="skiplist" value="// doc: https://shibh308.github.io/library/library/lib/classes/skiplist.cpp.html&#10;template &lt;typename T&gt;&#10;struct SkipList{&#10;&#10;    static uint32_t rnd(){&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = time(0);&#10;        uint32_t t = x ^ (x &lt;&lt; 11);&#10;        x = y, y = z, z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return w;&#10;    }&#10;&#10;    struct Node{&#10;        int height;&#10;        T val;&#10;        vector&lt;Node*&gt; next, prev;&#10;        vector&lt;T&gt; sum;&#10;        vector&lt;int&gt; size;&#10;        Node(T val, int height) : val(val), height(height), next(height, nullptr), prev(height, nullptr), sum(height, val), size(height, 1){}&#10;    };&#10;&#10;    using NodePtr = Node*;&#10;    int max_height;&#10;    NodePtr front, back;&#10;    function&lt;T(T, T)&gt; f;&#10;    T op;&#10;&#10;    SkipList(function&lt;T(T, T)&gt; f = [](auto x, auto y){return x;}, T op = T()) : max_height(0), f(f), op(op){&#10;        front = new Node(op, 32);&#10;        back = new Node(op, 32);&#10;        front-&gt;next[0] = back;&#10;        back-&gt;prev[0] = front;&#10;    }&#10;&#10;    int size(){&#10;        return front-&gt;size[max_height] - 1;&#10;    }&#10;&#10;    void insert_next(NodePtr pre, T key){&#10;        uint32_t r = max(rnd(), uint32_t(1));&#10;        int height = __builtin_ffs(r);&#10;        while(max_height &lt; height){&#10;            ++max_height;&#10;            front-&gt;size[max_height] = front-&gt;size[max_height - 1];&#10;            front-&gt;next[max_height] = back;&#10;            back-&gt;prev[max_height] = front;&#10;            front-&gt;sum[max_height] = front-&gt;sum[max_height - 1];&#10;        }&#10;        NodePtr node = new Node(key, height);&#10;&#10;        int pre_size = 1;&#10;        T pre_sum = pre-&gt;val;&#10;        T nex_sum = key;&#10;        NodePtr nex = pre-&gt;next[0];&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            ++pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = node;&#10;                node-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = node;&#10;                node-&gt;prev[i] = pre;&#10;                int range_size = pre-&gt;size[i];&#10;                pre-&gt;size[i] = pre_size;&#10;                pre-&gt;sum[i] = pre_sum;&#10;                node-&gt;size[i] = range_size - pre_size;&#10;                node-&gt;sum[i] = nex_sum;&#10;            }&#10;            else{&#10;                pre-&gt;sum[i] = f(pre_sum, nex_sum);&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i]){&#10;                pre_sum = f(pre-&gt;prev[i]-&gt;sum[i], pre_sum);&#10;                pre_size += pre-&gt;prev[i]-&gt;size[i];&#10;            }&#10;            for(; nex-&gt;height == i + 1  &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i]){&#10;                nex_sum = f(nex_sum, nex-&gt;sum[i]);&#10;            }&#10;        }&#10;    }&#10;&#10;    // idx番目(idx=0なら先頭)に挿入する&#10;    void insert_index(int idx, T key){&#10;        NodePtr pre = access(idx - 1);&#10;        insert_next(pre, key);&#10;    }&#10;&#10;    void insert_key(T key){&#10;        NodePtr pre = lower_bound(key)-&gt;prev[0];&#10;        insert_next(pre, key);&#10;    }&#10;&#10;    void erase(NodePtr target){&#10;        // メモリ解放はしない(してもいいけど)&#10;        int height = target-&gt;height;&#10;        NodePtr pre = target-&gt;prev[0];&#10;        NodePtr nex = target-&gt;next[0];&#10;        T sum = pre-&gt;val;&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            pre-&gt;sum[i] = sum;&#10;            --pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = pre;&#10;                pre-&gt;size[i] += target-&gt;size[i];&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i])&#10;                sum = f(pre-&gt;prev[i]-&gt;sum[i], sum);&#10;            for(; nex-&gt;height == i + 1 &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i])&#10;                sum = f(sum, nex-&gt;sum[i]);&#10;        }&#10;    }&#10;&#10;    void erase_index(int idx){&#10;        NodePtr target = access(idx);&#10;        erase(target);&#10;    }&#10;    void erase_key(T key){&#10;        NodePtr target = lower_bound(key);&#10;        if(target == back || target-&gt;val != key)&#10;            return;&#10;        erase(target);&#10;    }&#10;&#10;    NodePtr lower_bound(T key){&#10;        NodePtr pre = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; pre-&gt;next.size() &amp;&amp; pre-&gt;next[i] != back &amp;&amp; pre-&gt;next[i]-&gt;val &lt; key; pre = pre-&gt;next[i]);&#10;        return pre-&gt;next[0];&#10;    }&#10;&#10;    NodePtr upper_bound(T key){&#10;        NodePtr pre = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; pre-&gt;next.size() &amp;&amp; pre-&gt;next[i] != back &amp;&amp; pre-&gt;next[i]-&gt;val &lt;= key; pre = pre-&gt;next[i]);&#10;        return pre-&gt;next[0];&#10;    }&#10;&#10;    bool contains(T key){&#10;        NodePtr ptr = lower_bound(key);&#10;        return ptr != back &amp;&amp; ptr-&gt;key == key;&#10;    }&#10;&#10;    // 0-indexedでアクセスする&#10;    NodePtr access(int idx){&#10;        ++idx;&#10;        assert(0 &lt;= idx &amp;&amp; idx &lt;= size());&#10;        NodePtr ptr = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; ptr-&gt;next.size() &amp;&amp; ptr-&gt;next[i] != back &amp;&amp; ptr-&gt;size[i] &lt;= idx; idx -= ptr-&gt;size[i], ptr = ptr-&gt;next[i]);&#10;        return ptr;&#10;    }&#10;&#10;    T get(int l, int r){&#10;        NodePtr ptr = access(l);&#10;        T sum = op;&#10;        int diff = r - l;&#10;        int height_bound = 32;&#10;        for(; ptr-&gt;size[ptr-&gt;height - 1] &lt;= diff; ptr = ptr-&gt;next[ptr-&gt;height - 1]){&#10;            diff -= ptr-&gt;size[ptr-&gt;height - 1];&#10;            sum = f(sum, ptr-&gt;sum[ptr-&gt;height - 1]);&#10;        }&#10;        for(int i = ptr-&gt;height - 2; diff; --i)&#10;            for(; ptr-&gt;size[i] &lt;= diff; ptr = ptr-&gt;next[i]){&#10;                diff -= ptr-&gt;size[i];&#10;                sum = f(sum, ptr-&gt;sum[i]);&#10;            }&#10;        return sum;&#10;    }&#10;&#10;    void print(){&#10;        for(NodePtr node = front; node != nullptr; node = node-&gt;next[0]){&#10;            if(node == front || node == back)&#10;                printf(&quot;  null: &quot;);&#10;            else&#10;                printf(&quot;%6lld: &quot;, node-&gt;val);&#10;            for(int i = 0; i &lt; node-&gt;height; ++i)&#10;                printf(&quot;%2d &quot;, node-&gt;sum[i]);&#10;                // cout &lt;&lt; node-&gt;size[i] &lt;&lt; &quot; &quot;;&#10;            cout &lt;&lt; endl;&#10;        }&#10;        cout &lt;&lt; endl;&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="skiplist_sset" value="// doc: https://shibh308.github.io/library/library/lib/classes/skiplist_sset.cpp.html&#10;template &lt;typename T&gt;&#10;struct SSet{&#10;&#10;    static uint32_t rnd(){&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = time(0);&#10;        uint32_t t = x ^(x &lt;&lt; 11);&#10;        x = y, y = z, z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return w;&#10;    }&#10;&#10;    struct Node{&#10;        int height;&#10;        T val;&#10;        vector&lt;Node *&gt; next, prev;&#10;        vector&lt;int&gt; size;&#10;        Node(T val, int height) : val(val), height(height), next(height, nullptr), prev(height, nullptr), size(height, 1){}&#10;    };&#10;&#10;    using NodePtr = Node*;&#10;    int max_height;&#10;    NodePtr front, back;&#10;&#10;    SSet(Node* fr = nullptr, Node* ba = nullptr) : max_height(0), front(fr), back(ba){&#10;        if(front == nullptr){&#10;            front = new Node(T(), 21);&#10;            back = new Node(T(), 21);&#10;            front-&gt;next[0] = back;&#10;            back-&gt;prev[0] = front;&#10;        }&#10;    }&#10;&#10;    int size(){&#10;        return front-&gt;size[max_height] - 1;&#10;    }&#10;&#10;    void insert_next(NodePtr pre, T key, int height = -1){&#10;        if(height == -1){&#10;            uint32_t r = max(rnd(), uint32_t(1));&#10;            height = min(20, __builtin_ffs(r));&#10;        }&#10;        while(max_height &lt; height){&#10;            ++max_height;&#10;            front-&gt;size[max_height] = front-&gt;size[max_height - 1];&#10;            front-&gt;next[max_height] = back;&#10;            back-&gt;prev[max_height] = front;&#10;        }&#10;        NodePtr node = new Node(key, height);&#10;&#10;        int pre_size = 1;&#10;        NodePtr nex = pre-&gt;next[0];&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            ++pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = node;&#10;                node-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = node;&#10;                node-&gt;prev[i] = pre;&#10;                int range_size = pre-&gt;size[i];&#10;                pre-&gt;size[i] = pre_size;&#10;                node-&gt;size[i] = range_size - pre_size;&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i])&#10;                pre_size += pre-&gt;prev[i]-&gt;size[i];&#10;            for(; nex-&gt;height == i + 1 &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i]);&#10;        }&#10;    }&#10;&#10;    void insert(T key){&#10;        NodePtr pre = lower_bound(key)-&gt;prev[0];&#10;        insert_next(pre, key);&#10;    }&#10;&#10;    void erase(NodePtr target){&#10;        // メモリ解放はしない(してもいいけど)&#10;        int height = target-&gt;height;&#10;        NodePtr pre = target-&gt;prev[0];&#10;        NodePtr nex = target-&gt;next[0];&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            --pre-&gt;size[i];&#10;            if(i &lt; height){&#10;                pre-&gt;next[i] = nex;&#10;                nex-&gt;prev[i] = pre;&#10;                pre-&gt;size[i] += target-&gt;size[i];&#10;            }&#10;            for(; pre-&gt;height == i + 1 &amp;&amp; pre-&gt;prev[i] != nullptr; pre = pre-&gt;prev[i]);&#10;            for(; nex-&gt;height == i + 1 &amp;&amp; nex-&gt;next[i] != nullptr; nex = nex-&gt;next[i]);&#10;        }&#10;    }&#10;&#10;    void erase_index(int idx){&#10;        NodePtr target = access(idx);&#10;        erase(target);&#10;    }&#10;&#10;    void erase_key(T key){&#10;        NodePtr target = lower_bound(key);&#10;        if(target == back || target-&gt;val != key)&#10;            return;&#10;        erase(target);&#10;    }&#10;&#10;    NodePtr lower_bound(T key){&#10;        NodePtr pre = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; pre-&gt;next.size() &amp;&amp; pre-&gt;next[i] != back &amp;&amp; pre-&gt;next[i]-&gt;val &lt; key; pre = pre-&gt;next[i]);&#10;        return pre-&gt;next[0];&#10;    }&#10;&#10;    // 0-indexedでアクセスする&#10;    NodePtr access(int idx){&#10;        ++idx;&#10;        assert(0 &lt;= idx &amp;&amp; idx &lt;= size());&#10;        NodePtr ptr = front;&#10;        for(int i = max_height; i &gt;= 0; --i)&#10;            for(; i &lt; ptr-&gt;next.size() &amp;&amp; ptr-&gt;next[i] != back &amp;&amp; ptr-&gt;size[i] &lt;= idx; idx -= ptr-&gt;size[i], ptr = ptr-&gt;next[i]);&#10;        return ptr;&#10;    }&#10;&#10;    // [0, k), [k, n)で分割し、[k, n)を返す&#10;    SSet&lt;T&gt; split(int k){&#10;        int max_h = max_height;&#10;        NodePtr pre = access(k - 1);&#10;        insert_next(pre, T(), 21);&#10;        NodePtr l_back = pre-&gt;next[0];&#10;        insert_next(l_back, T(), 21);&#10;        NodePtr r_front = l_back-&gt;next[0];&#10;        NodePtr l_front = front, r_back = back;&#10;        for(int i = 0; i &lt; l_back-&gt;height; ++i){&#10;            l_back-&gt;next[i] = nullptr;&#10;            r_front-&gt;prev[i] = nullptr;&#10;            l_back-&gt;size[i] = 1;&#10;        }&#10;        max_height = max_h;&#10;        NodePtr ptr = l_back;&#10;        int size = 1;&#10;        for(int i = 0; i &lt;= max_height; ++i){&#10;            ptr-&gt;size[i] = size;&#10;            for(; ptr-&gt;height == i + 1 &amp;&amp; ptr-&gt;prev[i] != nullptr; ptr = ptr-&gt;prev[i])&#10;                size += ptr-&gt;prev[i]-&gt;size[i];&#10;        }&#10;        back = l_back;&#10;        SSet&lt;T&gt; sset(r_front, r_back);&#10;        sset.max_height = max_h;&#10;        return sset;&#10;    }&#10;&#10;    // thisの末尾にslistを結合する&#10;    void merge(SSet&lt;T&gt;&amp; slist){&#10;        while(max_height &lt; slist.max_height){&#10;            ++max_height;&#10;            front-&gt;size[max_height] = front-&gt;size[max_height - 1];&#10;            front-&gt;next[max_height] = back;&#10;            back-&gt;prev[max_height] = front;&#10;        }&#10;        while(slist.max_height &lt; max_height){&#10;            ++slist.max_height;&#10;            slist.front-&gt;size[slist.max_height] = slist.front-&gt;size[slist.max_height - 1];&#10;            slist.front-&gt;next[slist.max_height] = slist.back;&#10;            slist.back-&gt;prev[slist.max_height] = slist.front;&#10;        }&#10;        NodePtr a = back, b = slist.front;&#10;        for(int i = 0; i &lt; back-&gt;height; ++i){&#10;            a-&gt;next[i] = b;&#10;            b-&gt;prev[i] = a;&#10;        }&#10;        back = slist.back;&#10;        erase(a);&#10;        erase(b);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="slp" value="// doc: https://shibh308.github.io/library/library/lib/classes/slp.cpp.html&#10;struct SLP{&#10;    SLP *l, *r;&#10;    long long size, left, right;&#10;    char c;&#10;    bool left_heavy;&#10;    const PersistentSkewBinaryList&lt;SLP*&gt;* heavy_path;&#10;&#10;    struct PairHashing{&#10;        size_t operator()(const pair&lt;SLP*, SLP*&gt;&amp; p) const{&#10;            return hash&lt;SLP*&gt;()(p.first) ^ (hash&lt;SLP*&gt;()(p.second) &lt;&lt; 1);&#10;        }&#10;    };&#10;&#10;    static unordered_map&lt;char, SLP*&gt; terminal_map;&#10;    static unordered_map&lt;pair&lt;SLP*, SLP*&gt;, SLP*, PairHashing&gt; nonterminal_map;&#10;    bool is_terminal(){ return l == nullptr; }&#10;private:&#10;    SLP(char c) : l(nullptr), r(nullptr), size(1), c(c), left(0), right(1){&#10;        heavy_path = new PersistentSkewBinaryList&lt;SLP*&gt;(this);&#10;    }&#10;    SLP(SLP *l, SLP *r) : l(l), r(r), size(l-&gt;size + r-&gt;size), left_heavy(l-&gt;size &gt;= r-&gt;size){&#10;        heavy_path = (left_heavy ? l : r)-&gt;heavy_path-&gt;push_front(this);&#10;        if(left_heavy){&#10;            left = l-&gt;left;&#10;            right = l-&gt;right + r-&gt;size;&#10;        }&#10;        else{&#10;            left = r-&gt;left - l-&gt;size;&#10;            right = r-&gt;right;&#10;        }&#10;    }&#10;    bool check(long long k){&#10;        return left &lt;= k &amp;&amp; k &lt; right;&#10;    }&#10;    SLP* find_lowest(PersistentSkewBinaryList&lt;SLP*&gt;::Node* ptr, long long k){&#10;        if(ptr-&gt;dep == 1){&#10;            return ptr-&gt;x-&gt;check(k) ? ptr-&gt;x : nullptr;&#10;        }&#10;        if(ptr-&gt;r-&gt;x-&gt;check(k))&#10;            return find_lowest(ptr-&gt;r, k);&#10;        else if(ptr-&gt;l-&gt;x-&gt;check(k))&#10;            return find_lowest(ptr-&gt;l, k);&#10;        else&#10;            return ptr-&gt;x-&gt;check(k) ? ptr-&gt;x : nullptr;&#10;    }&#10;    SLP* find_lowest(const PersistentSkewBinaryList&lt;SLP*&gt;* ptr, long long k){&#10;        if(ptr == nullptr || !ptr-&gt;node-&gt;x-&gt;check(k))&#10;            return nullptr;&#10;        auto res = find_lowest(ptr-&gt;nex, k);&#10;        if(res != nullptr)&#10;            return res;&#10;        return find_lowest(ptr-&gt;node, k);&#10;    }&#10;    // heavyからの相対位置&#10;    char _access(long long k){&#10;        auto ptr = find_lowest(heavy_path, k);&#10;        if(ptr-&gt;is_terminal())&#10;            return ptr-&gt;c;&#10;        // ptrの左端からの相対位置&#10;        long long left_pos = k - ptr-&gt;left;&#10;        if(ptr-&gt;left_heavy){&#10;            return ptr-&gt;r-&gt;_access(left_pos - ptr-&gt;l-&gt;size + ptr-&gt;r-&gt;left);&#10;        }&#10;        else{&#10;            return ptr-&gt;l-&gt;_access(left_pos + ptr-&gt;l-&gt;left);&#10;        }&#10;    }&#10;&#10;public:&#10;    static SLP* make(char c){&#10;        if(terminal_map.find(c) == terminal_map.end())&#10;            return terminal_map[c] = new SLP(c);&#10;        else&#10;            return terminal_map[c];&#10;    }&#10;    static SLP* make(SLP* l, SLP* r){&#10;        auto p = make_pair(l, r);&#10;        if(nonterminal_map.find(p) == nonterminal_map.end())&#10;            return nonterminal_map[p] = new SLP(l, r);&#10;        else&#10;            return nonterminal_map[p];&#10;    }&#10;    char access(long long k){&#10;        return _access(k + left);&#10;    }&#10;};&#10;&#10;unordered_map&lt;char, SLP*&gt; SLP::terminal_map;&#10;unordered_map&lt;pair&lt;SLP*, SLP*&gt;, SLP*, SLP::PairHashing&gt; SLP::nonterminal_map;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="sparsetable" value="// doc: https://shibh308.github.io/library/library/lib/classes/sparsetable.cpp.html&#10;template &lt;typename T&gt;&#10;struct SparseTable{&#10;    vector&lt;int&gt; len;&#10;    vector&lt;vector&lt;T&gt;&gt; v;&#10;    function&lt;T(T, T)&gt; f;&#10;    SparseTable(){}&#10;    SparseTable(vector&lt;T&gt;&amp; a, function&lt;T(T, T)&gt; f) : len(a.size() + 1, 0), v(1, a), f(f){&#10;        int n = a.size();&#10;        for(int j = 0; (1 &lt;&lt; j) &lt; n; ++j){&#10;            v.emplace_back(n);&#10;            for(int i = 0; i &lt; n; ++i)&#10;                v[j + 1][i] = (i + (1 &lt;&lt; j) &lt; n ? f(v[j][i], v[j][i + (1 &lt;&lt; j)]) : v[j][i]);&#10;        }&#10;        for(int i = 2; i &lt;= n; ++i){&#10;            len[i] = len[i &gt;&gt; 1] + 1;&#10;        }&#10;    }&#10;    T get(int l, int r){&#10;        int siz = r - l;&#10;        return f(v[len[siz]][l], v[len[siz]][r - (1 &lt;&lt; len[siz])]);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="splaytree_sset" value="// doc: https://shibh308.github.io/library/library/lib/classes/splaytree_sset.cpp.html&#10;template &lt;typename T&gt;&#10;struct SplayTree{&#10;    struct Node{&#10;        int size;&#10;        T val;&#10;        Node* par;&#10;        Node* c[2];&#10;        Node(){}&#10;        Node(T val, Node* nil) : val(val), size(1), par(nil){c[0] = nil; c[1] = nil;}&#10;    };&#10;    using NodePtr = Node*;&#10;    NodePtr nil;&#10;&#10;    SplayTree(){&#10;        nil = new Node(T(), nullptr);&#10;        nil-&gt;size = 0;&#10;        nil-&gt;par = nil-&gt;c[0] = nil-&gt;c[1] = nil;&#10;    }&#10;&#10;    NodePtr make(T val){&#10;        return new Node(val, nil);&#10;    }&#10;&#10;    void _update(NodePtr x){&#10;        if(x == nil)&#10;            return;&#10;        assert(x != x-&gt;c[0]);&#10;        assert(x != x-&gt;c[1]);&#10;        assert(x-&gt;c[0] == nil || x-&gt;c[0] != x-&gt;c[1]);&#10;        x-&gt;size = x-&gt;c[0]-&gt;size + x-&gt;c[1]-&gt;size + 1;&#10;        assert(x-&gt;size &gt; 0);&#10;    }&#10;&#10;    // idx側の子を上に持っていく&#10;    void rotate(NodePtr p, bool p_right){&#10;        NodePtr x = p-&gt;c[p_right];&#10;        NodePtr q = p-&gt;par;&#10;        // xに元々ついてた辺をpに張り替え&#10;        assert(p-&gt;c[p_right] == x);&#10;        p-&gt;c[p_right] = x-&gt;c[p_right ^ 1];&#10;        if(x-&gt;c[p_right ^ 1] != nil){&#10;            p-&gt;c[p_right]-&gt;par = p;&#10;            assert(p != p-&gt;c[p_right]);&#10;        }&#10;        // xp間の辺の張り替え&#10;        p-&gt;par = x;&#10;        x-&gt;c[p_right ^ 1] = p;&#10;        // pq間の辺の張り替え&#10;        x-&gt;par = q;&#10;        if(q != nil){&#10;            bool q_right = (q-&gt;c[1] == p);&#10;            assert(q-&gt;c[q_right] == p);&#10;            q-&gt;c[q_right] = x;&#10;        }&#10;        _update(p), _update(x), _update(q);&#10;    }&#10;&#10;    void reroot(NodePtr x){&#10;        while(x-&gt;par != nil){&#10;            NodePtr p = x-&gt;par;&#10;            NodePtr q = p-&gt;par;&#10;            bool q_right = (q-&gt;c[1] == p);&#10;            bool p_right = (p-&gt;c[1] == x);&#10;            if(p-&gt;par == nil){&#10;                rotate(p, p_right);&#10;                break;&#10;            }&#10;            // 同じ向きの二回回転&#10;            if(q_right == p_right){&#10;                rotate(q, q_right), rotate(p, p_right);&#10;            }&#10;            else{&#10;                rotate(p, p_right), rotate(q, q_right);&#10;            }&#10;        }&#10;    }&#10;&#10;    pair&lt;NodePtr, bool&gt; _lower_bound(NodePtr p, T key){&#10;        if(p == nil)&#10;            return make_pair(nil, false);&#10;        if(p-&gt;val &lt; key){&#10;            auto res = _lower_bound(p-&gt;c[1], key);&#10;            return res.second ? res : make_pair(p, false);&#10;        }&#10;        else{&#10;            auto res = _lower_bound(p-&gt;c[0], key);&#10;            return res.second ? res : make_pair(p, true);&#10;        }&#10;    }&#10;&#10;    pair&lt;NodePtr, bool&gt; lower_bound(NodePtr p, T key){&#10;        if(p == nil)&#10;            return make_pair(p, false);&#10;        auto res = _lower_bound(p, key);&#10;        reroot(res.first);&#10;        assert(res.first != nil);&#10;        return res;&#10;    }&#10;&#10;    NodePtr access(NodePtr p, int idx){&#10;        if(p == nil)&#10;            return nil;&#10;        while(p-&gt;c[0]-&gt;size != idx){&#10;            if(p-&gt;c[0]-&gt;size &lt; idx)&#10;                idx -= p-&gt;c[0]-&gt;size + 1, p = p-&gt;c[1];&#10;            else&#10;                p = p-&gt;c[0];&#10;            if(p == nil)&#10;                return nil;&#10;        }&#10;        reroot(p);&#10;        return p;&#10;    }&#10;&#10;    NodePtr next(NodePtr p){&#10;        reroot(p);&#10;        p = p-&gt;c[1];&#10;        while(p-&gt;c[0] != nil)&#10;            p = p-&gt;c[0];&#10;        if(p != nil)&#10;            reroot(p);&#10;        return p;&#10;    }&#10;&#10;    NodePtr prev(NodePtr p){&#10;        reroot(p);&#10;        p = p-&gt;c[0];&#10;        while(p-&gt;c[1] != nil)&#10;            p = p-&gt;c[1];&#10;        if(p != nil)&#10;            reroot(p);&#10;        return p;&#10;    }&#10;&#10;    pair&lt;NodePtr, bool&gt; insert(NodePtr root, T key){&#10;        if(root == nil)&#10;            return make_pair(make(key), true);&#10;        NodePtr l, r, np;&#10;        bool exist;&#10;        // lower_boundの結果からsplitする時、lower_boundの結果がnilだとバグるので注意&#10;        tie(np, exist) = lower_bound(root, key);&#10;        if(exist){&#10;            if(np-&gt;val == key)&#10;                return make_pair(np, false);&#10;            tie(l, r) = split(np);&#10;            return make_pair(merge(merge(l, make(key)), r), true);&#10;        }&#10;        else{&#10;            return make_pair(merge(np, make(key)), true);&#10;        }&#10;    }&#10;&#10;    pair&lt;NodePtr, bool&gt; erase(NodePtr root, T key){&#10;        NodePtr p = lower_bound(root, key).first;&#10;        reroot(p);&#10;        if(p == nil || p-&gt;val != key)&#10;            return make_pair(p, false);&#10;        NodePtr l = p-&gt;c[0], r = p-&gt;c[1];&#10;        l-&gt;par = r-&gt;par = nil;&#10;        delete(p);&#10;        return make_pair(merge(l, r), true);&#10;    }&#10;&#10;    // [0, p), [p, n)でsplist&#10;    pair&lt;NodePtr, NodePtr&gt; split(NodePtr p){&#10;        if(p == nil)&#10;            return make_pair(nil, nil);&#10;        reroot(p);&#10;        NodePtr l = p-&gt;c[0];&#10;        l-&gt;par = nil;&#10;        p-&gt;c[0] = nil;&#10;        _update(p);&#10;        return make_pair(l, p);&#10;    }&#10;&#10;    NodePtr merge(NodePtr p, NodePtr q){&#10;        reroot(p);&#10;        reroot(q);&#10;        if(q == nil)&#10;            return p;&#10;        if(p == nil)&#10;            return q;&#10;        while(p-&gt;c[1] != nil)&#10;            p = p-&gt;c[1];&#10;        reroot(p);&#10;        assert(p-&gt;c[1] == nil);&#10;        p-&gt;c[1] = q;&#10;        q-&gt;par = p;&#10;        _update(p);&#10;        assert(p != nil);&#10;        return p;&#10;    }&#10;&#10;    void print(NodePtr x, int p = 0){&#10;        if(x == nil)return;&#10;        if(p == 0)&#10;            cout &lt;&lt; &quot;----print----&quot; &lt;&lt; endl;&#10;        print(x-&gt;c[0], p + 8);&#10;        for(int i = 0; i &lt; p; ++i)&#10;            cout &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;val:&quot; &lt;&lt; x-&gt;val &lt;&lt; &quot; &quot;;&#10;        cout &lt;&lt; &quot;size:&quot; &lt;&lt; x-&gt;size &lt;&lt; endl;&#10;        print(x-&gt;c[1], p + 8);&#10;        if(p == 0)&#10;            cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="stringutils" value="// doc: https://shibh308.github.io/library/library/lib/classes/stringutils.cpp.html&#10;struct StringUtils{&#10;    int n;&#10;    vector&lt;int&gt; s;&#10;    vector&lt;int&gt; sa, sa_inv, lcp, tab_len;&#10;    vector&lt;vector&lt;int&gt;&gt; lcp_arr;&#10;    StringUtils(string _s) : StringUtils(vector&lt;int&gt;(_s.begin(), _s.end())){}&#10;    StringUtils(vector&lt;int&gt; _s) : n(_s.size() + 1), s(_s), sa(n), lcp(n, 0), tab_len(n + 1, 0){&#10;        s.emplace_back(numeric_limits&lt;int&gt;::min());&#10;        sa_inv = s;&#10;        vector&lt;int&gt; comp(s);&#10;        sort(comp.begin(), comp.end());&#10;        comp.erase(unique(comp.begin(), comp.end()), comp.end());&#10;        for(int i = 0; i &lt; n; ++i)&#10;            sa_inv[i] = distance(comp.begin(), lower_bound(comp.begin(), comp.end(), sa_inv[i]));&#10;        int m = comp.size();&#10;        for(int i = 0; m != n; ++i){&#10;            vector&lt;vector&lt;int&gt;&gt; table(m);&#10;            vector&lt;vector&lt;int&gt;&gt; table2(m);&#10;            for(int j = 0; j &lt; n; ++j){&#10;                table[sa_inv[(j + (1 &lt;&lt; i)) % n]].emplace_back(j);&#10;            }&#10;            for(int j = 0; j &lt; m; ++j)&#10;                for(auto idx : table[j]){&#10;                    table2[sa_inv[idx]].emplace_back(idx);&#10;                }&#10;            pair&lt;int,int&gt; pre{-1, -1};&#10;            int pm = m;&#10;            m = -1;&#10;            vector&lt;int&gt; nex(n);&#10;            for(int j = 0; j &lt; pm; ++j)&#10;                for(auto idx : table2[j]){&#10;                    auto p = make_pair(sa_inv[idx], sa_inv[(idx + (1 &lt;&lt; i)) % n]);&#10;                    if(p != pre){&#10;                        m++;&#10;                        pre = p;&#10;                    }&#10;                    nex[idx] = m;&#10;                }&#10;            sa_inv = move(nex);&#10;            m++;&#10;        }&#10;        for(int i = 0; i &lt; n; ++i){&#10;            sa[sa_inv[i]] = i;&#10;        }&#10;        int h = 0;&#10;        for(int i = 0; i &lt; n; ++i){&#10;            int j = (sa_inv[i] + 1 == n ? n : sa[sa_inv[i] + 1]);&#10;            if(h)&#10;                --h;&#10;            for(; i + h &lt; n &amp;&amp; j + h &lt; n &amp;&amp; s[i + h] == s[j + h]; ++h);&#10;            lcp[sa_inv[i]] = h;&#10;        }&#10;        lcp_arr.emplace_back(lcp);&#10;        for(int j = 0; (1 &lt;&lt; j) &lt; n; ++j){&#10;            lcp_arr.emplace_back(n);&#10;            for(int i = 0; i &lt; n; ++i)&#10;                lcp_arr[j + 1][i] = (i + (1 &lt;&lt; j) &lt; n ? min(lcp_arr[j][i], lcp_arr[j][i + (1 &lt;&lt; j)]) : lcp_arr[j][i]);&#10;        }&#10;        for(int i = 2; i &lt;= n; ++i)&#10;            tab_len[i] = tab_len[i &gt;&gt; 1] + 1;&#10;    }&#10;    // [l1, r1) &lt; [l2, r2)&#10;    bool le(int l1, int r1, int l2, int r2){&#10;        int len1 = r1 - l1;&#10;        int len2 = r2 - l2;&#10;        if(get_lcp(l1, l2) &gt;= min(len1, len2))&#10;            return len1 &lt; len2;&#10;        else&#10;            return sa_inv[l1] &lt; sa_inv[l2];&#10;    }&#10;    int get_lcp(int l, int r){&#10;        l = sa_inv[l];&#10;        r = sa_inv[r];&#10;        if(l &gt; r)&#10;            swap(l, r);&#10;        else if(l == r){&#10;            return n - sa[l] - 1;&#10;        }&#10;        int siz = r - l;&#10;        return min(lcp_arr[tab_len[siz]][l], lcp_arr[tab_len[siz]][r - (1 &lt;&lt; tab_len[siz])]);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="substrmatching" value="// doc: https://shibh308.github.io/library/library/lib/classes/substrmatching.cpp.html&#10;struct SubstrMatching{&#10;    int n;&#10;    string s;&#10;    vector&lt;int&gt; sa, lcp, lcp_table;&#10;    SubstrMatching(string s) : s(s), n(s.size()){&#10;        sa_is();&#10;        lcp_build();&#10;    }&#10;    vector&lt;int&gt; induced_sort(vector&lt;int&gt; v, int k){&#10;        if(v.size() == k){&#10;            vector&lt;int&gt; ret(v.size());&#10;            for(int i = 0; i &lt; v.size(); ++i)&#10;                ret[v[i]] = i;&#10;            return ret;&#10;        }&#10;        vector&lt;int&gt; type(v.size(), 1);&#10;        for(int i = v.size() - 2; i &gt;= 0; --i)&#10;            type[i] = (v[i] == v[i + 1] ? type[i + 1] : v[i] &lt; v[i + 1]);&#10;        vector&lt;int&gt; lms;&#10;        vector&lt;vector&lt;int&gt;&gt; lms_str;&#10;        for(int i = 0; i &lt; v.size() - 1; ++i){&#10;            if(!lms_str.empty())&#10;                lms_str.back().emplace_back(v[i + 1]);&#10;            if(!type[i] &amp;&amp; type[i + 1]){&#10;                lms_str.emplace_back(1, v[i + 1]);&#10;                type[i + 1] = 2 + lms.size();&#10;                lms.emplace_back(i + 1);&#10;            }&#10;        }&#10;        vector&lt;int&gt; v_cnt(k, 0);&#10;        for(auto x : v)&#10;            ++v_cnt[x];&#10;        vector&lt;int&gt; bin(k + 1, v.size());&#10;        for(int i = 0, idx = 0; i &lt; k; ++i){&#10;            bin[i] = idx;&#10;            idx += v_cnt[i];&#10;        }&#10;        auto calc = [&amp;](auto&amp; seed){&#10;            vector&lt;int&gt; cnt(k, 0);&#10;            vector&lt;int&gt; sa_v(v.size(), -1);&#10;            for(auto i : seed){&#10;                int ch = v[i];&#10;                sa_v[bin[ch + 1] - cnt[ch] - 1] = i;&#10;                ++cnt[ch];&#10;            }&#10;            cnt.assign(k, 0);&#10;            for(int i = 0; i &lt; v.size(); ++i){&#10;                int nex = sa_v[i] - 1;&#10;                if(nex &gt;= 0 &amp;&amp; type[nex] == 0){&#10;                    int ch = v[nex];&#10;                    sa_v[bin[ch] + cnt[ch]] = nex;&#10;                    ++cnt[ch];&#10;                }&#10;            }&#10;            cnt.assign(k, 0);&#10;&#10;            for(int i = v.size() - 1; i &gt;= 0; --i){&#10;                int nex = sa_v[i] - 1;&#10;                if(nex &lt; 0 || !type[nex])&#10;                    continue;&#10;                if(nex &gt;= 0 &amp;&amp; type[nex]){&#10;                    int ch = v[nex];&#10;                    sa_v[bin[ch + 1] - cnt[ch] - 1] = nex;&#10;                    ++cnt[ch];&#10;                }&#10;            }&#10;            return sa_v;&#10;        };&#10;        auto ret_sa = calc(lms);&#10;        int m = lms.size();&#10;        vector&lt;int&gt; lms_idx;&#10;        for(int i = 0; i &lt; v.size(); ++i){&#10;            if(type[ret_sa[i]] &gt;= 2)&#10;                lms_idx.emplace_back(type[ret_sa[i]] - 2);&#10;        }&#10;        int lms_cnt = 0;&#10;        vector&lt;int&gt; lms_id(m, -100);&#10;        for(int i = 0; i &lt; m; ++i){&#10;            if(i &amp;&amp; lms_str[lms_idx[i - 1]] != lms_str[lms_idx[i]])&#10;                ++lms_cnt;&#10;            lms_id[lms_idx[i]] = lms_cnt + 0;&#10;        }&#10;        vector&lt;int&gt; ret_seed = induced_sort(lms_id, lms_cnt + 1);&#10;        vector&lt;int&gt; seed(m, 0);&#10;        for(int i = 0; i &lt; m; ++i)&#10;            seed[i] = lms[ret_seed[m - i - 1]];&#10;        ret_sa = calc(seed);&#10;        return ret_sa;&#10;    }&#10;    void sa_is(){&#10;        unordered_set&lt;char&gt; c_uset;&#10;        for(int i = 0; i &lt; n; ++i)&#10;            c_uset.insert(s[i]);&#10;        set&lt;char&gt; c_set;&#10;        for(auto c : c_uset)&#10;            c_set.insert(c);&#10;        unordered_map&lt;int, int&gt; c_idx;&#10;        int k = 1;&#10;        for(auto c : c_set)&#10;            c_idx[c] = k++;&#10;        vector&lt;int&gt; v(n + 1, 0);&#10;        for(int i = 0; i &lt; n; ++i)&#10;            v[i] = c_idx[s[i]];&#10;        sa = induced_sort(v, k);&#10;    }&#10;    void lcp_build(){&#10;        vector&lt;int&gt; sa_inv(n + 1);&#10;        for(int i = 0; i &lt;= n; ++i)&#10;            sa_inv[sa[i]] = i;&#10;        lcp.assign(n + 1, 0);&#10;        for(int i = 0, p = 0; i &lt;= n; ++i){&#10;            if(sa_inv[i] == n)&#10;                continue;&#10;            for(; i + p &lt; n &amp;&amp; sa[sa_inv[i] + 1] + p &lt; n &amp;&amp; s[i + p] == s[sa[sa_inv[i] + 1] + p]; ++p);&#10;            lcp[sa_inv[i]] = p;&#10;            if(p &gt; 0)&#10;                --p;&#10;        }&#10;        int siz = 1;&#10;        for(; siz &lt;= n; siz *= 2);&#10;        lcp_table.resize(2 * siz, -1);&#10;        for(int i = 0; i &lt; n; ++i)&#10;            lcp_table[i + siz] = lcp[i];&#10;        for(int i = siz - 1; i &gt; 0; --i)&#10;            lcp_table[i] = min(lcp_table[i &lt;&lt; 1], lcp_table[(i &lt;&lt; 1) | 1]);&#10;    }&#10;    int match_len(string&amp; t){&#10;        int l = 0, r = lcp_table.size() / 2;&#10;        int l_lcp = 0;&#10;        int idx = 1;&#10;        while(r - l &gt; 1){&#10;            int mid = (l + r) &gt;&gt; 1;&#10;            int m_lcp = lcp_table[idx &lt;&lt;= 1];&#10;            if(m_lcp == lcp_table[0])&#10;                r = mid;&#10;            else if(l_lcp &lt; m_lcp){&#10;                l = mid;&#10;                ++idx;&#10;            }&#10;            else if(l_lcp &gt; m_lcp)&#10;                r = mid;&#10;            else{&#10;                for(m_lcp = l_lcp; m_lcp &lt; t.size() &amp;&amp; sa[mid] + m_lcp &lt; s.size() &amp;&amp; t[m_lcp] == s[sa[mid] + m_lcp]; ++m_lcp);&#10;                if(sa[mid] + m_lcp == s.size() || m_lcp == t.size() || s[sa[mid] + m_lcp] &lt; t[m_lcp]){&#10;                    l_lcp = m_lcp;&#10;                    l = mid;&#10;                    ++idx;&#10;                }else{&#10;                    r = mid;&#10;                }&#10;            }&#10;        }&#10;        return l_lcp;&#10;    }&#10;    bool contains(string&amp; t){&#10;        return match_len(t) == t.size();&#10;    }&#10;    int lower_bound(string&amp; t){&#10;        int l = 0, r = lcp_table.size() / 2;&#10;        int l_lcp = 0;&#10;        int idx = 1;&#10;        while(r - l &gt; 1){&#10;            int mid = (l + r) &gt;&gt; 1;&#10;            int m_lcp = lcp_table[idx &lt;&lt;= 1];&#10;&#10;            if(m_lcp == lcp_table[0])&#10;                r = mid;&#10;            else if(l_lcp &lt; m_lcp){&#10;                l = mid;&#10;                ++idx;&#10;            }&#10;            else if(l_lcp &gt; m_lcp)&#10;                r = mid;&#10;            else{&#10;                for(m_lcp = l_lcp; m_lcp &lt; t.size() &amp;&amp; sa[mid] + m_lcp &lt; s.size() &amp;&amp; t[m_lcp] == s[sa[mid] + m_lcp]; ++m_lcp);&#10;                if(sa[mid] + m_lcp == s.size() || m_lcp == t.size() || s[sa[mid] + m_lcp] &lt; t[m_lcp]){&#10;                    l_lcp = m_lcp;&#10;                    l = mid;&#10;                    ++idx;&#10;                }else{&#10;                    r = mid;&#10;                }&#10;            }&#10;        }&#10;        return r;&#10;    }&#10;    pair&lt;int,int&gt; find(string t){&#10;        --t.back();&#10;        auto l = lower_bound(t);&#10;        ++t.back();&#10;        auto r = lower_bound(t);&#10;        return make_pair(l, r);&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="succinctbitvector" value="// doc: https://shibh308.github.io/library/library/lib/classes/succinctbitvector.cpp.html&#10;struct FastSelect {&#10;    static const int l_size = 65536;&#10;    static const int m_size = 256;&#10;    static const int mb = 255;&#10;    static const int s_size = 32;&#10;    static const int ss_size = 8;&#10;&#10;    struct Table{&#10;        uint16_t l_table[m_size][m_size][s_size];&#10;        uint32_t s_table[m_size];&#10;        Table() : l_table(), s_table(){&#10;            for(int i = 0; i &lt; m_size; ++i)&#10;                for(int j = 0; j &lt; m_size; ++j){&#10;                    for(int k = 0; k &lt; s_size; ++k)&#10;                        l_table[i][j][k] = 0;&#10;                    for(int k = 0; k &lt; m_size; ++k){&#10;                        if(k &gt;= i &amp;&amp; k &lt; i + j)&#10;                            l_table[i][j][k &gt;&gt; 3] |= 1 &lt;&lt; ((k &amp; 7) * 2);&#10;                        else if(k &gt;= i + j)&#10;                            l_table[i][j][k &gt;&gt; 3] |= 2 &lt;&lt; ((k &amp; 7) * 2);&#10;                    }&#10;                }&#10;            for(int i = 0; i &lt; m_size; ++i){&#10;                s_table[i] = 0;&#10;                for(int j = 0; j &lt; ss_size; ++j){&#10;                    int c = 0;&#10;                    for(int k = 0; k &lt; ss_size; ++k){&#10;                        c += bool(i &amp; (1 &lt;&lt; k));&#10;                        if(j &lt; c){&#10;                            s_table[i] |= (k &lt;&lt; (j * 4));&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    };&#10;    const static Table tab;&#10;&#10;    struct AbstractSelect{virtual int select(int x) = 0;};&#10;    struct BigSelect : public AbstractSelect{&#10;        vector&lt;int&gt; w;&#10;        BigSelect(vector&lt;uint32_t&gt;&amp; v, int l, int r, bool fl){&#10;            for(int i = l; i &lt; r; ++i){&#10;                if(bool(v[i / s_size] &amp; (1u &lt;&lt; (i % s_size))) == fl){&#10;                    w.emplace_back(i - l);&#10;                }&#10;            }&#10;        }&#10;        int select(int x){return w[x];}&#10;    };&#10;    struct SmallSelect : public AbstractSelect{&#10;        vector&lt;uint32_t&gt;&amp; v;&#10;        int l;&#10;        bool fl;&#10;        vector&lt;int&gt; siz;&#10;        vector&lt;unsigned char&gt; w;&#10;        bool flag(int i){&#10;            return bool(v[(l + i) / s_size] &amp; (1u &lt;&lt; ((l + i) % s_size))) == fl;&#10;        }&#10;        uint16_t get(int i){&#10;            i += l;&#10;            if(i % s_size &lt;= 24){&#10;                return (v[i / s_size] &gt;&gt; (i % s_size)) &amp; 255;&#10;            }&#10;            else{&#10;                int l_bit = 32 - (i % s_size);&#10;                uint16_t lv = (v[i / s_size] &gt;&gt; (i % s_size));&#10;                uint16_t rv = v[i / s_size + 1] &amp; ((1u &lt;&lt; (8 - l_bit)) - 1);&#10;                return lv + (rv &lt;&lt; l_bit);&#10;            }&#10;        }&#10;        SmallSelect(vector&lt;uint32_t&gt;&amp; v, int l, int r, bool fl) : v(v), l(l), fl(fl){&#10;            int n = r - l;&#10;            siz.emplace_back(0);&#10;            for(int k = (n + 7) / 8; k != 1; k = (k + 3) / 4){&#10;                siz.emplace_back(siz.back() + (k + 3) / 4 * 4);&#10;            }&#10;            siz.emplace_back(siz.back() + 1);&#10;            w.assign(siz.back(), 0);&#10;            for(int i = 0; i &lt; n; ++i){&#10;                if(flag(i)){&#10;                    ++w[i / ss_size];&#10;                }&#10;            }&#10;            for(int i = 0; i &lt; siz.size() - 2; ++i){&#10;                for(int j = siz[i]; j &lt; siz[i + 1]; ++j){&#10;                    w[siz[i + 1] + (j - siz[i]) / 4] += w[j];&#10;                }&#10;            }&#10;        }&#10;        int select(int x){&#10;            int d = siz.size() - 1;&#10;            int idx = siz[d];&#10;            for(; d &gt; 0; --d){&#10;                int ch = siz[d - 1] + (idx - siz[d]) * 4;&#10;                int res = (tab.l_table[w[ch]][w[ch + 1]][x &gt;&gt; 3] &gt;&gt; ((x &amp; 7) * 2)) &amp; 3;&#10;                if(res &lt; 2){&#10;                    if(res)&#10;                        x -= w[ch];&#10;                    idx = ch + res;&#10;                }&#10;                else{&#10;                    x -= w[ch] + w[ch + 1];&#10;                    int res2 = (tab.l_table[w[ch + 2]][w[ch + 3]][x &gt;&gt; 3] &gt;&gt; ((x &amp; 7) * 2)) &amp; 3;&#10;                    assert(res2 &lt; 2);&#10;                    if(res2)&#10;                        x -= w[ch + 2];&#10;                    idx = ch + 2 + res2;&#10;                }&#10;            }&#10;            return idx * ss_size + ((tab.s_table[get(idx * ss_size) ^ (fl ? 0 : 255)] &gt;&gt; (x * 4)) &amp; 15);&#10;        }&#10;    };&#10;&#10;    int cnt;&#10;    vector&lt;AbstractSelect*&gt; b;&#10;    vector&lt;int&gt; st;&#10;    FastSelect(){}&#10;    FastSelect(int n, vector&lt;uint32_t&gt;&amp; v, bool fl) : cnt(0){&#10;        int s = 0;&#10;        for(int i = 0; i &lt; n; ++i){&#10;            if(bool(v[i / s_size] &amp; (1u &lt;&lt; (i % s_size))) == fl){&#10;                ++cnt;&#10;                if(cnt % mb == 0){&#10;                    if(i - s + 1 &gt; l_size)&#10;                        b.emplace_back(new BigSelect(v, s, i + 1, fl));&#10;                    else&#10;                        b.emplace_back(new SmallSelect(v, s, i + 1, fl));&#10;                    st.emplace_back(s);&#10;                    s = i + 1;&#10;                }&#10;            }&#10;        }&#10;        if(s != n){&#10;            st.emplace_back(s);&#10;            b.emplace_back(new BigSelect(v, s, n, fl));&#10;        }&#10;    }&#10;    int select(int x){&#10;        if(x &gt;= cnt)&#10;            return -1;&#10;        else{&#10;            return st[x / mb] + b[x / mb]-&gt;select(x % mb);&#10;        }&#10;    }&#10;};&#10;&#10;const FastSelect::Table FastSelect::tab = FastSelect::Table();&#10;&#10;struct SuccinctBitVector {&#10;    const int m_size = 256;&#10;    const int s_size = 32;&#10;    int n;&#10;    vector&lt;uint32_t&gt; l;&#10;    vector&lt;unsigned char&gt; m;&#10;    vector&lt;uint32_t&gt; s;&#10;    FastSelect sel[2];&#10;    SuccinctBitVector(int n) : n(n), l((n + m_size - 1) / m_size + 1, 0), m((n + s_size - 1) / s_size + 1, 0), s((n + s_size - 1) / s_size, 0){}&#10;    void set(int x, bool fl = true){&#10;        if(bool(s[x / s_size] &amp; (1u &lt;&lt; (x % s_size))) == fl)&#10;            return;&#10;        if(fl){&#10;            s[x / s_size] |= (1u &lt;&lt; (x % s_size));&#10;            ++l[x / m_size + 1];&#10;            ++m[x / s_size + 1];&#10;        }&#10;        else{&#10;            s[x / s_size] &amp;= ~(1u &lt;&lt; (x % s_size));&#10;            --l[x / m_size + 1];&#10;            --m[x / s_size + 1];&#10;        }&#10;    }&#10;    void build(){&#10;        for(int i = 0; i &lt; l.size() - 1; ++i)&#10;            l[i + 1] += l[i];&#10;        for(int i = 0; i &lt; m.size() - 1; ++i){&#10;            if(i % 8 != 7)&#10;                m[i + 1] += m[i];&#10;            else&#10;                m[i + 1] = 0;&#10;        }&#10;        sel[0] = FastSelect(n, s, 0);&#10;        sel[1] = FastSelect(n, s, 1);&#10;    }&#10;    // [0, x)&#10;    int rank(int x){&#10;        return l[x / m_size] + m[x / s_size] + __builtin_popcount(s[x / s_size] &amp; ((1uLL &lt;&lt; (x % s_size)) - 1));&#10;    }&#10;    int rank(int x, bool fl){&#10;        return fl ? rank(x) : x - rank(x);&#10;    }&#10;    // flがx回目に出現する位置(0-indexedなので注意)&#10;    int select(int x, bool fl = true){&#10;        return sel[fl].select(x);&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="suffixtree" value="// doc: https://shibh308.github.io/library/library/lib/classes/suffixtree.cpp.html&#10;struct SuffixTree{&#10;    // Weinerでの構築 [0,n)が葉 nが根 [n+1,)が内部節点 番兵'$'&#10;    struct Node{&#10;        int pos = -1, par = -1, par_len = -1, dep = 0, slink = -1;&#10;        int child = 0, plink = 0;&#10;    };&#10;    AVL_map&lt;char,int&gt; avl;&#10;    int n;&#10;    string s;&#10;    vector&lt;Node&gt; nodes;&#10;    vector&lt;int&gt; sa, sa_inv, lcp;&#10;    SuffixTree(string&amp; _s) : n(_s.size() + 1), s(_s + &quot;$&quot;), nodes(_s.size() + 3), sa(n), sa_inv(n), lcp(n){&#10;        nodes[n].slink = n;&#10;        nodes[n].par = n + 1;&#10;        nodes[n].par_len = 1;&#10;        for(int i = n - 1; i &gt;= 0; --i)&#10;            add(i);&#10;        make_sa();&#10;    }&#10;    void make_sa(){&#10;        stack&lt;pair&lt;int,bool&gt;&gt; sta;&#10;        int cnt = 0;&#10;        int lca = 0;&#10;        sta.emplace(n, false);&#10;        int x;&#10;        bool is_lca;&#10;        while(!sta.empty()){&#10;            tie(x, is_lca) = sta.top();&#10;            sta.pop();&#10;            if(is_lca){&#10;                lca = min(lca, x);&#10;                continue;&#10;            }&#10;            if(x &lt; n){&#10;                sa[cnt] = x;&#10;                if(cnt &gt; 0)&#10;                    lcp[cnt - 1] = lca;&#10;                lca = nodes[x].dep;&#10;                sa_inv[x] = cnt++;&#10;            }&#10;            auto chi = avl.list(nodes[x].child);&#10;            for(int i = chi.size() - 1; i &gt;= 0; --i){&#10;                sta.emplace(nodes[x].dep, true);&#10;                sta.emplace(chi[i].second, false);&#10;            }&#10;        }&#10;    }&#10;    int child(int x, char c){&#10;        auto res = avl.get(nodes[x].child, c);&#10;        if(res.second)&#10;            return res.first;&#10;        else&#10;            return -1;&#10;    }&#10;    int plink(int x, char c){&#10;        if(x == n + 1)&#10;            return n;&#10;        auto res = avl.get(nodes[x].plink, c);&#10;        if(res.second)&#10;            return res.first;&#10;        else&#10;            return -1;&#10;    }&#10;    void attach(int par, int ch, char c, int len){&#10;        nodes[par].child = avl.add(nodes[par].child, c, ch);&#10;        nodes[ch].par_len = len;&#10;        nodes[ch].par = par;&#10;        nodes[ch].dep = nodes[par].dep + len;&#10;    }&#10;    void add(int i){&#10;        int old = i + 1;&#10;        vector&lt;int&gt; path(1, old);&#10;        int vlen = s.size() - i;&#10;        while(plink(old, s[i]) == -1){&#10;            vlen -= nodes[old].par_len;&#10;            old = nodes[old].par;&#10;            path.emplace_back(old);&#10;        }&#10;        int now = plink(old, s[i]);&#10;        int ch = child(now, s[i + nodes[now].dep]);&#10;        int old_idx = path.size() - 1;&#10;        if(ch != -1){&#10;            int idx = nodes.size();&#10;            nodes.emplace_back();&#10;            int pos;&#10;            for(pos = nodes[ch].pos - nodes[ch].par_len; s[pos] == s[i + vlen]; pos += nodes[old].par_len){&#10;                old = path[--old_idx];&#10;                vlen += nodes[old].par_len;&#10;            }&#10;            nodes[idx].pos = pos;&#10;            attach(now, idx, s[nodes[ch].pos - nodes[ch].par_len], nodes[ch].par_len - (nodes[ch].pos - pos));&#10;            attach(idx, ch, s[pos], nodes[ch].pos - pos);&#10;            now = idx;&#10;            nodes[old].plink = avl.add(nodes[old].plink, s[i], idx);&#10;            nodes[idx].slink = old;&#10;        }&#10;        old = path.front();&#10;        nodes[old].plink = avl.add(nodes[old].plink, s[i], i);&#10;        nodes[i].slink = old;&#10;        attach(now, i, s[i + nodes[now].dep], s.size() - (i + nodes[now].dep));&#10;        nodes[i].pos = n;&#10;    }&#10;    void print(int st = -1, string t = &quot;&quot;){&#10;        if(st == -1)&#10;            st = n;&#10;        if(st &lt; n){&#10;            cout &lt;&lt; st &lt;&lt; &quot;: &quot; &lt;&lt; t &lt;&lt; endl;&#10;        }&#10;        else{&#10;            cout &lt;&lt; &quot;-&quot; &lt;&lt; &quot;: &quot; &lt;&lt; t &lt;&lt; endl;&#10;        }&#10;        for(auto p : avl.list(nodes[st].child)){&#10;            int ch = p.second;&#10;            t += s.substr(nodes[ch].pos - nodes[ch].par_len, nodes[ch].par_len);&#10;            print(ch, t);&#10;            t.erase(prev(t.end(), nodes[ch].par_len), t.end());&#10;        }&#10;    }&#10;    // 途中でマッチした場合は (マッチした辺の子, 子側からの距離) を返す&#10;    // ノードでマッチした場合は (マッチしたノード, 0) になる&#10;    // マッチしなかったら (n, 0) を返す&#10;    pair&lt;int,int&gt; match(string t){&#10;        int i = 0;&#10;        int x = n;&#10;        auto res = avl.list(nodes[x].child);&#10;&#10;        while(i != t.size()){&#10;            int ch = child(x, t[i]);&#10;            if(ch == -1)&#10;                return {-1, -1};&#10;            for(int j = 0; j &lt; nodes[ch].par_len; ++i, ++j){&#10;                if(i == t.size()){&#10;                    return {ch, nodes[ch].par_len - j};&#10;                }&#10;                int k = nodes[ch].pos - nodes[ch].par_len + j;&#10;                if(s[k] != t[i])&#10;                    return {n, -1};&#10;            }&#10;            x = ch;&#10;        }&#10;        return {x, 0};&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="treap" value="// doc: https://shibh308.github.io/library/library/lib/classes/treap.cpp.html&#10;template &lt;typename T, typename U = int&gt;&#10;struct Node{&#10;&#10;    using np = Node&lt;T, U&gt;*;&#10;&#10;    static np nil;&#10;&#10;    T val;&#10;    U lazy;&#10;    uint32_t pri;&#10;&#10;    int size;&#10;    T sum;&#10;&#10;    np l = nil;&#10;    np r = nil;&#10;&#10;    Node(T v, U OU = U()) : val(v), lazy(OU), pri(rndpri()), size(1), sum(v), l(nil), r(nil){}&#10;    Node(T v, U OU, uint32_t p) : val(v), lazy(OU), pri(p), size(1), sum(v), l(nil), r(nil){}&#10;&#10;    static uint32_t rndpri() {&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = time(0);&#10;        uint32_t t = x ^ (x &lt;&lt; 11);&#10;        x = y;&#10;        y = z;&#10;        z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return max&lt;uint32_t&gt;(1, w &amp; 0x3FFFFFFF);&#10;    }&#10;};&#10;&#10;&#10;template &lt;typename T, typename U = int&gt;&#10;class Treap{&#10;&#10;    using nt = Node&lt;T, U&gt;;&#10;    using np = nt*;&#10;    using F = function&lt;T(T, T)&gt;;&#10;    using G = function&lt;T(T, U, int)&gt;;&#10;    using H = function&lt;U(U, U)&gt;;&#10;&#10;public:&#10;&#10;    np root;&#10;    bool is_list;&#10;    F f;&#10;    G g;&#10;    H h;&#10;    T OT;&#10;    U OU;&#10;&#10;    Treap(bool is_list, F f, G g, H h, T OT, U OU) : root(nt::nil), is_list(is_list), f(f), g(g), h(h), OT(OT), OU(OU){}&#10;&#10;    Treap(T val, bool is_list, F f, G g, H h, T OT, U OU) : root(new nt(val)), is_list(is_list), f(f), g(g), h(h), OT(OT), OU(OU){}&#10;&#10;    // 配列で初期化する&#10;    Treap(vector&lt;T&gt; v, bool is_list, F f, G g, H h, T OT, U OU) : root(nt::nil), is_list(is_list), f(f), g(g), h(h), OT(OT), OU(OU){&#10;        for(auto&amp; xx : v)&#10;            root = _merge(root, new nt(xx, OU));&#10;    }&#10;&#10;    static Treap make(bool is_list, F f = [](T x, T){return x;}, T OT = T(), G g = [](auto x, auto, auto){return x;}, H h = [](auto x, auto){return x;}, U OU = U()){&#10;        assert(nt::nil != nullptr);&#10;        return Treap(is_list, f, g, h, OT, OU);&#10;    }&#10;&#10;    static Treap make(T val, bool is_list, F f = [](auto x, auto){return x;}, T OT = T(), G g = [](auto x, auto, auto){return x;}, H h = [](auto x, auto){return x;}, U OU = U()){&#10;        assert(nt::nil != nullptr);&#10;        return Treap(val, is_list, f, g, h, OT, OU);&#10;    }&#10;&#10;    static Treap make(vector&lt;T&gt; val, bool is_list, F f = [](auto x, auto){return x;}, T OT = T(), G g = [](auto x, auto, auto){return x;}, H h = [](auto x, auto){return x;}, U OU = U()){&#10;        assert(nt::nil != nullptr);&#10;        return Treap(val, is_list, f, g, h, OT, OU);&#10;    }&#10;&#10;    ~Treap(){&#10;        clear();&#10;        if(root != nt::nil)&#10;            delete root;&#10;    }&#10;&#10;    int _size(np x){return x == nt::nil ? 0 : x-&gt;size;}&#10;    T _sum(np x){return x == nt::nil ? OT : x-&gt;sum;}&#10;&#10;    np _update(np x){&#10;&#10;        if(x == nt::nil)&#10;            return x;&#10;&#10;        if(is_list){&#10;            _push(x);&#10;            _push(x-&gt;l);&#10;            _push(x-&gt;r);&#10;        }&#10;&#10;		x-&gt;sum = f(f(_sum(x-&gt;l), x-&gt;val), _sum(x-&gt;r));&#10;		x-&gt;size = _size(x-&gt;l) + _size(x-&gt;r) + 1;&#10;        return x;&#10;    }&#10;&#10;    void _push(np x){&#10;        if(x-&gt;lazy == OU)&#10;            return ;&#10;&#10;        x-&gt;sum = g(x-&gt;sum, x-&gt;lazy, x-&gt;size);&#10;        x-&gt;val = g(x-&gt;val, x-&gt;lazy, 1);&#10;&#10;        if(x-&gt;l != nt::nil)&#10;            x-&gt;l-&gt;lazy = h(x-&gt;l-&gt;lazy, x-&gt;lazy);&#10;        if(x-&gt;r != nt::nil)&#10;            x-&gt;r-&gt;lazy = h(x-&gt;r-&gt;lazy, x-&gt;lazy);&#10;&#10;        x-&gt;lazy = OU;&#10;&#10;    }&#10;&#10;    np _merge(np l, np r){&#10;        if(l == nt::nil || r ==nt::nil)&#10;            return l == nt::nil ? r : l;&#10;&#10;        if(l-&gt;pri &gt; r-&gt;pri){&#10;            l-&gt;r = _merge(l-&gt;r, r);&#10;            return _update(l);&#10;        }else{&#10;            r-&gt;l = _merge(l, r-&gt;l);&#10;            return _update(r);&#10;        }&#10;    }&#10;&#10;    pair&lt;np,np&gt; _split(np x, int k){&#10;        if(x == nt::nil)&#10;            return make_pair(nt::nil, nt::nil);&#10;&#10;        assert(0 &lt;= k &amp;&amp; k &lt;= _size(x));&#10;&#10;        if(k &lt;= _size(x-&gt;l)){&#10;            pair&lt;np, np&gt; s = _split(x-&gt;l, k);&#10;            x-&gt;l = s.second;&#10;            return make_pair(s.first, _update(x));&#10;&#10;        }else{&#10;            pair&lt;np, np&gt; s = _split(x-&gt;r, k - _size(x-&gt;l) - 1);&#10;            x-&gt;r = s.first;&#10;            return make_pair(_update(x), s.second);&#10;        }&#10;    }&#10;&#10;    np _insert(np x, int k, T val){&#10;        np l, r;&#10;        tie(l, r) = _split(x, k);&#10;        return _merge(_merge(l, new nt(val, OU)), r);&#10;    }&#10;&#10;    np _erase(np x, int k){&#10;        np l, r, m;&#10;        tie(l, r) = _split(x, k);&#10;        tie(m, r) = _split(r, 1);&#10;        if(m != nt::nil)&#10;            delete m;&#10;        return _merge(l, r);&#10;    }&#10;&#10;    void _set(np x, int k, T val){&#10;        _update(x);&#10;&#10;        if(k &lt; _size(x-&gt;l))&#10;            _set(x-&gt;l, k, val);&#10;        else if(_size(x-&gt;l) == k)&#10;            x-&gt;val = val;&#10;        else&#10;            _set(x-&gt;r, k - _size(x-&gt;l) - 1, val);&#10;&#10;        _update(x);&#10;    }&#10;&#10;    void _add(np x, int l, int r, U val){&#10;        assert(is_list);&#10;        _update(x);&#10;&#10;        if(x == nt::nil)&#10;            return ;&#10;        l = max(l, 0);&#10;        r = min(r, _size(x));&#10;&#10;        int sl = _size(x-&gt;l);&#10;&#10;        if(l &gt;= r)&#10;            return ;&#10;&#10;        if (l == 0 &amp;&amp; r == _size(x)){&#10;            x-&gt;lazy = h(x-&gt;lazy, val);&#10;        }&#10;        else{&#10;            if(l &lt;= sl &amp;&amp; sl &lt; r)&#10;                x-&gt;val = g(x-&gt;val, val, 1);&#10;&#10;            _add(x-&gt;l, l, r, val);&#10;            _add(x-&gt;r, l - sl - 1, r - sl - 1, val);&#10;        }&#10;&#10;        _update(x);&#10;    }&#10;&#10;    np _getnode(np x, int k){&#10;&#10;        _update(x);&#10;&#10;        assert(0 &lt;= k &amp;&amp; k &lt; _size(x));&#10;&#10;        if(k &lt; _size(x-&gt;l))&#10;            return _getnode(x-&gt;l, k);&#10;        else if(_size(x-&gt;l) == k)&#10;            return x;&#10;        else&#10;            return _getnode(x-&gt;r, k - _size(x-&gt;l) - 1);&#10;    }&#10;&#10;    T _get(np x, int k){&#10;        return _getnode(x, k)-&gt;val;&#10;    }&#10;&#10;    T _rangesum(np x, int l, int r){&#10;        _update(x);&#10;&#10;        l = max(l, 0);&#10;        r = min(r, _size(x));&#10;        if(l &gt;= r)&#10;            return OT;&#10;        if(l == 0 &amp;&amp; r == _size(x))&#10;            return _sum(x);&#10;&#10;        int sl = _size(x-&gt;l);&#10;        T ret = (l &lt;= sl &amp;&amp; sl &lt; r ? x-&gt;val : OT);&#10;        ret = f(_rangesum(x-&gt;l, l, r), ret);&#10;        ret = f(ret, _rangesum(x-&gt;r, l - sl - 1, r - sl - 1));&#10;        return ret;&#10;    }&#10;&#10;    int _lowerbound(np x, T val){&#10;        _update(x);&#10;&#10;        if(x == nt::nil)&#10;            return 0;&#10;        if(val &lt;= x-&gt;val)&#10;            return _lowerbound(x-&gt;l, val);&#10;        else&#10;            return _lowerbound(x-&gt;r,val) + _size(x-&gt;l) + 1;&#10;    }&#10;&#10;    int _upperbound(np x, T val){&#10;        _update(x);&#10;&#10;        if(x == nt::nil)&#10;            return 0;&#10;        if(val &lt; x-&gt;val)&#10;            return _upperbound(x-&gt;l, val);&#10;        else&#10;            return _upperbound(x-&gt;r,val) + _size(x-&gt;l) + 1;&#10;    }&#10;&#10;    np _insert(np x, T val){&#10;        return _insert(x, _lowerbound(x, val), val);&#10;    }&#10;&#10;    void _clear(np x){&#10;        if(x-&gt;l != nt::nil){&#10;            _clear(x-&gt;l);&#10;            delete(x-&gt;l);&#10;            x-&gt;l = nt::nil;&#10;        }&#10;        if(x-&gt;r != nt::nil){&#10;            _clear(x-&gt;r);&#10;            delete(x-&gt;r);&#10;            x-&gt;r = nt::nil;&#10;        }&#10;    }&#10;&#10;    void push_front(T val){&#10;        root = _merge(new nt(val, OU), root);&#10;    }&#10;&#10;    void push_back(T val){&#10;        root = _merge(root, new nt(val, OU));&#10;    }&#10;&#10;    void pop_front(){&#10;        root = _split(root, 1).second;&#10;    }&#10;&#10;    void pop_back(){&#10;        root = _split(root, _size(root) - 1).first;&#10;    }&#10;&#10;    // [0, k)と[k, size)に分割して, [k, size)側を返す&#10;    Treap split_left(int k){&#10;        np p;&#10;        tie(root, p) = _split(root, k);&#10;        return decltype(this)(f, g, h, p);&#10;    }&#10;&#10;    // [0, k)と[k, size)に分割して, [0, k)側を返す&#10;    Treap split_right(int k){&#10;        np p;&#10;        tie(p, root) = _split(root, k);&#10;        return decltype(this)(f, g, h, p);&#10;    }&#10;&#10;    // rootを含めたサイズの出力&#10;    int size(){&#10;        return (root == nt::nil ? 0 : root-&gt;size);&#10;    }&#10;&#10;    // k番目への代入&#10;    void set(int k, T val){&#10;        return _set(root, k, val);&#10;    }&#10;&#10;    // k番目への加算&#10;    void add(int k, U val){&#10;        assert(is_list);&#10;        return _add(root, k, k + 1, val);&#10;    }&#10;&#10;    // [l, r)への一様加算&#10;    void add(int l, int r, U val){&#10;        assert(is_list);&#10;        return _add(root, l, r, val);&#10;    }&#10;&#10;    // k番目の取得&#10;    T get(int k){&#10;        return _get(root, k);&#10;    }&#10;&#10;    // [l, r)の総和 (同様の実装でRMQ等も可能)&#10;    T get(int l, int r){&#10;        return _rangesum(root, l, r);&#10;    }&#10;&#10;    // k番目への挿入&#10;    void insert(int k, T val){&#10;        assert(is_list);&#10;        root = _insert(root, k, val);&#10;    }&#10;&#10;    // 適切な位置への挿入&#10;    void insert(T val){&#10;        root = _insert(root, val);&#10;    }&#10;&#10;    // val &lt;= get(k) となるような最小のk&#10;    int lowerbound(T val){&#10;        return _lowerbound(root, val);&#10;    }&#10;&#10;    // val &lt; get(k) となるような最小のk&#10;    int upperbound(T val){&#10;        return _upperbound(root, val);&#10;    }&#10;&#10;    // k番目の要素削除&#10;    void erase(int k){&#10;        root = _erase(root, k);&#10;    }&#10;&#10;    void clear(){&#10;        if(root != nt::nil){&#10;            _clear(root);&#10;            delete(root);&#10;            root = nt::nil;&#10;        }&#10;    }&#10;};&#10;&#10;const i64 val = 0;&#10;const i64 op = -1e9;&#10;using node_type = Node&lt;i64, i64&gt;;&#10;template&lt;&gt; node_type* node_type::nil = new node_type(0, op, 0);&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="trie" value="// doc: https://shibh308.github.io/library/library/lib/classes/trie.cpp.html&#10;template &lt;int size = 26, int start = 'a'&gt;&#10;struct Trie{&#10;    struct Node{&#10;        // 値, prefixに含む文字列の数, 文字列の数&#10;        int val, len, cnt, exist_cnt;&#10;        // 子のindex, 子の(indexの)一覧&#10;        vector&lt;int&gt; next, exist;&#10;        Node(int val = -1, int len = 0, bool back = false) : val(val), len(len), cnt(0), exist_cnt(back), next(size, -1){}&#10;    };&#10;&#10;    vector&lt;Node&gt; nodes;&#10;    Trie() : nodes(1){}&#10;&#10;    int insert(string&amp; s, int str_index = 0){&#10;        int pos = 0, idx = str_index;&#10;        while(idx != s.size()){&#10;            ++nodes[pos].cnt;&#10;            int c = s[idx] - start;&#10;            assert(c &lt; size);&#10;&#10;            if(nodes[pos].next[c] == -1){&#10;                nodes[pos].next[c] = nodes.size();&#10;                nodes[pos].exist.emplace_back(nodes.size());&#10;                nodes.emplace_back(c, nodes[pos].len + 1);&#10;            }&#10;            pos = nodes[pos].next[c];&#10;            ++idx;&#10;        }&#10;        ++nodes[pos].cnt;&#10;        ++nodes[pos].exist_cnt;&#10;        return pos;&#10;    }&#10;&#10;    // (sの部分文字列, s, sを部分文字列に含む文字列)に対して関数を実行する&#10;    // ラムダ内でtrie.nodes[idx].exist_cntを判定する事で, 挿入された文字列そのもの以外判定しなくなる&#10;    void query(string&amp; s, function&lt;void(int, string&amp;)&gt; f, bool from_prefix, bool correct, bool to_prefix, int str_index = 0){&#10;        int pos = 0, idx = str_index;&#10;        string str;&#10;        while(idx != s.size()){&#10;            if(from_prefix)&#10;                f(pos, str);&#10;            int c = s[idx] - start;&#10;            assert(c &lt; size);&#10;&#10;            if(nodes[pos].next[c] == -1)&#10;                return ;&#10;            pos = nodes[pos].next[c];&#10;            str += static_cast&lt;char&gt;(nodes[pos].val + start);&#10;            ++idx;&#10;        }&#10;        if(correct)&#10;            f(pos, str);&#10;        function&lt;void(int)&gt; dfs = [&amp;](int pos){&#10;            for(auto&amp; next : nodes[pos].exist){&#10;                char c = nodes[next].val + start;&#10;                if(to_prefix)&#10;                    f(pos, str);&#10;                str += c;&#10;                dfs(next);&#10;                str.pop_back();&#10;            }&#10;        };&#10;        dfs(pos);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="twothreetree" value="// doc: https://shibh308.github.io/library/library/lib/classes/twothreetree.cpp.html&#10;template &lt;typename T&gt;&#10;struct TwoThreeTree{&#10;    struct Node;&#10;    using Index = typename MemoryPool&lt;Node&gt;::Index;&#10;    struct Node{&#10;        int siz;&#10;        bool leaf;&#10;        T mi;&#10;        vector&lt;T&gt; v;&#10;        vector&lt;Index&gt; c;&#10;        Node(T val) : siz(1), leaf(true), v(1, val), c(0), mi(val){}&#10;        Node() : siz(0), leaf(false), v(0), c(0){}&#10;    };&#10;    MemoryPool&lt;Node&gt; pool;&#10;    static constexpr Index nil = {-1};&#10;    Index root;&#10;    TwoThreeTree(){root = nil;}&#10;&#10;    int size(){return root == nil ? 0 : pool[root].siz;}&#10;&#10;    Index insert(T x, Index idx){&#10;        Node&amp; node = pool[idx];&#10;        if(node.leaf){&#10;            // 葉は無視するため&#10;            int ins = 0;&#10;            for(; node.v[ins] &lt;= x &amp;&amp; ins &lt; node.v.size(); ++ins);&#10;            for(; ins &lt; node.v.size(); ++ins)&#10;                swap(x, node.v[ins]);&#10;            node.v.emplace_back(x);&#10;            node.mi = node.v[0];&#10;        }&#10;        else{&#10;            int ins = 0;&#10;            for(; node.v[ins] &lt;= x &amp;&amp; ins &lt; node.v.size(); ++ins);&#10;            Index ret = insert(x, node.c[ins]);&#10;            if(ret != nil){&#10;                T key = pool[ret].mi;&#10;                for(; ins &lt; node.v.size(); ++ins){&#10;                    swap(key, node.v[ins]);&#10;                    swap(ret, node.c[ins + 1]);&#10;                }&#10;                node.v.emplace_back(key);&#10;                node.c.emplace_back(ret);&#10;            }&#10;            node.mi = pool[node.c[0]].mi;&#10;        }&#10;        ++node.siz;&#10;        if(node.v.size() &gt; 2){&#10;            assert(node.v.size() == 3);&#10;            assert(node.leaf || node.c.size() == 4);&#10;            Index new_idx = pool.alloc();&#10;            auto&amp; new_node = pool[new_idx];&#10;            new_node.c.clear();&#10;            new_node.c.shrink_to_fit();&#10;            assert(new_node.c.empty());&#10;            new_node.leaf = node.leaf;&#10;            if(node.leaf){&#10;                new_node.v = {node.v[2]};&#10;                new_node.mi = node.v[2];&#10;                node.v.pop_back();&#10;                new_node.siz = 1;&#10;                --node.siz;&#10;            }&#10;            else{&#10;                node.v = {node.v[0]};&#10;                new_node.v = {node.v[2]};&#10;                new_node.c = {node.c[2], node.c[3]};&#10;                new_node.mi = pool[node.c[2]].mi;&#10;                node.c = {node.c[0], node.c[1]};&#10;&#10;                new_node.siz = pool[new_node.c[0]].siz + pool[new_node.c[1]].siz;&#10;                node.siz -= new_node.siz;&#10;            }&#10;            assert(!node.leaf || node.c.empty());&#10;            return new_idx;&#10;        }&#10;        return nil;&#10;    }&#10;&#10;    void insert(T x){&#10;        if(root == nil){&#10;            root = pool.alloc();&#10;            pool[root] = Node(x);&#10;            assert(pool[root].c.empty());&#10;        }&#10;        else{&#10;            Index res = insert(x, root);&#10;            if(res != nil){&#10;                Index new_idx = pool.alloc();&#10;                auto&amp; new_node = pool[new_idx];&#10;                new_node.leaf = false;&#10;                new_node.v = {pool[res].mi};&#10;                new_node.c = {root, res};&#10;                new_node.mi = pool[root].mi;&#10;                new_node.siz = pool[root].siz + pool[res].siz;&#10;                assert(new_node.v.size() == 1);&#10;                assert(new_node.c.size() == 2);&#10;                root = new_idx;&#10;            }&#10;        }&#10;        Index idx = root;&#10;        while(!pool[idx].leaf)&#10;            idx = pool[idx].c[0];&#10;    }&#10;&#10;    // (削除できたか, 該当ノードが削除されたか)&#10;    short erase(T x, Index idx){&#10;        Node&amp; node = pool[idx];&#10;        if(node.leaf){&#10;            if(node.v.size() == 1){&#10;                if(node.v[0] != x)&#10;                    return 0;&#10;                return 2;&#10;            }&#10;            else{&#10;                assert(node.v.size() == 2);&#10;                bool fl = (node.v[1] == x);&#10;                if(node.v[fl] != x)&#10;                    return 0;&#10;                node.v = {node.v[fl ^ 1]};&#10;                node.mi = node.v[0];&#10;                --node.siz;&#10;                return 1;&#10;            }&#10;        }&#10;        else{&#10;            int ins = 0;&#10;            for(; node.v[ins] &lt;= x &amp;&amp; ins &lt; node.v.size(); ++ins);&#10;            short res = erase(x, node.c[ins]);&#10;            node.mi = pool[node.c[0]].mi;&#10;            if(res)&#10;                --node.siz;&#10;            if(res == 3){&#10;                // 子はまだ削除されてないので, 兄弟で併合する処理を書く&#10;                assert(node.c.size() == 2 || node.c.size() == 3);&#10;                // 兄弟からノードを取ってくる&#10;                if(ins + 1 &lt; node.c.size() &amp;&amp; pool[node.c[ins + 1]].v.size() == 2){&#10;                    // 右とマージ&#10;                    Node&amp; target = pool[node.c[ins]];&#10;                    Node&amp; bro = pool[node.c[ins + 1]];&#10;                    assert(target.v.size() == 1);&#10;                    // target.v = {target.v[0]};&#10;                    target.v = {pool[bro.c[0]].mi};&#10;                    bro.v = {bro.v[1]};&#10;                    bro.siz -= pool[bro.c[0]].siz;&#10;                    target.siz += pool[bro.c[0]].siz;&#10;                    target.c = {target.c[0], bro.c[0]};&#10;                    bro.c = {bro.c[1], bro.c[2]};&#10;                    node.v[ins] = bro.mi = pool[bro.c[0]].mi;&#10;                }&#10;                else if(ins &amp;&amp; pool[node.c[ins - 1]].v.size() == 2){&#10;                    // 左とマージ&#10;                    Node&amp; bro = pool[node.c[ins - 1]];&#10;                    Node&amp; target = pool[node.c[ins]];&#10;                    bro.siz -= pool[bro.c[2]].siz;&#10;                    target.siz += pool[bro.c[2]].siz;&#10;                    target.c = {bro.c[2], target.c[0]};&#10;                    target.v[0] = pool[target.c[1]].mi;&#10;                    bro.v.pop_back();&#10;                    bro.c.pop_back();&#10;                    node.v[ins - 1] = target.mi = pool[target.c[0]].mi;&#10;                }&#10;                else{&#10;                    // 親のノードが2つなので削除して解決するパターン&#10;                    if(node.v.size() == 2){&#10;                        // マージした後に解決するパターン&#10;                        if(ins + 1 &lt; node.v.size()){&#10;                            // 右とマージして解決させる&#10;                            Node&amp; target = pool[node.c[ins]];&#10;                            Node&amp; bro = pool[node.c[ins + 1]];&#10;                            assert(target.v.size() == 1 &amp;&amp; target.c.size() == 1);&#10;                            if(!(bro.v.size() == 1 &amp;&amp; bro.c.size() == 2)){&#10;                                print();&#10;                            }&#10;                            assert(bro.v.size() == 1 &amp;&amp; bro.c.size() == 2);&#10;                            target.siz += bro.siz;&#10;                            target.v = {pool[bro.c[0]].mi, pool[bro.c[1]].mi};&#10;                            target.c = {target.c[0], bro.c[0], bro.c[1]};&#10;                        }&#10;                        else{&#10;                            --ins;&#10;                            Node&amp; target = pool[node.c[ins + 1]];&#10;                            Node&amp; bro = pool[node.c[ins]];&#10;                            assert(target.v.size() == 1 &amp;&amp; target.c.size() == 1);&#10;                            assert(bro.v.size() == 1 &amp;&amp; bro.c.size() == 2);&#10;                            bro.siz += target.siz;&#10;                            bro.v = {pool[bro.c[1]].mi, pool[target.c[0]].mi};&#10;                            bro.c.emplace_back(target.c[0]);&#10;                        }&#10;                        ++ins;&#10;                        for(; ins &lt; node.v.size(); ++ins){&#10;                            if(ins + 1 != node.v.size())&#10;                                swap(node.v[ins], node.v[ins + 1]);&#10;                            swap(node.c[ins], node.c[ins + 1]);&#10;                        }&#10;                        pool.free(node.c.back());&#10;                        node.v.pop_back();&#10;                        node.c.pop_back();&#10;                        assert(node.v.size() == 1);&#10;                    }&#10;                    else{&#10;                        // 2つをマージするパターン&#10;                        Node&amp; l = pool[node.c[0]];&#10;                        Node&amp; r = pool[node.c[1]];&#10;                        assert(l.c.size() + r.c.size() == 3);&#10;                        l.c.insert(l.c.end(), r.c.begin(), r.c.end());&#10;                        assert(l.c.size() == 3);&#10;                        l.siz += r.siz;&#10;                        l.v = {pool[l.c[1]].mi, pool[l.c[2]].mi};&#10;                        pool.free(node.c[1]);&#10;                        node.c.pop_back();&#10;                        assert(node.c.size() == 1);&#10;                        node.v = {pool[l.c[1]].mi};&#10;                        node.mi = l.mi;&#10;                        node.siz = l.siz;&#10;                        return 3;&#10;                    }&#10;                }&#10;                node.v[0] = pool[node.c[1]].mi;&#10;                node.mi = pool[node.c[0]].mi;&#10;                return 1;&#10;            }&#10;            else if(res == 2){&#10;                if(node.v.size() == 2){&#10;                    pool.free(node.c[ins]);&#10;                    for(; ins &lt; node.v.size(); ++ins){&#10;                        if(ins + 1 != node.v.size())&#10;                            swap(node.v[ins], node.v[ins + 1]);&#10;                        swap(node.c[ins], node.c[ins + 1]);&#10;                    }&#10;                    node.v.pop_back();&#10;                    node.c.pop_back();&#10;                    node.mi = pool[node.c[0]].mi;&#10;                    return 1;&#10;                }&#10;                else{&#10;                    assert(node.v.size() == 1);&#10;                    assert(node.c.size() == 2);&#10;                    // 兄弟ノード分の処理を親に任せるようにする&#10;                    Node&amp; ch = pool[node.c[ins ^ 1]];&#10;                    if(ch.v.size() == 2){&#10;                        vector&lt;int&gt; vs = ch.v;&#10;                        vector&lt;Index&gt; cs = ch.c;&#10;                        pool[node.c[0]].siz = pool[node.c[1]].siz = 1;&#10;                        pool[node.c[0]].v = {vs[0]};&#10;                        pool[node.c[1]].v = {vs[1]};&#10;                        pool[node.c[0]].mi = pool[node.c[0]].v[0];&#10;                        node.v[0] = pool[node.c[1]].mi = pool[node.c[1]].v[0];&#10;                        node.siz = 2;&#10;                        node.mi = pool[node.c[0]].mi;&#10;                        return 1;&#10;                    }&#10;                    node.c = {node.c[ins ^ 1]};&#10;                    assert(ch.v.size() == 1);&#10;                    node.v = {ch.mi};&#10;                    node.mi = ch.mi;&#10;                    node.siz = ch.siz;&#10;                    assert(node.c.size() == 1);&#10;                    return 3;&#10;                }&#10;            }&#10;            if(ins)&#10;                node.v[ins - 1] = pool[node.c[ins]].mi;&#10;            return res;&#10;        }&#10;    }&#10;&#10;    bool erase(T x){&#10;        if(root == nil)&#10;            return false;&#10;        int res = erase(x, root);&#10;        if(res == 2)&#10;            root = nil;&#10;        if(res == 3){&#10;            // 親を見る処理で詰まってる(高さが減る)&#10;            assert(pool[root].v.size() == 1);&#10;            assert(pool[root].c.size() == 1);&#10;            Index new_root = pool[root].c[0];&#10;            pool.free(root);&#10;            root = new_root;&#10;        }&#10;        return res;&#10;    }&#10;&#10;    pair&lt;T, bool&gt; lower_bound(T x, Index idx = nil){&#10;        if(idx == nil)&#10;            idx = root;&#10;        if(root == nil)&#10;            return make_pair(T(), false);&#10;        bool fl = false;&#10;        T nex_val;&#10;        while(1){&#10;            Node&amp; node = pool[idx];&#10;            int ins = 0;&#10;            if(node.leaf){&#10;                for(; node.v[ins] &lt; x &amp;&amp; ins &lt; node.v.size(); ++ins);&#10;                assert(node.c.empty());&#10;                if(ins == node.v.size())&#10;                    return make_pair(fl ? nex_val : T(), fl);&#10;                return make_pair(pool[idx].v[ins], true);&#10;            }&#10;            for(; node.v[ins] &lt;= x &amp;&amp; ins &lt; node.v.size(); ++ins);&#10;            idx = node.c[ins];&#10;            if(ins + 1 &lt; node.c.size()){&#10;                fl = true;&#10;                nex_val = pool[node.c[ins + 1]].mi;&#10;            }&#10;        }&#10;    }&#10;&#10;    void print(Index idx = nil, int cnt = 0){&#10;        if(idx == nil)&#10;            idx = root;&#10;        if(idx == nil){&#10;            cout &lt;&lt; &quot;nil(0)[0]&quot; &lt;&lt; endl;&#10;            return;&#10;        }&#10;        string cs = &quot;&quot;;&#10;        for(int i = 0; i &lt; cnt; ++i)&#10;            cs += ' ';&#10;        auto&amp; node = pool[idx];&#10;        // cout &lt;&lt; cs &lt;&lt; &quot;idx: &quot; &lt;&lt; idx &lt;&lt; &quot; val: &quot; &lt;&lt; node.v[0] &lt;&lt;  &quot; / leaf: &quot; &lt;&lt; node.leaf &lt;&lt; endl;&#10;        for(int i = 0; i &lt; max(node.v.size(), node.c.size()); ++i){&#10;            if(!node.leaf){&#10;                if(i &lt; node.c.size()){&#10;                    print(node.c[i], cnt + 8);&#10;                }&#10;            }&#10;            if(i &lt; node.v.size()){&#10;                if(i == 0){&#10;                    cout &lt;&lt; cs &lt;&lt; &quot; &quot; &lt;&lt; node.v[i] &lt;&lt; &quot; (&quot; &lt;&lt; node.mi &lt;&lt; &quot;){&quot; &lt;&lt; node.siz &lt;&lt; &quot;}[&quot; &lt;&lt; idx.idx &lt;&lt; &quot;]&quot;;&#10;                    if(node.leaf){&#10;                        cout &lt;&lt; &quot;[&quot;;&#10;                        for(int i = 0; i &lt; node.c.size(); ++i){&#10;                            cout &lt;&lt; node.c[i].idx;&#10;                            if(i)&#10;                                cout &lt;&lt; &quot;/&quot;;&#10;                        }&#10;                        cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;&#10;                    }&#10;                    else&#10;                        cout &lt;&lt; endl;&#10;                }&#10;                else&#10;                    cout &lt;&lt; cs &lt;&lt; &quot; &quot; &lt;&lt; node.v[i] &lt;&lt; endl;&#10;            }&#10;        }&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="unionfind" value="// doc: https://shibh308.github.io/library/library/lib/classes/unionfind.cpp.html&#10;struct UnionFind{&#10;    vector&lt;int&gt; par;&#10;    int count;&#10;    UnionFind(int n) : par(n, -1), count(0){}&#10;    int Find(int x){return par[x] &lt; 0 ? x : Find(par[x]);}&#10;    int Size(int x){return par[x] &lt; 0 ? -par[x] : Size(par[x]);}&#10;    bool Unite(int x, int y){&#10;        x = Find(x);&#10;        y = Find(y);&#10;        if(x == y)&#10;            return false;&#10;        if(par[x] &gt; par[y])&#10;            swap(x, y);&#10;        par[x] += par[y];&#10;        par[y] = x;&#10;        return ++count;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="vanemdeboastree" value="// doc: https://shibh308.github.io/library/library/lib/classes/vanemdeboastree.cpp.html&#10;template &lt;uint32_t W, uint32_t NULL_FLAG = ~0u&gt;&#10;struct VanEmdeBoasTree{&#10;&#10;    // サイズ2^(2^U)のノード&#10;    // U=0からでサイズが2, 4, 16, 256, 65536, となる&#10;    struct Node{&#10;        uint32_t u, ma, mi;&#10;        Node* aux;&#10;        vector&lt;Node*&gt; c;&#10;        Node(int u, int n) : u(u), mi(NULL_FLAG), ma(0){&#10;            if(u){&#10;                while(n){&#10;                    int d = min(1 &lt;&lt; (1 &lt;&lt; (u - 1)), n);&#10;                    Node *node = new Node(u - 1, d);&#10;                    c.push_back(node);&#10;                    n -= d;&#10;                }&#10;                aux = new Node(u - 1, c.size());&#10;            }&#10;        }&#10;    };&#10;    Node* root;&#10;    VanEmdeBoasTree(){&#10;        root = new Node(32 - __builtin_clz(W - 1), 1 &lt;&lt; W);&#10;        insert((1 &lt;&lt; W) - 1, root);&#10;    }&#10;&#10;    bool insert(uint32_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;u == 0){&#10;            bool fl = (ptr-&gt;ma &lt; key) || (key &lt; ptr-&gt;mi);&#10;            ptr-&gt;ma = max(ptr-&gt;ma, key);&#10;            ptr-&gt;mi = min(ptr-&gt;mi, key);&#10;            return fl;&#10;        }&#10;        if(ptr-&gt;mi &gt; ptr-&gt;ma){&#10;            ptr-&gt;mi = ptr-&gt;ma = key;&#10;            return true;&#10;        }&#10;        if(key &lt; ptr-&gt;mi){&#10;            swap(key, ptr-&gt;mi);&#10;        }&#10;        else if(ptr-&gt;mi == key)&#10;            return false;&#10;        if(ptr-&gt;ma &lt; key)&#10;            ptr-&gt;ma = key;&#10;&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        uint32_t idx = uint64_t(key) &gt;&gt; shift_cnt;&#10;        uint32_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1u);&#10;&#10;        assert(idx &lt; ptr-&gt;c.size());&#10;&#10;        if(ptr-&gt;c[idx]-&gt;mi &gt; ptr-&gt;c[idx]-&gt;ma){&#10;            insert(idx, ptr-&gt;aux);&#10;        }&#10;        return insert(next_key, ptr-&gt;c[idx]);&#10;    }&#10;&#10;    bool erase(uint32_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;mi &gt; ptr-&gt;ma){&#10;            return false;&#10;        }&#10;        if(ptr-&gt;mi == ptr-&gt;ma){&#10;            if(ptr-&gt;mi == key){&#10;                ptr-&gt;mi = NULL_FLAG;&#10;                ptr-&gt;ma = 0;&#10;                return true;&#10;            }&#10;            return false;&#10;        }&#10;        if(ptr-&gt;u == 0){&#10;            // 2要素あるうちの1要素が残る&#10;            assert(ptr-&gt;mi == key || ptr-&gt;ma == key);&#10;            i64 x = ptr-&gt;mi == key ? ptr-&gt;ma : ptr-&gt;mi;&#10;            ptr-&gt;mi = ptr-&gt;ma = x;&#10;            return true;&#10;        }&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        if(ptr-&gt;mi == key)&#10;            ptr-&gt;mi = key = ((ptr-&gt;aux-&gt;mi &lt;&lt; shift_cnt) | ptr-&gt;c[ptr-&gt;aux-&gt;mi]-&gt;mi);&#10;&#10;        uint32_t idx = uint64_t(key) &gt;&gt; shift_cnt;&#10;        uint32_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1u);&#10;        auto nex = ptr-&gt;c[idx];&#10;        if(erase(next_key, nex)){&#10;            if(nex-&gt;mi &gt; nex-&gt;ma)&#10;                erase(idx, ptr-&gt;aux);&#10;            if(ptr-&gt;ma == key){&#10;                if(ptr-&gt;aux-&gt;mi &gt; ptr-&gt;aux-&gt;ma)&#10;                    ptr-&gt;ma = ptr-&gt;mi;&#10;                else&#10;                    ptr-&gt;ma = ((ptr-&gt;aux-&gt;ma &lt;&lt; shift_cnt) | ptr-&gt;c[ptr-&gt;aux-&gt;ma]-&gt;ma);&#10;            }&#10;            return true;&#10;        }&#10;        else&#10;            return false;&#10;    }&#10;&#10;    uint32_t lower_bound(uint32_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;u == 0){&#10;            assert(key &lt;= ptr-&gt;ma);&#10;            return key &lt;= ptr-&gt;mi ? ptr-&gt;mi : ptr-&gt;ma;&#10;        }&#10;        if(key &lt;= ptr-&gt;mi){&#10;            assert(ptr-&gt;mi != NULL_FLAG);&#10;            return ptr-&gt;mi;&#10;        }&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        uint32_t idx = uint64_t(key) &gt;&gt; shift_cnt;&#10;        uint32_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1u);&#10;        assert(idx &lt; ptr-&gt;c.size());&#10;&#10;        auto nex = ptr-&gt;c[idx];&#10;        if(nex-&gt;mi != NULL_FLAG &amp;&amp; next_key &lt;= nex-&gt;ma){&#10;            return (idx &lt;&lt; shift_cnt) | lower_bound(next_key, nex);&#10;        }&#10;&#10;        uint64_t i = lower_bound(idx + 1, ptr-&gt;aux);&#10;        return (i &lt;&lt; shift_cnt) | ptr-&gt;c[i]-&gt;mi;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="vanemdeboastree2" value="// doc: https://shibh308.github.io/library/library/lib/classes/vanemdeboastree2.cpp.html&#10;// 必要な所だけ作るvEB木&#10;template &lt;uint32_t W, uint64_t NULL_FLAG = ~0uLL&gt;&#10;struct VanEmdeBoasTree{&#10;&#10;    struct Node{&#10;        uint64_t u, ma, mi;&#10;        Node* aux;&#10;        HashMap&lt;int, Node*&gt; c;&#10;        Node(int u) : u(u), mi(NULL_FLAG), ma(0){&#10;            if(u)&#10;                aux = new Node(u - 1);&#10;        }&#10;    };&#10;    Node* root;&#10;    VanEmdeBoasTree(){&#10;        root = new Node(64 - __builtin_clzll(W - 1));&#10;        insert((1uLL &lt;&lt; W) - 1, root);&#10;    }&#10;&#10;    Node* child(Node* ptr, uint64_t idx){&#10;        assert(ptr-&gt;u &gt; 0);&#10;        auto res = ptr-&gt;c.find(idx);&#10;        if(res.second)&#10;            return res.first;&#10;        ptr-&gt;c.add(idx, new Node(ptr-&gt;u - 1));&#10;        return ptr-&gt;c.find(idx).first;&#10;    }&#10;&#10;    bool insert(uint64_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;u == 0){&#10;            bool fl = (ptr-&gt;ma &lt; key) || (key &lt; ptr-&gt;mi);&#10;            ptr-&gt;ma = max(ptr-&gt;ma, key);&#10;            ptr-&gt;mi = min(ptr-&gt;mi, key);&#10;            return fl;&#10;        }&#10;        if(ptr-&gt;mi &gt; ptr-&gt;ma){&#10;            ptr-&gt;mi = ptr-&gt;ma = key;&#10;            return true;&#10;        }&#10;        if(key &lt; ptr-&gt;mi){&#10;            swap(key, ptr-&gt;mi);&#10;        }&#10;        else if(ptr-&gt;mi == key)&#10;            return false;&#10;        if(ptr-&gt;ma &lt; key)&#10;            ptr-&gt;ma = key;&#10;&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        uint64_t idx = key &gt;&gt; shift_cnt;&#10;        uint64_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1);&#10;&#10;        if(child(ptr, idx)-&gt;mi &gt; child(ptr, idx)-&gt;ma)&#10;            insert(idx, ptr-&gt;aux);&#10;        return insert(next_key, child(ptr, idx));&#10;    }&#10;&#10;    bool erase(uint64_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;mi &gt; ptr-&gt;ma)&#10;            return false;&#10;        if(ptr-&gt;mi == ptr-&gt;ma){&#10;            if(ptr-&gt;mi == key){&#10;                ptr-&gt;mi = NULL_FLAG;&#10;                ptr-&gt;ma = 0;&#10;                return true;&#10;            }&#10;            return false;&#10;        }&#10;        if(ptr-&gt;u == 0){&#10;            // 2要素あるうちの1要素が残る&#10;            assert(ptr-&gt;mi == key || ptr-&gt;ma == key);&#10;            uint64_t x = ptr-&gt;mi == key ? ptr-&gt;ma : ptr-&gt;mi;&#10;            ptr-&gt;mi = ptr-&gt;ma = x;&#10;            return true;&#10;        }&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        if(ptr-&gt;mi == key)&#10;            ptr-&gt;mi = key = ((ptr-&gt;aux-&gt;mi &lt;&lt; shift_cnt) | child(ptr, ptr-&gt;aux-&gt;mi)-&gt;mi);&#10;&#10;        uint64_t idx = uint64_t(key) &gt;&gt; shift_cnt;&#10;        uint64_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1);&#10;        auto nex = child(ptr, idx);&#10;        if(erase(next_key, nex)){&#10;            if(nex-&gt;mi &gt; nex-&gt;ma)&#10;                erase(idx, ptr-&gt;aux);&#10;            if(ptr-&gt;ma == key){&#10;                if(ptr-&gt;aux-&gt;mi &gt; ptr-&gt;aux-&gt;ma)&#10;                    ptr-&gt;ma = ptr-&gt;mi;&#10;                else&#10;                    ptr-&gt;ma = ((ptr-&gt;aux-&gt;ma &lt;&lt; shift_cnt) | child(ptr, ptr-&gt;aux-&gt;ma)-&gt;ma);&#10;            }&#10;            return true;&#10;        }&#10;        else&#10;            return false;&#10;    }&#10;&#10;    uint32_t lower_bound(uint64_t key, Node* ptr = nullptr){&#10;        if(ptr == nullptr)&#10;            ptr = root;&#10;        if(ptr-&gt;u == 0){&#10;            assert(key &lt;= ptr-&gt;ma);&#10;            return key &lt;= ptr-&gt;mi ? ptr-&gt;mi : ptr-&gt;ma;&#10;        }&#10;        if(key &lt;= ptr-&gt;mi){&#10;            assert(ptr-&gt;mi != NULL_FLAG);&#10;            return ptr-&gt;mi;&#10;        }&#10;        int shift_cnt = 1 &lt;&lt; (ptr-&gt;u - 1);&#10;        uint64_t idx = uint64_t(key) &gt;&gt; shift_cnt;&#10;        uint64_t next_key = key &amp; ((1uLL &lt;&lt; shift_cnt) - 1);&#10;&#10;        auto nex = child(ptr, idx);&#10;        if(nex-&gt;mi != NULL_FLAG &amp;&amp; next_key &lt;= nex-&gt;ma){&#10;            return (idx &lt;&lt; shift_cnt) | lower_bound(next_key, nex);&#10;        }&#10;&#10;        uint64_t i = lower_bound(idx + 1, ptr-&gt;aux);&#10;        return (i &lt;&lt; shift_cnt) | child(ptr, i)-&gt;mi;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="waveletmatrix" value="// doc: https://shibh308.github.io/library/library/lib/classes/waveletmatrix.cpp.html&#10;template &lt;typename T, int W&gt;&#10;struct WaveletMatrix{&#10;&#10;    array&lt;BitVector, W&gt; bv;&#10;    array&lt;int, W&gt; zero_cnt;&#10;&#10;    WaveletMatrix(vector&lt;T&gt;&amp; a){&#10;        int n = a.size();&#10;        vector&lt;T&gt; v(a);&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            vector&lt;uint64_t&gt; b((n &gt;&gt; 6) + 1, 0);&#10;            vector&lt;T&gt; v1, v2;&#10;            for(int j = 0; j &lt; n; ++j){&#10;                ((v[j] &gt;&gt; i) &amp; 1 ? v2 : v1).push_back(v[j]);&#10;                b[j &gt;&gt; 6] |= uint64_t((v[j] &gt;&gt; i) &amp; 1) &lt;&lt; (j &amp; 63);&#10;            }&#10;            for(int j = 0; j &lt; v.size(); ++j)&#10;                v[j] = (j &lt; v1.size() ? v1[j] : v2[j - v1.size()]);&#10;            bv[i].v = move(b);&#10;            bv[i].build();&#10;            zero_cnt[i] = bv[i].rank(n, 0);&#10;        }&#10;    }&#10;&#10;    // [l, r)内のxの数&#10;    int count(int l, int r, T x){&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (x &gt;&gt; i) &amp; 1;&#10;            int st = bv[i].rank(l, fl);&#10;            int en = bv[i].rank(r, fl);&#10;            l = (fl ? zero_cnt[i] : 0) + st;&#10;            r = (fl ? zero_cnt[i] : 0) + en;&#10;        }&#10;        return r - l;&#10;    }&#10;&#10;    // [l, r)内で[0, x)を満たす値の数&#10;    int count_lower(int l, int r, T x){&#10;        int cnt = 0;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (x &gt;&gt; i) &amp; 1;&#10;            int st = bv[i].rank(l, fl);&#10;            int en = bv[i].rank(r, fl);&#10;            if(fl){&#10;                st += zero_cnt[i];&#10;                en += zero_cnt[i];&#10;                cnt += (bv[i].rank(r, 0) - bv[i].rank(l, 0));&#10;            }&#10;            l = st, r = en;&#10;        }&#10;        return cnt;&#10;    }&#10;&#10;    // [l, r)内で[x, y)を満たす値の数&#10;    int count_range(int l, int r, T x, T y){&#10;        return count_lower(l, r, y) - count_lower(l, r, x);&#10;    }&#10;&#10;    // 0-indexedでk番目に小さいものを返す&#10;    T kth_min(int l, int r, int k){&#10;        T ans = 0;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            int st = bv[i].rank(l, 0);&#10;            int en = bv[i].rank(r, 0);&#10;            if(en - st &lt;= k){&#10;                k -= en - st;&#10;                l = zero_cnt[i] + bv[i].rank(l, 1);&#10;                r = zero_cnt[i] + bv[i].rank(r, 1);&#10;                ans |= (1uLL &lt;&lt; i);&#10;            }&#10;            else{&#10;                l = st, r = en;&#10;            }&#10;        }&#10;        return ans;&#10;    }&#10;&#10;    // [l, r)でのx以上最小値&#10;    pair&lt;T, bool&gt; predecessor(int l, int r, T x){&#10;        int idx = count_lower(l, r, x);&#10;        if(idx == r - l){&#10;            return make_pair((1uLL &lt;&lt; W) - 1, false);&#10;        }&#10;        return make_pair(kth_min(l, r, idx), true);&#10;    }&#10;&#10;    // [l, r)でのx以下最大値&#10;    pair&lt;T, bool&gt; successor(int l, int r, T x){&#10;        int idx = count_lower(l, r, x + 1);&#10;        if(idx == 0)&#10;            return make_pair(0, false);&#10;        return make_pair(kth_min(l, r, idx - 1), true);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="xfasttrie" value="// doc: https://shibh308.github.io/library/library/lib/classes/xfasttrie.cpp.html&#10;template &lt;typename T, int W = 31, T HASHMAP_NULL = (1LL &lt;&lt; W) - 1, T HASHMAP_DEL = (1LL &lt;&lt; W) - 2&gt;&#10;struct XFastTrie{&#10;    struct Node{&#10;        T val;&#10;        int exist;&#10;        Node* c[2];&#10;        Node(T val) : val(val), exist(0){&#10;            // 子が存在するなら子へのポインタを持つ&#10;            // 葉なら左右はそれぞれprev,next&#10;            // 左の子が存在しないなら左はprevへのショートカット&#10;            // 右のが存在しないなら右はnextへのショートカット&#10;            c[0] = nullptr;&#10;            c[1] = nullptr;&#10;        }&#10;    };&#10;    int n;&#10;    Node* root;&#10;    Node* front;&#10;    Node* back;&#10;    array&lt;HashMap&lt;T, Node*, HASHMAP_NULL, HASHMAP_DEL&gt;, W&gt; hashmap;&#10;&#10;    XFastTrie() : n(0){&#10;        root = new Node(0);&#10;        front = new Node(0);&#10;        back = new Node(0);&#10;        front-&gt;exist = 2;&#10;        front-&gt;c[1] = back;&#10;        back-&gt;exist = 1;&#10;        back-&gt;c[0] = front;&#10;        root-&gt;c[0] = back;&#10;        root-&gt;c[1] = front;&#10;    }&#10;&#10;    void insert(T key){&#10;        // 存在しているノードは全部葉があると仮定する&#10;        T val = 0;&#10;        Node* ptr = root;&#10;        Node* nex = nullptr;&#10;        Node* pre = nullptr;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            bool exist = (ptr-&gt;exist &gt;&gt; fl) &amp; 1;&#10;            if(fl)&#10;                val += (1LL &lt;&lt; i);&#10;            if(!exist){&#10;                if(!nex){&#10;                    if(fl){&#10;                        pre = ptr-&gt;c[1];&#10;                        nex = pre-&gt;c[1];&#10;                    }&#10;                    else{&#10;                        nex = ptr-&gt;c[0];&#10;                        pre = nex-&gt;c[0];&#10;                    }&#10;                }&#10;                ptr-&gt;exist |= (1 &lt;&lt; fl);&#10;                ptr-&gt;c[fl] = new Node(val);&#10;                hashmap[i].add(val, ptr-&gt;c[fl]);&#10;                ptr-&gt;c[fl]-&gt;c[0] = back;&#10;                ptr-&gt;c[fl]-&gt;c[1] = front;&#10;            }&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        if(nex == nullptr)&#10;            return;&#10;        ++n;&#10;        assert(nex == back || key &lt; nex-&gt;val);&#10;        assert(pre == front || pre-&gt;val &lt; key);&#10;        pre-&gt;c[1] = ptr;&#10;        ptr-&gt;c[1] = nex;&#10;        nex-&gt;c[0] = ptr;&#10;        ptr-&gt;c[0] = pre;&#10;        assert(val == key &amp;&amp; ptr-&gt;val == key);&#10;&#10;        Node* new_node = ptr;&#10;        ptr = root;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            if(!(ptr-&gt;exist &amp; 1) &amp;&amp; (ptr-&gt;c[0] == back || key &lt; ptr-&gt;c[0]-&gt;val)){&#10;                ptr-&gt;c[0] = new_node;&#10;            }&#10;            if(!(ptr-&gt;exist &amp; 2) &amp;&amp; (ptr-&gt;c[1] == front || ptr-&gt;c[1]-&gt;val &lt; key)){&#10;                ptr-&gt;c[1] = new_node;&#10;            }&#10;            ptr = ptr-&gt;c[(key &gt;&gt; i) &amp; 1];&#10;        }&#10;    }&#10;&#10;    void erase(T key){&#10;        Node* ptr = root;&#10;        Node* cut_ptr = nullptr;&#10;        bool cut_fl = false;&#10;        stack&lt;Node*&gt; node_stack;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            if(!((ptr-&gt;exist &gt;&gt; fl) &amp; 1))&#10;                return;&#10;            if((ptr-&gt;exist &gt;&gt; (!fl)) &amp; 1){&#10;                while(!node_stack.empty())node_stack.pop();&#10;                cut_ptr = ptr;&#10;                cut_fl = fl;&#10;            }&#10;            else if(i != W - 1)&#10;                node_stack.push(ptr);&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        Node* target = ptr;&#10;        Node* pre = target-&gt;c[0];&#10;        Node* nex = target-&gt;c[1];&#10;        if(nex == nullptr || target-&gt;val != key)&#10;            return;&#10;        pre-&gt;c[1] = nex;&#10;        nex-&gt;c[0] = pre;&#10;        int h = 0;&#10;        for(int i = 0; !node_stack.empty(); ++i){&#10;            Node* node = node_stack.top();&#10;            hashmap[i + 1].erase(node-&gt;val);&#10;            node_stack.pop();&#10;            assert(node != target);&#10;        }&#10;        hashmap[0].erase(key);&#10;        if(!cut_ptr){&#10;            *this = XFastTrie();&#10;            return;&#10;        }&#10;        cut_ptr-&gt;c[cut_fl] = cut_fl ? pre : nex;&#10;        cut_ptr-&gt;exist &amp;= ~(1 &lt;&lt; cut_fl);&#10;        ptr = root;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            if(ptr-&gt;c[0] == target){&#10;                ptr-&gt;c[0] = nex;&#10;            }&#10;            if(ptr-&gt;c[1] == target){&#10;                ptr-&gt;c[1] = pre;&#10;            }&#10;            if(!(ptr-&gt;exist &amp; (1 &lt;&lt; fl)))&#10;                break;&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        --n;&#10;        delete(target);&#10;    }&#10;&#10;    Node* lower_bound(T key){&#10;        Node* ptr = root;&#10;        int lb = W, rb = -1;&#10;        int mid;&#10;        bool fl;&#10;        Node* res;&#10;        while(lb - rb &gt; 1){&#10;            mid = (lb + rb) &gt;&gt; 1;&#10;            tie(res, fl) = hashmap[mid].find(key &amp; ~((1LL &lt;&lt; mid) - 1));&#10;            if(fl)&#10;                ptr = res;&#10;            (fl ? lb : rb) = mid;&#10;        }&#10;        if(lb){&#10;            if((key &gt;&gt; rb) &amp; 1)&#10;                ptr = ptr-&gt;c[1]-&gt;c[1];&#10;            else&#10;                ptr = ptr-&gt;c[0];&#10;        }&#10;        return ptr;&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="xfasttrie_yft" value="// doc: https://shibh308.github.io/library/library/lib/classes/xfasttrie_yft.cpp.html&#10;// y-fast trie用のx-fast trie&#10;template &lt;typename T, int W = 31, T HASHMAP_NULL = (1LL &lt;&lt; W) - 1, T HASHMAP_DEL = (1LL &lt;&lt; W) - 2&gt;&#10;struct XFastTrie_yft{&#10;    using SplayNode = typename SplayTree&lt;T&gt;::NodePtr;&#10;    struct Node{&#10;        T val;&#10;        int exist;&#10;        Node* c[2];&#10;        SplayNode node;&#10;        Node(T val) : val(val), exist(0), node(nullptr){&#10;            // 子が存在するなら子へのポインタを持つ&#10;            // 葉なら左右はそれぞれprev,next&#10;            // 左の子が存在しないなら左はprevへのショートカット&#10;            // 右のが存在しないなら右はnextへのショートカット&#10;            c[0] = nullptr;&#10;            c[1] = nullptr;&#10;        }&#10;    };&#10;    int n;&#10;    Node* root;&#10;    Node* front;&#10;    Node* back;&#10;    array&lt;HashMap&lt;T, Node*, HASHMAP_NULL, HASHMAP_DEL&gt;, W&gt; hashmap;&#10;&#10;    XFastTrie_yft() : n(0), hashmap(){&#10;        root = new Node(0);&#10;        front = new Node(0);&#10;        back = new Node(0);&#10;        front-&gt;exist = 2;&#10;        front-&gt;c[1] = back;&#10;        back-&gt;exist = 1;&#10;        back-&gt;c[0] = front;&#10;        root-&gt;c[0] = back;&#10;        root-&gt;c[1] = front;&#10;    }&#10;&#10;    Node* insert(SplayNode node){&#10;        T key = node-&gt;val;&#10;        // 存在しているノードは全部葉があると仮定する&#10;        T val = 0;&#10;        Node* ptr = root;&#10;        Node* nex = nullptr;&#10;        Node* pre = nullptr;&#10;        bool make_flag = false;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            bool exist = (ptr-&gt;exist &gt;&gt; fl) &amp; 1;&#10;            if(fl)&#10;                val += (1LL &lt;&lt; i);&#10;            if(!exist){&#10;                if(!nex){&#10;                    if(fl){&#10;                        pre = ptr-&gt;c[1];&#10;                        nex = pre-&gt;c[1];&#10;                    }&#10;                    else{&#10;                        nex = ptr-&gt;c[0];&#10;                        pre = nex-&gt;c[0];&#10;                    }&#10;                }&#10;                make_flag = true;&#10;                ptr-&gt;exist |= (1 &lt;&lt; fl);&#10;                ptr-&gt;c[fl] = new Node(val);&#10;                hashmap[i].add(val, ptr-&gt;c[fl]);&#10;                ptr-&gt;c[fl]-&gt;c[0] = back;&#10;                ptr-&gt;c[fl]-&gt;c[1] = front;&#10;            }&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        if(!make_flag)&#10;            return nullptr;&#10;        ++n;&#10;        assert(nex == back || key &lt; nex-&gt;val);&#10;        assert(pre == front || pre-&gt;val &lt; key);&#10;&#10;        ptr-&gt;node = node;&#10;        pre-&gt;c[1] = ptr;&#10;        ptr-&gt;c[1] = nex;&#10;        nex-&gt;c[0] = ptr;&#10;        ptr-&gt;c[0] = pre;&#10;        assert(val == key &amp;&amp; ptr-&gt;val == key);&#10;&#10;        Node* new_node = ptr;&#10;        ptr = root;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            if(!(ptr-&gt;exist &amp; 1) &amp;&amp; (ptr-&gt;c[0] == back || key &lt; ptr-&gt;c[0]-&gt;val)){&#10;                ptr-&gt;c[0] = new_node;&#10;            }&#10;            if(!(ptr-&gt;exist &amp; 2) &amp;&amp; (ptr-&gt;c[1] == front || ptr-&gt;c[1]-&gt;val &lt; key)){&#10;                ptr-&gt;c[1] = new_node;&#10;            }&#10;            ptr = ptr-&gt;c[(key &gt;&gt; i) &amp; 1];&#10;        }&#10;        return new_node;&#10;    }&#10;&#10;    bool erase(T key){&#10;        Node* ptr = root;&#10;        Node* cut_ptr = nullptr;&#10;        bool cut_fl = false;&#10;        stack&lt;Node*&gt; node_stack;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            if(!((ptr-&gt;exist &gt;&gt; fl) &amp; 1))&#10;                return false;&#10;            if((ptr-&gt;exist &gt;&gt; (!fl)) &amp; 1){&#10;                while(!node_stack.empty())node_stack.pop();&#10;                cut_ptr = ptr;&#10;                cut_fl = fl;&#10;            }&#10;            else if(i != W - 1)&#10;                node_stack.push(ptr);&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        Node* target = ptr;&#10;        Node* pre = target-&gt;c[0];&#10;        Node* nex = target-&gt;c[1];&#10;        pre-&gt;c[1] = nex;&#10;        nex-&gt;c[0] = pre;&#10;        int h = 0;&#10;        for(int i = 0; !node_stack.empty(); ++i){&#10;            Node* node = node_stack.top();&#10;            hashmap[i + 1].erase(node-&gt;val);&#10;            node_stack.pop();&#10;            assert(node != target);&#10;        }&#10;        hashmap[0].erase(key);&#10;        if(!cut_ptr){&#10;            *this = XFastTrie_yft();&#10;            return true;&#10;        }&#10;        cut_ptr-&gt;c[cut_fl] = cut_fl ? pre : nex;&#10;        cut_ptr-&gt;exist &amp;= ~(1 &lt;&lt; cut_fl);&#10;        ptr = root;&#10;        if(target-&gt;val != key)&#10;            return false;&#10;        for(int i = W - 1; i &gt;= 0; --i){&#10;            bool fl = (key &gt;&gt; i) &amp; 1;&#10;            if(ptr-&gt;c[0] == target){&#10;                ptr-&gt;c[0] = nex;&#10;            }&#10;            if(ptr-&gt;c[1] == target){&#10;                ptr-&gt;c[1] = pre;&#10;            }&#10;            if(!(ptr-&gt;exist &amp; (1 &lt;&lt; fl)))&#10;                break;&#10;            ptr = ptr-&gt;c[fl];&#10;        }&#10;        --n;&#10;        delete(target);&#10;        return true;&#10;    }&#10;&#10;    Node* lower_bound(T key){&#10;        Node* ptr = root;&#10;        int lb = W, rb = -1;&#10;        while(lb - rb &gt; 1){&#10;            int mid = (lb + rb) &gt;&gt; 1;&#10;            bool fl;&#10;            Node* res;&#10;            tie(res, fl) = hashmap[mid].find(key &amp; ~((1LL &lt;&lt; mid) - 1));&#10;            if(fl)&#10;                ptr = res;&#10;            (fl ? lb : rb) = mid;&#10;        }&#10;        if(!lb)return ptr;&#10;        int fl = (key &gt;&gt; rb) &amp; 1;&#10;        return fl ? ptr-&gt;c[fl]-&gt;c[1] : ptr-&gt;c[fl];&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="yfasttrie" value="// doc: https://shibh308.github.io/library/library/lib/classes/yfasttrie.cpp.html&#10;// 乱択で挿入先を決めるy-fast trie&#10;template &lt;typename T, int W = 31, T HASHMAP_NULL = (1LL &lt;&lt; W) - 1, T HASHMAP_DEL = (1LL &lt;&lt; W) - 2&gt;&#10;struct YFastTrie{&#10;&#10;    static uint32_t rnd(){&#10;        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = 0; // time(0);&#10;        uint32_t t = x ^ (x &lt;&lt; 11);&#10;        x = y, y = z, z = w;&#10;        w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;        return w;&#10;    }&#10;&#10;    using SplayNode = typename SplayTree&lt;T&gt;::NodePtr;&#10;    int n;&#10;    XFastTrie_yft&lt;T, W, HASHMAP_NULL, HASHMAP_DEL&gt; xft;&#10;    SplayTree&lt;T&gt; splay;&#10;&#10;    YFastTrie() : n(1), xft(), splay(){&#10;        SplayNode node = splay.make((1LL &lt;&lt; W) - 1);&#10;        xft.insert(node);&#10;    }&#10;&#10;    SplayNode lower_bound(T key){&#10;        auto xft_ptr = xft.lower_bound(key);&#10;        assert(xft_ptr != xft.back);&#10;        return xft_ptr-&gt;node = splay.lower_bound(xft_ptr-&gt;node, key).first;&#10;    }&#10;&#10;    bool insert(T key){&#10;        auto xft_ptr = xft.lower_bound(key);&#10;         pair&lt;SplayNode , bool&gt; res;&#10;        if(xft_ptr-&gt;val == key)&#10;            return false;&#10;        if(rnd() % W == 0){&#10;            res = splay.lower_bound(xft_ptr-&gt;node, key);&#10;            assert(res.second);&#10;            SplayNode l;&#10;            tie(l, xft_ptr-&gt;node) = splay.split(res.first);&#10;            assert(xft_ptr-&gt;node != splay.nil);&#10;            res = splay.insert(l, key);&#10;            n += res.second;&#10;            assert(res.first != splay.nil);&#10;            xft.insert(splay.access(res.first, res.first-&gt;size - 1));&#10;        }&#10;        else{&#10;            res = splay.insert(xft_ptr-&gt;node, key);&#10;            n += res.second;&#10;            xft_ptr-&gt;node = res.first;&#10;        }&#10;        return res.second;&#10;    }&#10;&#10;    bool erase(T key){&#10;        pair&lt;SplayNode, bool&gt; res;&#10;        auto xft_ptr = xft.lower_bound(key);&#10;        if(xft_ptr-&gt;val == key){&#10;            auto r = xft_ptr-&gt;c[1];&#10;            r-&gt;node = splay.merge(xft_ptr-&gt;node, r-&gt;node);&#10;            res = splay.erase(r-&gt;node, key);&#10;            r-&gt;node = res.first;&#10;            if(res.second){&#10;                xft_ptr-&gt;node = nullptr;&#10;                xft.erase(xft_ptr-&gt;val);&#10;            }&#10;        }&#10;        else{&#10;            res = splay.erase(xft_ptr-&gt;node, key);&#10;            xft_ptr-&gt;node = res.first;&#10;        }&#10;        n -= res.second;&#10;        return res.second;&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="yfasttrie2" value="// doc: https://shibh308.github.io/library/library/lib/classes/yfasttrie2.cpp.html&#10;// サイズを保つようにsplit/mergeをするy-fast trie&#10;template &lt;typename T, int W = 31, T HASHMAP_NULL = (1LL &lt;&lt; W) - 1, T HASHMAP_DEL = (1LL &lt;&lt; W) - 2&gt;&#10;struct YFastTrie2{&#10;&#10;    using SplayNode = typename SplayTree&lt;T&gt;::NodePtr;&#10;    int n;&#10;    XFastTrie_yft&lt;T, W, HASHMAP_NULL, HASHMAP_DEL&gt; xft;&#10;    SplayTree&lt;T&gt; splay;&#10;&#10;    YFastTrie2() : n(1), xft(), splay(){&#10;        SplayNode node = splay.make((1LL &lt;&lt; W) - 1);&#10;        xft.insert(node);&#10;    }&#10;&#10;    SplayNode lower_bound(T key){&#10;        auto xft_ptr = xft.lower_bound(key);&#10;        assert(xft_ptr != xft.back);&#10;        auto res = splay.lower_bound(xft_ptr-&gt;node, key);&#10;        xft_ptr-&gt;node = res.first;&#10;        if(!res.second){&#10;            xft_ptr = xft_ptr-&gt;c[1];&#10;            xft_ptr-&gt;node = splay.access(xft_ptr-&gt;node, 0);&#10;        }&#10;        return xft_ptr-&gt;node;&#10;    }&#10;&#10;    bool insert(T key){&#10;        auto xft_ptr = xft.lower_bound(key);&#10;        auto res = splay.insert(xft_ptr-&gt;node, key);&#10;        xft_ptr-&gt;node = res.first;&#10;        n += res.second;&#10;        split(xft_ptr);&#10;        return res.second;&#10;    }&#10;&#10;    bool erase(T key){&#10;        auto xft_ptr = xft.lower_bound(key);&#10;        auto res = splay.erase(xft_ptr-&gt;node, key);&#10;        assert(res.first != splay.nil);&#10;        xft_ptr-&gt;node = res.first;&#10;        n -= res.second;&#10;        merge(xft_ptr);&#10;        return res.second;&#10;    }&#10;&#10;    void split(typename XFastTrie_yft&lt;T, W&gt;::Node* xft_node){&#10;        if(xft_node-&gt;node-&gt;size &lt;= (W &lt;&lt; 1))&#10;            return;&#10;        SplayNode l, r;&#10;        tie(l, r) = splay.split(splay.access(xft_node-&gt;node, xft_node-&gt;node-&gt;size &gt;&gt; 1));&#10;        xft_node-&gt;node = r;&#10;        l = splay.access(l, l-&gt;size - 1);&#10;        xft.insert(l);&#10;    }&#10;&#10;    void merge(typename XFastTrie_yft&lt;T, W&gt;::Node* xft_ptr){&#10;        if(xft_ptr-&gt;node-&gt;size &gt;= (W &gt;&gt; 2))&#10;            return;&#10;        if(xft_ptr-&gt;c[0] != xft.front)&#10;            merge(xft_ptr-&gt;c[0], xft_ptr);&#10;        else if(xft_ptr-&gt;c[1] != xft.back)&#10;            merge(xft_ptr, xft_ptr-&gt;c[1]);&#10;    }&#10;&#10;    void merge(typename XFastTrie_yft&lt;T, W&gt;::Node* xft_l, typename XFastTrie_yft&lt;T, W&gt;::Node* xft_r){&#10;        xft_r-&gt;node = splay.merge(xft_l-&gt;node, xft_r-&gt;node);&#10;        xft_l-&gt;node = nullptr;&#10;        xft.erase(xft_l-&gt;val);&#10;        split(xft_r);&#10;    }&#10;};&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="zdd" value="// doc: https://shibh308.github.io/library/library/lib/classes/zdd.cpp.html&#10;struct ZDD{&#10;    struct Node{&#10;        int label;&#10;        using Index = typename MemoryPool&lt;Node&gt;::Index;&#10;        Index c[2];&#10;        Node(){}&#10;        Node(int label, Index nil) : label(label){&#10;            c[0] = c[1] = nil;&#10;        }&#10;        Node(int label, Index l, Index r) : label(label){&#10;            c[0] = l;&#10;            c[1] = r;&#10;        }&#10;    };&#10;    using Index = typename MemoryPool&lt;Node&gt;::Index;&#10;    Index nil, true_idx, false_idx;&#10;    MemoryPool&lt;Node&gt; pool;&#10;    // 引数は(Data, label, 最後どう進んだか)&#10;    // secondが-1ならDataを表す, 0/1なら終端状態を表す&#10;    ZDD(){&#10;        nil = {-1};&#10;        true_idx = {-2};&#10;        false_idx = {-3};&#10;    }&#10;    template&lt;typename Data&gt;&#10;    Index build(function&lt;pair&lt;Data, int&gt;(Data, int, bool)&gt; f, Data init){&#10;        unordered_map&lt;int, map&lt;Data, Index&gt;&gt; node_map;&#10;        Index root = pool.alloc();&#10;        pool[root] = Node(0, nil);&#10;        node_map[0][init] = root;&#10;        build&lt;Data&gt;(root, init, f, node_map);&#10;        return compress(root);&#10;    }&#10;    template&lt;typename Data&gt;&#10;    void build(Index pi, Data&amp; d, function&lt;pair&lt;Data, int&gt;(Data, int, bool)&gt;&amp; f, unordered_map&lt;int, map&lt;Data, Index&gt;&gt;&amp; node_map){&#10;        auto&amp; x = pool[pi];&#10;        for(int i = 0; i &lt; 2; ++i){&#10;            int fl;&#10;            Data y;&#10;            tie(y, fl) = f(d, x.label, i);&#10;            if(fl == 0){&#10;                x.c[i] = false_idx;&#10;            }&#10;            else if(fl == 1){&#10;                x.c[i] = true_idx;&#10;            }&#10;            else if(node_map[x.label + 1].find(y) == node_map[x.label + 1].end()){&#10;                Index new_idx = pool.alloc();&#10;                pool[new_idx] = Node(x.label + 1, nil);&#10;                node_map[x.label + 1][y] = new_idx;&#10;                x.c[i] = new_idx;&#10;                build(node_map[x.label + 1][y], y, f, node_map);&#10;            }else{&#10;                x.c[i] = node_map[x.label + 1][y];&#10;            }&#10;        }&#10;    }&#10;    Index compress(Index pi, unordered_map&lt;int, unordered_map&lt;uint64_t, Index&gt;&gt;&amp; node_map, unordered_map&lt;int, Index&gt;&amp; replace_map){&#10;        // 同型で子が一致する頂点を破滅&#10;        if(pi == true_idx || pi == false_idx)&#10;            return pi;&#10;        if(replace_map.find(pi.idx) != replace_map.end())&#10;            return replace_map[pi.idx];&#10;        auto&amp; p = pool[pi];&#10;        Index li = compress(p.c[0], node_map, replace_map);&#10;        Index ri = compress(p.c[1], node_map, replace_map);&#10;        p.c[0] = li;&#10;        p.c[1] = ri;&#10;        uint64_t h = uint32_t(li.idx) | ((1uLL * uint32_t(ri.idx)) &lt;&lt; 32);&#10;        if(node_map[p.label].find(h) == node_map[p.label].end())&#10;            node_map[p.label][h] = pi;&#10;        else&#10;            pool.free(pi);&#10;        return replace_map[pi.idx] = node_map[p.label][h];&#10;    }&#10;    Index compress(Index pi){&#10;        unordered_map&lt;int, unordered_map&lt;uint64_t, Index&gt;&gt; node_map;&#10;        unordered_map&lt;int, Index&gt; replace_map;&#10;        return compress(pi, node_map, replace_map);&#10;    }&#10;    i64 linear_func_max(Index pi, vector&lt;i64&gt;&amp; a, unordered_map&lt;int, i64&gt;&amp; res){&#10;        if(pi == true_idx)&#10;            return 0;&#10;        if(pi == false_idx)&#10;            return -INF;&#10;        if(res.find(pi.idx) == res.end())&#10;            res[pi.idx] = max(linear_func_max(pool[pi].c[0], a, res), linear_func_max(pool[pi].c[1], a, res) + a[pool[pi].label]);&#10;        return res[pi.idx];&#10;    }&#10;    i64 linear_func_max(Index root, vector&lt;i64&gt; a){&#10;        unordered_map&lt;int, i64&gt; res;&#10;        return linear_func_max(root, a, res);&#10;    }&#10;    i64 count(Index pi, unordered_map&lt;int, i64&gt;&amp; res){&#10;        if(pi == true_idx)&#10;            return 1;&#10;        if(pi == false_idx)&#10;            return 0;&#10;        if(res.find(pi.idx) == res.end())&#10;            res[pi.idx] = count(pool[pi].c[0], res) + count(pool[pi].c[1], res);&#10;        return res[pi.idx];&#10;    }&#10;    i64 count(Index root){&#10;        unordered_map&lt;int, i64&gt; res;&#10;        return count(root, res);&#10;    }&#10;    double get_per(Index pi, vector&lt;double&gt;&amp; a, unordered_map&lt;int, double&gt;&amp; res){&#10;        if(pi == true_idx)&#10;            return 1;&#10;        if(pi == false_idx)&#10;            return 0;&#10;        if(res.find(pi.idx) == res.end())&#10;            res[pi.idx] = a[pool[pi].label] * get_per(pool[pi].c[0], a, res) + (1.0 - a[pool[pi].label]) * get_per(pool[pi].c[1], a, res);&#10;        return res[pi.idx];&#10;    }&#10;    double get_per(Index root, vector&lt;double&gt;&amp; a){&#10;        unordered_map&lt;int, double&gt; res;&#10;        return get_per(root, a, res);&#10;    }&#10;    Index apply(Index li, Index ri, function&lt;Index(Index, Index)&gt;&amp; f, unordered_map&lt;uint64_t, Index&gt;&amp; node_map){&#10;        Index res = f(li, ri);&#10;        if(res != nil)&#10;            return res;&#10;        int lidx, ridx;&#10;        tie(lidx, ridx) = minmax(li.idx, ri.idx);&#10;        uint64_t h = lidx | ((1uLL * ridx) &lt;&lt; 32);&#10;        if(node_map.find(h) != node_map.end())&#10;            return node_map[h];&#10;        if(pool[li].label &lt; pool[ri].label)&#10;            swap(li, ri);&#10;        auto&amp; l = pool[li];&#10;        auto&amp; r = pool[ri];&#10;        Index idx = pool.alloc();&#10;        if(l.label == r.label)&#10;            pool[idx] = Node(l.label, apply(l.c[0], r.c[0], f, node_map), apply(l.c[1], r.c[1], f, node_map));&#10;        else&#10;            pool[idx] = Node(l.label, apply(l.c[0], ri, f, node_map), apply(l.c[1], ri, f, node_map));&#10;        return node_map[h] = idx;&#10;    }&#10;    Index apply_and(Index li, Index ri){&#10;        unordered_map&lt;uint64_t, Index&gt; node_map;&#10;        function&lt;Index(Index, Index)&gt; f = [&amp;](Index li, Index ri){&#10;            if(li == true_idx)&#10;                return ri;&#10;            if(ri == true_idx)&#10;                return li;&#10;            if(li == false_idx || ri == false_idx)&#10;                return false_idx;&#10;            else&#10;                return nil;&#10;        };&#10;        return apply(li, ri, f, node_map);&#10;    }&#10;    Index apply_or(Index li, Index ri){&#10;        unordered_map&lt;uint64_t, Index&gt; node_map;&#10;        function&lt;Index(Index, Index)&gt; f = [&amp;](Index li, Index ri){&#10;            if(li == false_idx)&#10;                return ri;&#10;            if(ri == false_idx)&#10;                return li;&#10;            if(li == true_idx || ri == true_idx)&#10;                return true_idx;&#10;            else&#10;                return nil;&#10;        };&#10;        return apply(li, ri, f, node_map);&#10;    }&#10;};&#10;&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="geometry" value="// doc: https://shibh308.github.io/library/library/lib/geometry.cpp.html&#10;namespace geometry{&#10;    using D = long double;&#10;    constexpr D eps =1e-9;&#10;&#10;    struct Point;&#10;    bool near_eq(Point, Point);&#10;    D norm(Point);&#10;&#10;    struct Point{&#10;        D x, y;&#10;        Point(D x = 0.0, D y = 0.0) : x(x), y(y){}&#10;        friend bool operator&lt;(const Point&amp; a, const Point&amp; b){&#10;            return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#10;        }&#10;        Point&amp; operator+=(Point a){x += a.x, y += a.y; return *this;}&#10;        Point&amp; operator-=(Point a){x -= a.x, y -= a.y; return *this;}&#10;        Point&amp; operator*=(D p){x *= p, y *= p; return *this;}&#10;        Point&amp; operator*=(Point b){return *this = *this * b;}&#10;        Point&amp; operator/=(D p){x /= p, y /= p; return *this;}&#10;        Point&amp; operator/=(Point b){return *this = *this / b;}&#10;        friend Point operator+(Point a, Point b){return Point(a) += b;}&#10;        friend Point operator-(Point a, Point b){return Point(a) -= b;}&#10;        friend Point operator*(Point a, D p){return Point(a) *= p;}&#10;        friend Point operator*(Point a, Point b){return Point(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);}&#10;        friend Point operator/(Point a, D b){return Point(a) /= b;}&#10;        friend Point operator/(Point a, Point b){return Point(a.x * b.x + a.y * b.y, b.x * a.y - a.x * b.y) / norm(b);}&#10;    };&#10;    using P = Point;&#10;&#10;    struct Circle : public Point{&#10;        D r;&#10;        Circle(Point p = Point(), D r = 1) : Point(p), r(r){}&#10;        Circle(D x = 0.0, D y = 0.0, D r = 1) : Point(x, y), r(r){}&#10;    };&#10;    using C = Circle;&#10;&#10;    bool near_eq(D a, D b = 0.0){return abs(a - b) &lt; eps;}&#10;    bool near_eq(P a, P b = Point()){return near_eq(a.x, b.x) &amp;&amp; near_eq(a.y, b.y);}&#10;    D diag(P a){&#10;        assert(!near_eq(a));&#10;        return atan2(a.y, a.x);&#10;    }&#10;    D norm(P a){return a.x * a.x + a.y * a.y;}&#10;    D abs(P a){return sqrt(norm(a));}&#10;    D dist(P a, P b){return abs(a - b);}&#10;    D dot(P a, P b){return a.x * b.x + a.y * b.y;}&#10;    D cross(P a, P b){return a.x * b.y - a.y * b.x;}&#10;    int ccw(P a, P b, P c){&#10;        b -= a;&#10;        c -= a;&#10;        if(cross(b, c) &gt; eps)return 1;&#10;        if(cross(b, c) &lt; -eps)return -1;&#10;        if(dot(b, c) &lt; -eps)return 2;&#10;        if(norm(b) &lt; norm(c))return -2;&#10;        return 0;&#10;    }&#10;    bool is_on_line(P a1, P a2, P b){return abs(ccw(a1, a2, b)) != -1;}&#10;    bool is_on_segment(P a1, P a2, P b){return !ccw(a1, a2, b);}&#10;    P proj(P a1, P a2, P b){return a1 + dot(a2 - a1, b - a1) / norm(a2 - a1) * (a2 - a1);} // 直線への射影点&#10;    D dist(P a1, P a2, P b){return dist(proj(a1, a2, b), b);}&#10;    bool intersect(P a1, P a2, P b1, P b2){&#10;        return ccw(a1, a2, b1) * ccw(a1, a2, b2) &lt;= 0 &amp;&amp;&#10;               ccw(b1, b2, a1) * ccw(b1, b2, a2) &lt;= 0;&#10;    }&#10;    P cross_point(P a1, P a2, P b1, P b2){&#10;        D d1 = cross(b2 - b1, b1 - a1);&#10;        D d2 = cross(b2 - b1, a2 - a1);&#10;        if(near_eq(d1) &amp;&amp; near_eq(d2))return a1;&#10;        assert(!near_eq(d2));&#10;        return a1 + d1 / d2 * (a2 - a1);&#10;    }&#10;    vector&lt;Point&gt; cross_point(C c1, C c2){&#10;        vector&lt;Point&gt; cross;&#10;        P diff = c2 - c1;&#10;        D d = abs(diff);&#10;        D crl = (norm(diff) + c1.r * c1.r - c2.r * c2.r) / (2 * d);&#10;        if(near_eq(d) || c1.r &lt; abs(crl))&#10;            return cross;&#10;        P abn = diff * P(0, sqrt(c1.r * c1.r - crl * crl) / d);&#10;        P cp = c1 + crl / d * diff;&#10;        cross.push_back(cp + abn);&#10;        if(!near_eq(abn))&#10;            cross.push_back(cp - abn);&#10;        return cross;&#10;    }&#10;    vector&lt;pair&lt;P, P&gt;&gt; tangent_lines(C c1, C c2){ // 共通接線、接線の両端は円との接点&#10;        vector&lt;pair&lt;P, P&gt;&gt; lines;&#10;        D d = dist(c1, c2);&#10;        for(int i = 0; i &lt; 2; ++i){&#10;            D sin =(c1.r - (1 - i * 2) * c2.r) / d;&#10;            if(!(sin * sin &lt; 1 + eps))&#10;                break;&#10;            D cos = sqrt(max(1 - sin * sin, D(0)));&#10;            for(int j = 0; j &lt; 2; ++j){&#10;                P n = (c2 - c1) * P(sin, (1 - j * 2) * cos) / d;&#10;                lines.emplace_back(c1 + c1.r * n, c2 + (1 - i * 2)  * c2.r * n);&#10;                if(cos &lt; eps)&#10;                    break;&#10;            }&#10;        }&#10;        return lines;&#10;    }&#10;}&#10;" discription="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
</templateSet>